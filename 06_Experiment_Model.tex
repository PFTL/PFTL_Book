\chapter{Writing The Experiment Model}\label{chapter:experiment-model}

\section{Objectives}
In the previous chapter, we have seen how to define a model for a device. Models specify the logic behind the use of a device. In the previous chapter, for example, we have implemented the use of units. The manual of the device specifies that values must be integers in a pre-determined range, but working with volts is much handier for the purpose of the experiment we are performing. 

However, models for devices alone are not sufficient perform a complete measurement. For example, we are still missing a way to save data. We are also missing a way of transforming a voltage to a current, or the to perform a scan in a given range. In this chapter, we are going to see how to define a model for the entire experiment. The \emph{experiment model} will include all the steps that build a measurement.

\section{Introduction}
In the \textbf{MVCs} design pattern, the \emph{Model} is where all the logic and experimental decisions should be placed. In the previous chapter, for example, you have decided that you wanted to use voltage as the default units to handle inputs and outputs. However, this is not always the handiest. Imagine you use the same {DAQ} device connected to a piezo stage. Voltage is going to be translated to nanometers or microns, and the program should take it into account. In this book, measuring the IV curve of a diode requires you to measure the current passing through a diode, but the physical quantity that you are actually measuring is a voltage.

Following the \emph{onion principle}, it makes sense to define volts as the default units for the device, because it is what it outputs and what it measures. With a simple example such as the one in this book, it is hard to understand what are the limits for the models of devices and for the experiment. One of the parameters you can think of is about the future. Do you think that the model we have developed can be used by someone else in a different context? For example, if you were to start developing a program for a confocal microscope, would you be able to re-use the {PFTL DAQ} model? If the answer is yes, then it is a good start. The truth is that you can't really know what is going to be the future of your program in a year's time.

In this chapter we are going to add another layer to the onion. So far, we are able to set a and read a voltage with our DAQ device. However, we would like to perform a scan, specifying voltages for start, stop, and step, for example. A model for experiments will allow you to quickly develop the logic that drives a measurement. In a more complex scenario, you may want to switch-on a laser only if a shutter is closed, and then you would like to open the shutter before doing a measurement. In the example that concerns us, measuring the  I-V curve, we are going to deal with inputs and outputs of one device. But remember that in more complicated setups this will most likely not be the case.

Writing an experiment model as a Python class has a twofold advantage. On the one hand, it isnaturally going to lead to reproducible experiments. If you keep track of the parameters you use and do version control on the model, you can go back exactly to the same conditions in which you have performed a specific measurement. On the other hand, there is a more technical benefit in defining the experiment as a class. Once we are ready, the model is going to perform as the backend of our program, and it is going to be very easy to build a Graphical User Interface ({GUI}) on top of it.

\section{Starting the Experiment Class}\label{starting-the-experimentclass}
In section \ref{subsection:loading-the-config}, we have started defining a class that was able to read from a configuration file. We are going to start building on top of it. If you didn't create any files yet, be sure to create a folder called \textbf{Experiment} inside of \textbf{Model}. In that file, create a filled called  \textbf{IV\_Curve.py}. Let's start by defining a class called \texttt{Experiment} with some attributes: 

\begin{minted}{python}
class Experiment:
    def __init__(self, user=None):
        self.user = user
        self.daq = None
        self.properties = {}
\end{minted}

The class defines three attributes: a \mintinline{python}{user}, a \mintinline{python}{daq}, and \mintinline{python}{properties}. The user is set to \mintinline{python}{None} by default, but it is useful to keep track of who is running an experiment and saving its results. The \texttt{daq} attribute is where we are going to keep the DAQ model, and the \texttt{properties} are going to be a dictionary with all the paremetres needed to perform a measurement. 

\exercise{If you want to get the username of the user logged in on the computer, you can try the package \emph{getpass}, which you can test by running \mintinline{python}{getpass.getuser(). Bear in mind that if several users share the same log-in, this approach is useless.}.

It is important to show the kind of functionality we are after in order for you to have a clearer picture of what is missing. The idea is that to perform a measurement, you would write a short script like the one below:

\begin{minted}{pycon}
>>> from Model.experiment import IVCurve
>>> exp = IVCurve(user='Me')
>>> exp.load_properties('Config/experiment.yml')
>>> exp.load_daq()
>>> exp.do_scan()
>>> exp.plot_results()
>>> exp.save_data()
>>> exp.save_meta_data() 
\end{minted}

We import the model of the experiment that we want toperform. Instantiate it with a specific user, in this case just \mintinline{python}{'Me'}. Then we specify the configuration file with the different parameters for the experiment, and load it. We load the daq, based on what the configuration file specifies. To perform a scan, we simply execute \mintinline{python}{do_scan}. In principle, the model could have a quick way of plotting the data and, more importantly, to save the data and metadata needed to reproduce the measurement.

One of the advantages of defining a class for a measurement is that you can also use it in other projects. For example, you could trigger a measurement from a Jupyter notebook and analyze the results directly within it. You can also trigger measurements remotely and you will be able to programmatically change the parameters that you used for a scan. Let's start simple and build on complexity.

\exercise{Write a method for loading the properties from a {YAML} file. Remember that you have already done a version of this in the Lay Out chapter. Store the properties in a dictionary called \texttt{self.properties}}

Once you have a method for loading a {YAML} configuration file, you will also know all the properties that are available
to perform a measurement. It may be hard to understand at the beginning the usefulness of having a separated configuration file. When the program gets largerWhich brings you to the following exercise:

\exercise{Write a \texttt{do\_scan} method that relies on the parameters stored at \texttt{self.properties} to perform a measurement. Assume that \texttt{self.daq} is the model for the daq we are going to use. Store the data of the measurement in an attribute of the experiment class, remember that stylistic rules say that you should add every new attribute to the \texttt{\_\_init\_\_} method of the class.}

The two previous exercises are based on things that we have done more than once in the previous chapters. But in this chapter we are systematizing all these information. Clear programs are great not only to yourself but also to other developers and users of your code. Moreover, once you start using the class in a real scenario, you will really appreciate the advantages of this approach.

\exercise{Write a method for saving the metadata of your experiment, i.e., all the information stored in the \texttt{self.properties} dictionary. \textbf{TIP}: Where do you save the data? Perhaps you can add one more parameter to the original {YAML} file to specify the destination folder.}

So far, you have developed the basic methods for performing an experiment and saving its data to a file. We are missing the crucial step of loading the {DAQ} model into the experiment model. There are two options to achieve it. The first one is that you manually import and initialize the {DAQ} and then you pass it to the experiment model. The second is to load the appropriate daq based on what is defined in the configuration file.

The code for the first option would look like this:

\begin{minted}{python}
from PythonForTheLab.Model.DAQ.simple_daq import AnalogDaq
from Model.experiment import DaqControl

daq = AnalogDaq()
daq.initialize()

e = DaqControl(user='me')
e.load_daq(daq)
\end{minted}

While the code for the second option looks like this:

\begin{minted}{python}
from Model.experiment import DaqControl

config_file = 'Config/experiment.yml'
e = DaqControl(user='me')
e.load_config(config_file)
e.load_daq()
\end{minted}

The two approaches are very different and is worth discussing their advantages and dissadvantages. In the first one, we are
importing the daq, we initialize it, and then we add it to the experiment class through the method \texttt{load\_daq}. This approach is quick, because the experiment model doesn't need to do much, just to accept the DAQ and store it within itself. If you want to use a different DAQ device, you would alter the code above, importing the proper model, etc. At first sight, this approach may seem simple enough, however, it will become harder when you are dealing with several devices which can be changed. Moreover, future users of your code need to be comfortable editing Python files. 

The second approach involves loading a module based on information stored as a string on a file, which is slightly more complicated programmatically speaking. One of the advantages of this approach is that the information on the devices used is automatically saved as metadata. The other advantage is that we are really splitting the code itself from the peculiarities of our own experiment. This approach is also a good opportunity to learn few new things about Python. 

In the next sections, we are going to start with the first approach and then we are going to change the code to work as in the second approach. This is called refactoring the code. Therfore, we are going to see not only the practical approach to solving the problem of loading the DAQ to the program, but also how to work with programs that may be in use by more people at the same time. 

\subsection{Loading a DAQ}\label{loading-a-daq}
We are going to start with the simplest approach, which consists of importing and initializing the daq outside of the experiment model and then load it to the \emph{model}. The method \mintinline{python}{load_daq} will look like this:

\begin{minted}{python}
def load_daq(self, daq):
    self.daq = daq
    self.properties['Experiment']['DAQ']['name'] = str(self.daq)
    self.properties['Experiment']['DAQ']['port'] = self.daq.port
\end{minted}

The code is straightforward. The \mintinline{python}{load_daq} method gets one
argument, daq, that is stored into the class property \mintinline{python}{self.daq}.
You also update the \mintinline{python}{properties} dictionary to keep the name of
the model that you are using. There are few things that need to be
addressed. First, is to check what happens when you do
\mintinline{python}{str(self.daq)}. Open a terminal and start python.

\begin{minted}{python}
>>> from Model.daq import DummyDaq
>>> daq = DummyDaq(port=1)
>>> str(daq)
'<dummy_daq.DummyDaq object at 0x7fe8c53c0c50>'
\end{minted}

The result of doing \mintinline{python}{str(daq)} may not be what you were
expecting. It is, however, a good starting point, because it allows you
to identify which class did you use to define the daq. Fortunately, this
can be improved. Open the file where you store the \mintinline{python}{DummyDaq}
class and add the following to it:

\begin{minted}{python}
def __str__(self):
    return "DummyDaq"
\end{minted}

If you repeat the steps above, you will see that now, the output of
doing \mintinline{python}{str(daq)} is exactly \mintinline{python}{"DummyDaq"}. The
\mintinline{python}{__str__} method of a class tells Python how to convert an
object to a string. It is also responsible for the behavior of
\mintinline{python}{print(daq)}. Now you will have a nicely formatted string to
store in your \mintinline{python}{properties} dictionary. Remember that if you
assign the same output for the \mintinline{python}{__str__} method, to two
different classes, you won't be able to distinguish which one you used.

There is something else that is worth learning at this stage. If the
user supplies a class, you won't be certain that it is the correct
class. It is wise to verify every user input that can alter the
functioning of the program. For example, loading the daq can happen at
the beginning of your code, but perhaps you use it much later. If an
error occurs because it was the wrong class the program is going to
crash and you are going to lose very valuable time because of a
simple mistake.

If you think about what the {DAQ} Models have in common, you should
realize that it is that both of them are child classes of the DAQBase
class. Therefore, if you want to know if you are dealing with the proper
model, you should check whether the daq variable that \mintinline{python}{load_daq}
is getting is actually derived from the base model. There is no easy way
of doing this in Python, and therefore you can build a workaround.
First, update the base model for the daq, adding a property called
\mintinline{python}{_type}:

\begin{minted}{python}
class DAQBase(object):
    _type = 'DAQModel'
    def __init__(self, port):
        pass
\end{minted}

Every child of \mintinline{python}{DAQBase} will have a property called
\mintinline{python}{_type} that can be used to identify the model. Therefore, you
can update the \mintinline{python}{load_daq} in the experiment model with
the following:

\begin{minted}{python}
def load_daq(self, daq):
    if daq._type is not 'DAQModel':
        raise Exception('The DAQ Model specified \
                    should be a child of DAQ Base')
    [...]
\end{minted}

It is not a particularly elegant solution, but it works in most cases.
Remember that with this approach you should be consistent in the naming
conventions. If different models end up being called DAQModel, the check
may give you unexpected warnings. The same works for the
\mintinline{python}{__str__} method since you are using it to identify the
model you used, if two different models end up calling themselves in the
same way, you won't be able to tell which one you used.

The first approach on how to load the daq model into the experiment is
relatively easy. Now it is time to work on the second approach. The idea
is that you will load a specific class based on what the {YAML} file
specifies. In the first approach, you have updated the properties of the
experiment model, adding an extra key called \mintinline{python}{DAQ}. Therefore,
you should do the same in the {YAML} file \textbf{experiment.yml}:

\begin{minted}{python}
User: me
DAQ:
  name: DummyDaq
  port: 0
\end{minted}

Next time you use the method \mintinline{python}{load_config}, you will also have a
key for the {DAQ}. Importing a module into Python can also be done
within a function, at any step of the program. You can also do it within
the \mintinline{python}{load_daq} method of the Experiment class. Since you want to
be able to provide a daq externally, you have to do the following:

\begin{minted}{python}
def load_daq(self, daq=None):
    if daq is None:
        name = self.properties['Experiment']['DAQ']['name']
        port = self.properties['Experiment']['DAQ']['port']
        if name == 'DummyDaq':
            from PythonForTheLab.Model.daq import DummyDaq
            self.daq = DummyDaq(port)
        
        elif self.properties['DAQ']['name'] == 'RealDaq':
            from PythonForTheLab.Model.daq import AnalogDaq
            self.daq = AnalogDaq(port)
        
        else:
            raise Exception('The daq specified is not yet supported')
    
    else:
        # Here goes the same code you had before
\end{minted}

The first to notice is that we have added a default value for the
\mintinline{python}{daq} argument. Adding a default value allows you to use the
method both as \mintinline{python}{load_daq()} and as \mintinline{python}{load_daq(daq)}. If
you call the method without an argument, \mintinline{python}{if daq is None} will
be \mintinline{python}{True}. The way of importing the different models is quite
straightforward, you check the name and make the import. However, it is
not very flexible. If you ever add a model for a new device, you need to
manually add it to the experiment model.

\exercise{Go ahead and trigger the exception by defining a name of the {DAQ}
different from `DummyDaq' or `RealDaq'. What happens to the code after
the exception? Does it get executed?}

The way in which you are handling the import of different classes in the code above is not a particularly elegant solution, but it works.
Switching between DAQs is something that can happen, but it won't happen
often enough to justify more complexity at this time. It is worth
noting, however, that if you plan to make your code available to users
with different devices, you should find a less pedestrian way of doing
importing and initializing the classes that you need. However, it is a
more complex behavior, and it will not be discussed in this book. If you
are interested in this and other useful ideas, you can check
\emph{Advance topics for Python in the Lab}.

\section{Defining a Scan}\label{defining-ascan}
The goal of the project is to measure the {IV} curve of a diode.
Therefore, doing a scan means changing an analog voltage output in a
controlled way and, at the same time, recording an analog input. This
kind of measurement is very common in a lot of different experiments,
not only for electronics.

\exercise{Think at least three different examples of experiments that you can
perform by changing an analog output and recording an analog input.}

Performing a scan requires some parameters, that you should have defined
in previous chapters, in any case, you can find them below as well.

\begin{minted}{yaml}
Scan:
  port_in: 2
  port_out: 1
  start: 0.1V
  stop: 0.7V
  step: 0.1V
  delay: 10ms
\end{minted}

\mintinline{python}{port_in} and \mintinline{python}{port_out} are the numbers of the ports
needed for the scan, i.e., the analog in and the analog out.
\mintinline{python}{start}, \mintinline{python}{stop} and \mintinline{python}{step} are the analog output
parameters, note that units are added, and we will see how to deal with
them later. It is important to point out that they don't need to have
the same unit but they have to be the same quantity. For example, you
can mix \mintinline{python}{mV}, \mintinline{python}{nV}, \mintinline{python}{V}, etc. The delay means how
often the output is going to change from one value to the next.

The advantage of starting by defining the parameters in a {YAML} file is
that now you know what parameters do you have available and what are
their names. The next step is to create the method for doing the scan.
You have already done the scan before, so you can adapt the code that
you have developed in the past. If you remember, the general idea is to
generate an output and record an input within a \emph{for loop} with the
range given by \mintinline{python}{start}, \mintinline{python}{stop} and \mintinline{python}{step}. You
should have something like this:

\begin{minted}{python}
def do_scan(self):
    scan_params = self.properties['Experiment']['Scan']
    
    start = scan_params['start']
    stop = scan_params['stop']
    step = scan_params['step']
    port_in = scan_params['port_in']
    port_out = scan_params['port_out']
    delay = scan_params['delay']

    num_points = int((start-stop)/step) + 1

    scan_values = np.linspace(start, stop, num_points)

    for value in scan_values:
        value = value
        self.daq.set_analog_value(port_out, value)
        data = self.read_analog(port_in)
            sleep(delay)
\end{minted}

The code is quite clear. The first step is to store the parameters of
the scan into a variable called \mintinline{python}{scan_params}. This is only a
way of shortening the amount of typing required later on. The loop is
responsible for changing the output value and reading the analog input.
As you can probably see, there are some issues that you will need to
solve, one by one.

\exercise{In the loop, the variable \mintinline{python}{data} is being overwritten on every
step. This is not what you want if you intend to do anything with it.
Store the information into an array. The array should be a property of
the class, i.e. it should be defined in the \mintinline{python}{__init__} method
and you can refer to it as \mintinline{python}{self.NAME_OF_VARIABLE}.}

The advantage of having the data stored in a property is that it
becomes available to other methods of the class and that it is
accessible from outside of it, for example for plotting. However,
storing the data is only one of the concerns that need to be addressed.
The other one is that the parameters that you are using have units
attached to them, and yaml is reading them as a string that needs to be
transformed into units.

We have covered how to use units in Python when you developed the first
driver for the {PFTL} {DAQ}. You have to use the Unit Registry from a
package called Pint. The code looked like this:

\begin{minted}{pycon}
>>> from pint import UnitRegistry
>>> ur = UnitRegistry()
>>> var = ur.Quantity('5V')
\end{minted}

With this code, \emph{Pint} interprets a string,
\mintinline{python}{'5V'} and transforms it into a
quantity. You could add the same code at the beginning of the
\emph{experiment} model, and transform the parameters when you use them,
or you can have a more elegant approach. In the root of your project,
the folder that contains the folders \emph{Model}, \emph{View} and
\emph{Controller}, create a file called \textbf{\_\_init\_\_.py} and add
the following code to it:

\begin{minted}{python}
from pint import UnitRegistry
ureg = UnitRegistry()
Q_ = ureg.Quantity
\end{minted}

At the top of the file where you define the experiment model, you
can add:

\begin{minted}{python}
from PythonForTheLab import Q_
\end{minted}

And you can use \mintinline{python}{Q_} for transforming the parameters into
quantities, simply doing \mintinline{python}{Q_(parameter)}.

\exercise{Update the code to transform each one of the appropriate parameters to a
Quantity. Remember that the port numbers are supposed to be integers,
not quantities.}

Once you start working with units, you need to take care of other
concerns. For example, to calculate the number of points in your scan,
you should transform all the parameters to the same quantity. One of the
possible ways of doing it is by picking the units of one of the
parameters, like this:

\begin{minted}{python}
units = start.u
stop = stop.to(units)
step = step.to(units)
num_points = (stop-start)/step
num_points = int(num_points.m_as(''))+1
\end{minted}

The \mintinline{python}{u} grabs the units from a \emph{Quantity}. You transform
everything into the same units to avoid problems with the number of
points you are computing. However, when dividing quantities, the result
will be another quantity, just that \emph{dimensionless}. To transform
it to a number, you have to append
\mintinline{python}{.m_as('')}. Doing
\mintinline{python}{num_points.m_as('')} means
that you want to take the magnitude of the variable, without units, and
the \mintinline{python}{''} are there because we
are dealing with a dimensionless quantity. It is possible to do things
like \mintinline{python}{start.m_as('pV')}.

There is one more parameter that you need to take care of. The
\mintinline{python}{delay} has units of time, and the function \mintinline{python}{sleep} takes
seconds as an argument. The easiest way to deal with it is simply
writing the following:

\begin{minted}{python}
sleep(delay.m_as('s'))
\end{minted}

Which ensures that you use the delay magnitude expressed in seconds. If
you use milliseconds or hours for that matter, it will be translated
into the proper number before the \mintinline{python}{sleep} function uses it. With
this changes, your code is ready for performing a scan. There are some
concerns, such as how do you stop a scan while it is running. But the
core ideas and methods are already there.

\section{Dummy DAQ}\label{dummy-daq}
The previous sections have been focused onto developing a model for interacting with the real device that drives your experiment. However, when you develop software for the lab, sometimes you would like to test your program without having the real device
connected to the computer. It can be a safety precaution or simply because you are not working on the lab computer. To achieve this, you
can define a fake model that generates fake data. We like calling fake devices of \textbf{dummy} devices. 

Create a new file called \textbf{dummy\_daq.py} in the folder \textbf{Model}. Add the following code to the file:

\begin{minted}{python}
from PythonForTheLab.Model.daq import DAQBase

class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    def idn(self):
        return self.serial_number
\end{minted}

You start by importing the base class \mintinline{python}{DAQBase}, as you did for
the real \emph{model}, but you don't need the controller since you are
not going to communicate with any device. The class defines a fake
serial, just to be able to return it as if it was the real device. Now
you have to think what do you actually expect from a fake device. Since
you are developing a dummy {DAQ}, you don't need to do anything when
setting a value to an output, but you do need to get a value when you
read back. And you need to use the proper units as well. It can look
something like this:

\begin{minted}{python}
import numpy as np
import pint

from .base import DAQBase

ur = pint.UnitRegistry()
V = ur('V')

class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    
    def __init__(self):
        super().__init__()
    
    def idn(self):
        return self.serial_number
    
    def get_analog_value(self, port):
        return np.random.random(1)*V
\end{minted}

The \mintinline{python}{idn} is quite clear, it just returns the serial number that
was defined during initialization. The \mintinline{python}{get_analog_value}
accepts a port as a parameter, even if they don't use it, but you need
to keep the compatibility with what was already defined. The value that
is returned is a random number with volts as units. Remember that the
random generator outputs values only between 0 and 1. You can try to run
the test, but using this DummyClass instead. Open the file
\textbf{test\_daq.py}, and replace the line:

\begin{minted}{python}
# from analog_daq import AnalogDaq
from dummy_daq import DummyDaq as AnalogDaq
\end{minted}

And run \textbf{test\_daq.py}. You will see that an error appears
because you are using the \mintinline{python}{initialize} method in the test, but it
is not defined within the class. This happened because you included
\mintinline{python}{initialize} in the
\mintinline{python}{AnalogDaq} but you never added it to the DAQBase.
Now you see the power that being organized and systematic has. Keeping
track of the methods in a general, base class, allows you not to make
the same mistakes. Moreover, it would have allowed you to run the test
without issues.

\exercise{Add an \mintinline{python}{initialize} method into the base class.}

If you run the test after completing the exercise, you will see that
there are no errors appearing, even if you don't modify the dummy class.
Now you see that you can exchange the models in a relatively simple way,
and the script that is responsible for measuring works without problems.
Of course, this is a simple example, where you exchange a real device
for a dummy one, but if you would have two different devices, exchanging
them would have been just as simple and the measurement would have
been performed.

\exercise{Make the \mintinline{python}{get_analog_value} return the value of a sine function
and not just a random value.}

\section{Conclusions}\label{conclusions}
With this chapter, the core code for a functioning experiment is
finished. Since the beginning of the book, you have developed from a
driver to the logic of how to perform a scan, including how to use text
files to store the parameters that you need. Of course there are things
that can be done better but, in any case, what you have achieved so far
is functioning and useful.

When you develop your own program, it can be wise to start with the
experiment model. Once you established the steps of a measurement it
will become clear what do you need to develop in order to achieve it. It
is a good way of being focused on a clear objective. If you are
developing a driver, or a model, without knowing to what end, you may
end up creating methods and options that you don't really need.

In this chapter, you also start to realize that if you plan to open your
code to others, not just as developers, but as users, you will need to
verify the input that they supply. For example, you learned how to
verify that the {DAQ} model is actually what you want. Following that
idea, there are several improvements to your code, for example, you can
check if the units of the parameters used are correct.

\section{Extras: Defining a Monitor}\label{extras-defining-amonitor}
The clear objective of the book is to show you how to build the software
that you need in order to measure an I-V curve of a diode. However,
there are some other options that you can add to the program, such as
continuous monitoring of a signal. In a lot of experiments, measuring a
signal is all you need, especially in the phase of setting up. Imagine
that you are monitoring a temperature, perhaps you need to wait until it
reaches a certain value, or you monitor the signal generated by a
photodiode in order to align a laser.

Monitoring a signal is somehow simpler than performing a scan because
you have fewer options. The parameters that you need are the port to
monitor, the total time, and time resolution of the monitor. The total
time is for how long do you want to acquire a signal before it starts
overwriting the information, and the time resolution defines the time
interval between consecutive acquisitions. The main difficulty with a
monitor is that the loop should be infinite and you should be able to
stop it somehow. We will see that in the next chapter, for the time
being, you can complete the exercises:

\exercise{Add one more block in the {YAML} file with the parameters that you need
to monitor a signal}

\exercise{Define a new method, called \mintinline{python}{monitor_signal} that used the
parameters defined in the previous exercise to continuously acquire a
value. If you want to test how the monitor works, you can make the loop
stop after a certain amount of time, for example using the module
\mintinline{python}{time.time()}.\\ 
\textbf{{HINT}}: You should define a numpy array where to store the data. In order to move all the values one step to the
left (or right), you can use \mintinline{python}{np.roll}.}
