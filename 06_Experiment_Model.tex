\chapter{Writing The Experiment Model}\label{chapter:experiment-model}

\section{Objectives}
In the previous chapter, we have seen how to define a model for a device. Models specify the logic behind the use of a device. In the previous chapter, for example, we have implemented the use of units. The manual of the device specifies that values must be integers in a predetermined range, but working with volts is much handier for the purpose of the experiment we are performing. 

However, models for devices alone are not sufficient to perform a complete measurement. For example, we are still missing a way to save data. We are also missing a way of transforming a voltage to a current, or the to perform a scan in a given range. In this chapter, we are going to see how to define a model for the entire experiment. The \emph{experiment model} will include all the steps that build a measurement.

\section{Introduction}
In the \textbf{MVCs} design pattern, the \emph{Model} is where all the logic and experimental decisions should be placed. In the previous chapter, for example, you have decided that you wanted to use voltage as the default units to handle inputs and outputs. However, this is not always the handiest. Imagine you use the same {DAQ} device connected to a piezo stage. Voltage is going to be translated to nanometers or microns, and the program should take it into account. In this book, measuring the IV curve of a diode requires you to measure the current passing through a diode, but the physical quantity that you are actually measuring is a voltage.

Following the \emph{onion principle}, it makes sense to define volts as the default units for the device, because it is what it outputs and what it measures. With a simple example such as the one in this book, it is hard to understand what are the limits for the models of devices and for the experiment. One of the parameters you can think of is about the future. Do you think that the model we have developed can be used by someone else in a different context? For example, if you were to start developing a program for a confocal microscope, would you be able to re-use the {PFTL DAQ} model? If the answer is yes, then it is a good start. The truth is that you can't really know what is going to be the future of your program in a year's time.

In this chapter, we are going to add another layer to the onion. So far, we are able to set a and read a voltage with our DAQ device. However, we would like to perform a scan, specifying voltages for start, stop, and step, for example. A model for experiments will allow you to quickly develop the logic that drives a measurement. In a more complex scenario, you may want to switch-on a laser only if a shutter is closed, and then you would like to open the shutter before doing a measurement. In the example that concerns us, measuring the  I-V curve, we are going to deal with inputs and outputs of one device. But remember that in more complicated setups this will most likely not be the case.

Writing an experiment model as a Python class has a twofold advantage. On the one hand, it is naturally going to lead to reproducible experiments. If you keep track of the parameters you use and do version control on the model, you can go back exactly to the same conditions in which you have performed a specific measurement. On the other hand, there is a more technical benefit in defining the experiment as a class. Once we are ready, the model is going to perform as the backend of our program, and it is going to be very easy to build a Graphical User Interface ({GUI}) on top of it.

\section{Starting the Experiment Class}\label{starting-the-experimentclass}
In section \ref{subsection:loading-the-config}, we have started defining a class that was able to read from a configuration file. We are going to start building on top of it. If you didn't create any files yet, be sure to create a folder called \textbf{Experiment} inside of \textbf{Model}. In that file, create a filled called  \textbf{IV\_Curve.py}. Let's start by defining a class called \texttt{Experiment} with some attributes: 

\begin{minted}{python}
class Experiment:
    def __init__(self, user=None):
        self.user = user
        self.daq = None
        self.properties = {}
\end{minted}

The class defines three attributes: a \mintinline{python}{user}, a \mintinline{python}{daq}, and \mintinline{python}{properties}. The user is set to \mintinline{python}{None} by default, but it is useful to keep track of who is running an experiment and saving its results. The \texttt{daq} attribute is where we are going to keep the DAQ model, and the \texttt{properties} are going to be a dictionary with all the parameters needed to perform a measurement. 

\exercise{If you want to get the username of the user logged in on the computer, you can try the package \emph{getpass}, which you can test by running \mintinline{python}{getpass.getuser(). Bear in mind that if several users share the same log-in, this approach is useless.}.

It is important to show the kind of functionality we are after in order for you to have a clearer picture of what is missing. The idea is that to perform a measurement, you would write a short script like the one below:

\begin{minted}{pycon}
>>> from Model.experiment import IVCurve
>>> exp = IVCurve(user='Me')
>>> exp.load_properties('Config/experiment.yml')
>>> exp.load_daq()
>>> exp.do_scan()
>>> exp.plot_results()
>>> exp.save_data()
>>> exp.save_meta_data() 
\end{minted}

We import the model of the experiment that we want to perform. Instantiate it with a specific user, in this case just \mintinline{python}{'Me'}. Then we specify the configuration file with the different parameters for the experiment and load it. We load the daq, based on what the configuration file specifies. To perform a scan, we simply execute \mintinline{python}{do_scan}. In principle, the model could have a quick way of plotting the data and, more importantly, to save the data and metadata needed to reproduce the measurement.

One of the advantages of defining a class for a measurement is that you can also use it in other projects. For example, you could trigger a measurement from a Jupyter notebook and analyze the results directly within it. You can also trigger measurements remotely and you will be able to programmatically change the parameters that you used for a scan. Let's start simple and build on complexity.

\exercise{Write a method for loading the properties from a {YAML} file. Remember that you have already done a version of this in the Lay Out chapter. Store the properties in a dictionary called \texttt{self.properties}}

Once you have a method for loading a {YAML} configuration file, you will also know all the properties that are available
to perform a measurement. It may be hard to understand at the beginning the usefulness of having a separated configuration file. When the program gets larger it is going to speed a lot the debugging and future improvements of your own code. In the following exercise you can already see that expanding the functionality of your program is relatively quick when the needed information is centralized: 

\exercise{Write a \texttt{do\_scan} method that relies on the parameters stored at \texttt{self.properties} to perform a measurement. Assume that \texttt{self.daq} is the model for the daq we are going to use. Store the data of the measurement in an attribute of the experiment class, remember that stylistic rules say that you should add every new attribute to the \texttt{\_\_init\_\_} method of the class.}

The two previous exercises are based on things that we have done more than once in the previous chapters. But in this chapter, we are systematizing all this information. Clear programs are great not only to yourself but also to other developers and users of your code. Moreover, once you start using the class in a real scenario, you will really appreciate the advantages of this approach.

\exercise{Write a method for saving the metadata of your experiment, i.e., all the information stored in the \texttt{self.properties} dictionary. \textbf{TIP}: Where do you save the data? Perhaps you can add one more parameter to the original {YAML} file to specify the destination folder.}

So far, you have developed the basic methods for performing an experiment and saving its data to a file. We are missing the crucial step of loading the {DAQ} model into the experiment model. There are two options to achieve it. The first one is that you manually import and initialize the {DAQ} and then you pass it to the experiment model. The second is to load the appropriate daq based on what is defined in the configuration file.

The code for the first option would look like this:

\begin{minted}{python}
from PythonForTheLab.Model.DAQ.simple_daq import AnalogDaq
from PythonForTheLab.Model.experiment import DaqControl

daq = AnalogDaq()
daq.initialize()

e = DaqControl(user='me')
e.load_daq(daq)
\end{minted}

While the code for the second option looks like this:

\begin{minted}{python}
from Model.experiment import DaqControl

config_file = 'Config/experiment.yml'
e = DaqControl(user='me')
e.load_config(config_file)
e.load_daq()
\end{minted}

The two approaches are very different and are worth discussing their advantages and disadvantages. In the first one, we are
importing the daq, we initialize it, and then we add it to the experiment class through the method \texttt{load\_daq}. This approach is quick because the experiment model doesn't need to do much, just to accept the DAQ and store it within itself. If you want to use a different DAQ device, you would alter the code above, importing the proper model, etc. At first sight, this approach may seem simple enough, however, it will become harder when you are dealing with several devices which can be changed. Moreover, future users of your code need to be comfortable editing Python files. 

The second approach involves loading a module based on information stored as a string on a file, which is slightly more complicated programmatically speaking. One of the advantages of this approach is that the information on the devices used is automatically saved as metadata. The other advantage is that we are really splitting the code itself from the peculiarities of our own experiment. This approach is also a good opportunity to learn a few new things about Python. 

In the next sections, we are going to start with the first approach and then we are going to change the code to work as in the second approach. This is called refactoring the code. Therefore, we are going to see not only how to solve the specific problem of loading the DAQ to the program, but also how to organize the workflow in order to guarantee that changes are backward compatible, and therefore other users can keep working. 

\subsection{Loading a DAQ}\label{loading-a-daq}
We are going to start with the simplest approach, which consists of importing and initializing the daq outside of the experiment model and then loading it to the \emph{experiment model}. The method \mintinline{python}{load_daq} will look like this:

\begin{minted}{python}
def load_daq(self, daq):
    self.daq = daq
    self.properties['Experiment']['DAQ']['name'] = str(self.daq)
    self.properties['Experiment']['DAQ']['port'] = self.daq.port
\end{minted}

The code is straightforward. The \mintinline{python}{load_daq} method gets one
argument, daq, that is stored into the class property \mintinline{python}{self.daq}.
You also update the \mintinline{python}{properties} dictionary to keep the name of
the model which you are using. This is important if you want to be sure you are able to reproduce the experiment at a later stage. If you save the properties, there will be no doubts regarding which DAQ you used to measure. This approach holds for any device that you may want to use in the future. 

There are, however, few things that need to be addressed. First, let's check what happens on the line which reads \mintinline{python}{str(self.daq)}. Remember, every time you see something with an unclear behavior, you can always check what is going on by opening a terminal and starting Python. Then, we can do the following:

\begin{minted}{python}
>>> from Model.daq import AnalogDaq
>>> daq = AnalogDaq(port=1)
>>> str(daq)
'<analog_daq.AnalogDaq object at 0x7fe8c53c0c50>'
\end{minted}

The result of doing \mintinline{python}{str(daq)} may not be what you were expecting. It is, however, a good starting point, because it allows you to identify which class did you use to define the daq. Fortunately, this can be improved. Open the file where you store the \mintinline{python}{AnalogDaq} class and add the following to it:

\begin{minted}{python}
def __str__(self):
    return "AnalogDaq"
\end{minted}

If you repeat the steps above, you will see now that the output of doing \mintinline{python}{str(daq)} is exactly \mintinline{python}{"AnalogDaq"}. The
\mintinline{python}{__str__} method of a class tells Python how to convert an object to a string. It is also responsible for the behavior of \mintinline{python}{print(daq)}. Now you will have a nicely formatted string to store in your \mintinline{python}{properties} dictionary. Remember that if you assign the same output for the \mintinline{python}{__str__} method, to two different classes, you won't be able to distinguish which one you used. Therefore, deciding what to include in the string representation requires some thinking. In principle, you can also add something that identifies that specific DAQ such as its serial number or the port to which it is connected. 

There is something else that is worth discussing at this stage. Remember that in principle we are developing software that can be expanded by other people. In the approach above, we ask the user to supply an object, but you won't be certain whether it is the correct class. Every time there is user input, there is room for mistakes. Complex programs such as the one we are developing now have the extra problem that mistakes at the beginning may generate data loss much later. Imagine that the user supplies the wrong class for the \mintinline{python}{load_daq}, but the experiment doesn't use the DAQ until the very end, before saving the data generated by another device, such as a camera. The program would raise an exception and most likely crash before it was able to write the data to the hard drive. 

Even if the example above can be a bit of an extreme, it can be wise to verify the user input, especially if it can alter the functioning of the program in some very wrong ways. If you think about what the {DAQ} Models have in common, you should realize that it is that both of them are child classes of the DAQBase class. Therefore, if you want to know if you are dealing with the proper model, you should check whether the daq variable that \mintinline{python}{load_daq} is getting is actually derived from the base model. To achieve this, you will need to update the experiment model, pay attention to the first line, which should be at the top of the file:

\begin{minted}{python}
from PythonForTheLab.Model.daq.base import DAQBase

[...]

    def load_daq(self, daq):
        if not isinstance(daq, DAQBase):
            raise Exception('The DAQ Model specified should be a child of DAQ Base')
    [...]
\end{minted}

The \mintinline{python}{isinstance} function is very useful to check whether the object we are inspecting belongs to a special class, including parents. It works not only with custom classes, but also with default data types of Python, for example:

\begin{minted}{pycon}
>>> a = 1
>>> isinstance(a, int)
True
>>> isinstance(a, str)
False
\end{minted}

Now we know that if the program is to continue, the user should have provided a model which inherits from the DAQBase class. This is one approach, which seems very adequate, but which may have some friction in the Python community. Many developers follow a pattern called duck typing. In a broad sense, it means that if a class behaves as expected, why would you care about what type of class it is? If someone develops a valid DAQ class, the only difference is that it does not inherit from DAQBase, is it correct to raise an exception? The discussion is not closed at all. You will find some people who are strong opponents of duck typing, others who are strong followers. Once you gain experience, you can make your own call. For the time being, our code is quite robust even if it could be at the expense of losing flexibility later on. 

The first approach on how to load the daq model into the experiment is relatively easy and is a pattern that will be repeated also in other places. Whenever you need information from outside the class, in this case, the DAQ model, you can create a method which accepts that information and you store it as an attribute. This will make it available throughout your class, in any other method. 

Let's see how the second approach would look like. The idea is that the experiment model will load a class based on what the {YAML} file specifies. In the first approach, you have updated the properties of the
experiment model, adding an extra key called \mintinline{python}{DAQ}. Therefore, we can do the same in the {YAML} file \textbf{experiment.yml}:

\begin{minted}{python}
User: me
DAQ:
  name: DummyDaq
  port: 0
\end{minted}

Next time you use the method \mintinline{python}{load_config}, you will also have a key for the {DAQ}. Importing a module into Python can be done at any stage of the program, also within a function or class method. We can therefore do it within the \mintinline{python}{load_daq} method of the Experiment class. For the time being we have developed only one DAQ, AnalogDaq, but let's assume we have a second one available, called DummyDaq (which we will actually develop by the end of this chapter), the method for loading the daq would look like:

\begin{minted}{python}
def load_daq(self, daq=None):
    if daq is None:
        try:
           name = self.properties['Experiment']['DAQ']['name']
            port = self.properties['Experiment']['DAQ']['port']
        except KeyError:
            raise Exception('You must either provide a daq or specify it in the configuration file')
        if name == 'DummyDaq':
            from PythonForTheLab.Model.daq import DummyDaq
            self.daq = DummyDaq(port)
        
        elif self.properties['DAQ']['name'] == 'AnalogDaq':
            from PythonForTheLab.Model.daq import AnalogDaq
            self.daq = AnalogDaq(port)
        
        else:
            raise Exception('The daq specified is not yet supported')
    
    else:
        # Here goes the same code you had before
\end{minted}

The first thing you have to notice is that we have added a default value for the \mintinline{python}{daq} argument, in this case, \mintinline{python}{None}. Adding a default value allows you to use the
method both as \mintinline{python}{load_daq()} and as \mintinline{python}{load_daq(daq)}. If you call the method without an argument, \mintinline{python}{if daq is None} will be \mintinline{python}{True}. The way of importing the different models is quite straightforward, you check the name specified in the config file and make the import. Pay attention to the fact that we added another failsafe: if the user does not supply an initialized DAQ nor any DAQ information in the configuration file, we will raise an exception to inform it. You could argue that this approach is not very flexible. If you ever add a model for a new device, you need to manually add it to the experiment model. However, the simplicity outweighs the flexibility. 

The method \mintinline{python}{load_daq} is compatible with our previous code. If the user does supply a DAQ, it will use that one instead of anything provided in the configuration file. This is called refactoring. We have changed our experiment model relatively a lot, but we added the possibility of using it as it was specified in the past. Adding default values when you add a new input to your methods or functions is an excellent way of keeping backward compatibility. Sometimes it will not be possible though. Bigger libraries, such as numpy, normally release intermediate versions, in which a warning appears telling you that in a future version a function will change, and they normally document it quite extensively. Smaller programs with a smaller user base tend to be sloppier in this regard, but that doesn't mean that you can't follow a neat approach from the beginning. 

\exercise{Go ahead and trigger the exception by defining a name of the {DAQ} different from `DummyDaq' or `RealDaq'. What happens to the code after the exception? Does it get executed?}

There is something else that is very easy to overlook. Imagine you run the experiment supplying the daq yourself, and then you save the properties dictionary in YAML format. The information contained will include the name of the DAQ and the port. If you use that file as a configuration file, the experiment model will be able to load the DAQ automatically, without you having to initialize it beforehand. This happens only because of the string representation of our model coincides with the options of the \mintinline{python}{load_daq}. This, however, is not mandatory. If you want to enforce it, you need to write very clear documentation, explaining it. You may also take a different approach. Since we are forcing all DAQs to be children of DAQBase, we can add the following to DAQBase:

\begin{minted}{python}
    def __str__(self):
        return self.__class__.__name__
\end{minted}

And then just remove the \mintinline{python}{__str__} method from AnalogDaq. What we have done is that by default the string representation of a class is the name of the class. This may not be wise in all contexts, but at least you get to see the power of inheritance and how to use some of the magic methods of Python. 

\section{Defining a Scan}\label{defining-ascan}
The goal that we were set to achieve at the beginning of the book is to measure the {IV} curve of a diode. Therefore, doing a scan means changing an analog voltage output in a controlled way and, at the same time, recording an analog input. This kind of measurement is very common in a lot of different experiments, not only in electronics.

\exercise{Think at least three different examples of experiments that you can perform by changing an analog output and recording an analog input.}

Performing a scan requires some parameters, that you should have defined in previous chapters, in any case, you can find them below as well.

\begin{minted}{yaml}
Scan:
  channel_in: 2
  channel_out: 1
  start: 0.1V
  stop: 0.7V
  step: 0.1V
  delay: 10ms
\end{minted}

\mintinline{python}{channel_in} and \mintinline{python}{channel_out} are the numbers of the channels on the DAQ needed for the scan, i.e., the analog in and the analog out. \mintinline{python}{start}, \mintinline{python}{stop} and \mintinline{python}{step} are the analog output parameters. Note that units are added, and we will see how to deal with them later. It is important to point out that they don't need to have the same unit but they have to be the same quantity. For example, you can mix \textttt{mV},  \textttt{nV},  \textttt{V}, etc. The delay means how often the output is going to change from one value to the next.

The advantage of starting by defining the parameters in a {YAML} file is that now you know what parameters you have available and what are their names. The next step is to create the method for doing the scan. You have already done a scan in the previous chapters. If you dig up the code, you can adapt it in order to make it work as a method in the experiment class. The general idea is to
generate an output and record an input within a \emph{for loop} with the range given by \mintinline{python}{start}, \mintinline{python}{stop} and \mintinline{python}{step}. You
should have something like this:

\begin{minted}{python}
def do_scan(self):
    scan_params = self.properties['Experiment']['Scan']
    
    start = scan_params['start']
    stop = scan_params['stop']
    step = scan_params['step']
    port_in = scan_params['port_in']
    port_out = scan_params['port_out']
    delay = scan_params['delay']

    num_points = int((start-stop)/step) + 1

    scan_values = np.linspace(start, stop, num_points)

    for value in scan_values:
        self.daq.set_analog_value(port_out, value)
        data = self.read_analog(port_in)
        sleep(delay)
\end{minted}

The code is quite clear. The first step is to store the parameters of the scan into a variable called \mintinline{python}{scan_params}. This is only a way of shortening the amount of typing required later on. The loop is responsible for changing the output value and reading the analog input. Probably you have realized that there are some issues with the code above which we will need to solve, one by one.

\exercise{In the loop, the variable \mintinline{python}{data} is being overwritten on every step. This is not what you want if you intend to do anything with it. Store the information into an array. The array should be an attribute of the class, i.e. it should be defined in the \mintinline{python}{__init__} method and you can refer to it as \mintinline{python}{self.scan_data}.}

The advantage of having the data stored in an attribute is that it becomes available to other methods of the class and that it is accessible from outside of it, for example for plotting. However,
storing the data is only one of the concerns that need to be addressed. The other one is that the parameters that you are using have units attached to them, and yaml is reading them as a string that needs to be
transformed into quantities.

We have covered how to use units in Python when you have developed the first driver for the {PFTL} {DAQ}. You have to use the Unit Registry from a package called Pint. The code looked like this:

\begin{minted}{pycon}
>>> from pint import UnitRegistry
>>> ur = UnitRegistry()
>>> var = ur.Quantity('5V')
\end{minted}

With this code, \emph{Pint} interprets a string, \mintinline{python}{'5V'} and transforms it into a quantity. You could add the same code at the beginning of the \emph{experiment} model, and transform the parameters when you use them, or you can have a more elegant approach. In the root of your project, the folder that contains the folders \emph{Model}, \emph{View} and \emph{Controller}, create a file called \textbf{\_\_init\_\_.py} and add the following code to it:

\begin{minted}{python}
from pint import UnitRegistry
ureg = UnitRegistry()
Q_ = ureg.Quantity
\end{minted}

At the top of the file where you define the experiment model, you can add:

\begin{minted}{python}
from PythonForTheLab import Q_
\end{minted}

And you can use \mintinline{python}{Q_} for transforming the parameters into quantities, simply doing \mintinline{python}{Q_(parameter)}.

\exercise{Update the code to transform each one of the appropriate parameters to a Quantity. Remember that the port numbers are supposed to be integers, not quantities.}

Once you complete the exercise above, one of the problems was addressed. But still, if you try to run the program you will face other issues. For example, to calculate the number of points in the scan, we should transform all the parameters to the same units. One of the possible ways of doing it is by picking the units of one of the parameters, like this:

\begin{minted}{python}
units = start.u
stop = stop.to(units)
step = step.to(units)
num_points = (stop-start)/step
num_points = int(num_points.m_as(''))+1
\end{minted}

The \mintinline{python}{u} grabs the units from a \emph{Quantity}. You transform everything into the same units to avoid problems with the number of points you are computing. However, when dividing quantities, the result will be another quantity, just that \emph{dimensionless}. To transform it to a number, you have to append \mintinline{python}{.m_as('')}. Doing \mintinline{python}{num_points.m_as('')} means that you want to take the magnitude of the variable, without units, and the \mintinline{python}{''} are there because we are dealing with a dimensionless quantity. 

\exercise{What happens if you calculate the number of points without transforming start, stop and step to the same units?}

There is one more parameter that you need to take care of. The \mintinline{python}{delay} has units of time, and the function \mintinline{python}{sleep} takes seconds as an argument. The easiest way to deal with it is simply writing the following:

\begin{minted}{python}
sleep(delay.m_as('s'))
\end{minted}

Which ensures that you use the delay magnitude expressed in seconds.  If you use milliseconds or hours for that matter, it will be translated into the proper number before the \mintinline{python}{sleep} function uses it. With these changes, your code is ready for performing a scan. 

Since everything is working, we may be tempted to step ahead. However, it is worth discussing how Pint and Numpy play along since it can give rise to a major bug in our program, which won't be evident until it is too late, i.e. after you have acquired data. We went very quickly from units to a numpy array using the function \mintinline{python}{linspace}. However, we never checked what that function is actually doing when the inputs have units. Paying attention to that crucial detail is what you gain with experience. Let's see with some quick examples what is going on:

\begin{minted}{pycon}
>>> start = Q_('5V')
>>> stop = Q_('10V')
>>> num_points = 6
>>> np.linspace(start, stop, num_points)
array([ 5.,  6.,  7.,  8.,  9., 10.])
\end{minted}

We see in the output that the array doesn't have units. That is not particularly bad, it is easy to add them later. But what happens if we mix different units?

\begin{minted}{pycon}
>>> start = ur('5mV')
>>> np.linspace(start, stop, num_points)
array([ 5.,  6.,  7.,  8.,  9., 10.])
\end{minted}

Surprisingly, what is happening is that Pint stripped the units from the quantities and just used the magnitude. This is a huge problem for our program. If at some point a user mixes units for start and stop, our program will behave in a completely unintended way. These kind of bugs are very hard to find and to solve because the only indication of something going badly is when we look at the data and we realize that something is incredibly off. The number of points is correct, but the values used for the output are not. 

In our solution, we have forced the same units, because we assumed that we needed them to calculate the number of points in our scan. The reality is that we don't need to do it for the number of points, but we do need it for the scan dimension. There is only one last thing that we are missing and is that we should use units when we set the output on our device. Therefore the quickest way of doing it is like this:

\begin{minted}{python}
def do_scan(self):
    [...]
    units = start.u
    stop = stop.to(units)
    scan = np.linspace(start, stop, num_points) * units
\end{minted}


\section{Dummy DAQ}\label{dummy-daq}
The previous sections have been focused on developing a model for interacting with the real device that drives your experiment. However, when you develop software for the lab, sometimes you would like to test your program without having the real device connected to the computer. It can be a safety precaution or simply because you are not working on the lab computer. To achieve this, you can define a fake model which generates fake data. We like calling fake devices of \textbf{dummy} devices. 

Create a new file called \textbf{dummy\_daq.py} in the folder \textbf{Model}. Add the following code to the file:

\begin{minted}{python}
from PythonForTheLab.Model.daq import DAQBase

class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    def idn(self):
        return self.serial_number
\end{minted}

You start by importing the base class \mintinline{python}{DAQBase}, as you did for the real \emph{model}, but you don't need the controller since you are not going to communicate with any device. The class defines a fake serial, just to be able to return it as if it was the real device. Since we are inheriting from DAQBase, the DummyDaq class will pass the check of the \mintinline{python}{load_daq} method in the experiment. Now you have to think about what do you actually expect from a fake device. Since you are developing a dummy {DAQ}, you don't need to do anything when setting a value to an output, but you do need to get a value when you read back. And you need to use the proper units as well. It can look something like this:

\begin{minted}{python}
import numpy as np
from PythonForTheLab import Q_
from .base import DAQBase


class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    
    def __init__(self):
        super().__init__()
    
    def idn(self):
        return self.serial_number
    
    def get_analog_value(self, channel):
        return np.random.random(1)*Q_('V')

\end{minted}

The \mintinline{python}{idn} is quite clear, it just returns the serial number that was defined beforehand. The \mintinline{python}{get_analog_value} accepts a channel as a parameter, even if it doesn't use it, you need to keep the compatibility with what was already defined. The value that is returned is a random number with volts as units. Remember that the random generator outputs values only between 0 and 1. You can try to run the test, but using this DummyDaq instead. Open the file \textbf{test\_daq.py}, and replace the line:

\begin{minted}{python}
# from analog_daq import AnalogDaq
from dummy_daq import DummyDaq as AnalogDaq
\end{minted}

And run \textbf{test\_daq.py}. You will see that an error appears because we are using the \mintinline{python}{initialize} method in the test, but it is not defined within the class. This happened because we included \mintinline{python}{initialize} in the \mintinline{python}{AnalogDaq} but we never added it to the DAQBase. Now you see the power that comes with been organized and systematic. Keeping track of the methods in a base class allows you not to make the same mistakes. Moreover, it would have allowed you to run the test without issues.

\exercise{Add an \mintinline{python}{initialize} method into the base class.}

If you run the test after completing the exercise, you will see that there are no errors appearing, even if you don't modify the dummy class. Now you see that you can exchange the models in a relatively simple way, and the script that is responsible for measuring works without problems. Of course, this is a simple example, where you exchange a real device for a dummy one, but if you would have two different devices, exchanging them would have been just as simple and the measurement would have been performed regardless of which device you are using.

\exercise{Make the \mintinline{python}{get_analog_value} return the value of a sine function and not just a random value.}

\section{Conclusions}\label{experiment-model-conclusions}
With this chapter, the core code for a functioning experiment is finished. We went from the development of a driver for a device to split the code into controllers and models. Defining a scan as we did in this chapter was so simple because of all the previous preparation. Of course, there are things that we can do better but what we have achieved so far is functioning and quite useful.

When you develop your own program, it can be wise to start with the experiment model. Once you established the steps of a measurement it will become clear what you need to develop in order to achieve it. Starting by outlining the experiment model is a good way of being focused on a clear objective. If you are developing a driver, or a model, without knowing to what end, you may end up creating methods and options that you don't really need.

In this chapter, you also start to realize that if you plan to open your code to others, not just as developers, but as users, you will need to verify the input that they supply. For example, you learned how to verify that the {DAQ} model is actually what you want. Following that idea, there are several improvements to your code, for example, you can check if the units of the parameters used are correct. It is not the same trying to apply $5\,\textrm{V}$ to an analog output than $5,\textrm{nm}$. 

\section{Extras: Defining a Monitor}\label{extras-defining-amonitor}
The principal objective of this book is to show you how to build the software that you need in order to measure the I-V curve of a diode. However, there are some other options that you can add to the program, such as continuous monitoring of a signal. In a lot of experiments, measuring a signal is all you need, especially in the phase of setting up. Imagine that you are monitoring a temperature, perhaps you need to wait until it reaches a certain value, or you monitor the signal generated by a photodiode in order to align a laser.

Monitoring a signal is somehow simpler than performing a scan because you have fewer options. The parameters that you need are the channel to monitor, the total time, and time resolution of the monitor. The total time means for how long do you want to acquire a signal before it starts overwriting the information, and the time resolution defines the time interval between consecutive acquisitions. The main difficulty with a monitor is that the loop should be infinite and you should be able to stop it somehow. We will see that in the next chapter, for the time
being, you can complete these exercises:

\exercise{Add one more block in the {YAML} file with the parameters that you need to monitor a signal}

\exercise{Define a new method, called \mintinline{python}{monitor_signal} that uses the parameters defined in the previous exercise to continuously acquire a value. If you want to test how the monitor works, you can make the loop stop after a certain amount of time, for example using the module \mintinline{python}{time.time()}.\\ 
\textbf{{HINT}}: You should define a numpy array where to store the data. In order to move all the values one step to the left (or right), you can use \mintinline{python}{np.roll}.}
