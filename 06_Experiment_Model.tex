\chapter{Writing The Experiment Model}\label{chapter:experiment-model}

\section{Introduction}
In the \textbf{MVCs} design pattern, the \emph{Model} is where we should place the the logic and the decisions we make in order to perform a measurement. In the previous chapter we started specifying the logic of how we are going to use the DAQ device. We decided, for example, that the device should start and finish with the outputs set to $0\,\textrm{V}$, and that it should handle Pint units for setting and reading values. Even though it was a great start, there are still steps missing to perform a real experiment.

We are still missing, for example, the possibility to perform a scan in a given range of voltages, there is no way of saving data nor the parameters used to generate it. We can develop these tools in a script, and that is fine to get started. At some point, however, we want to be systematic, and we don't want to keep editing a script every time we must perform a measurement. We want the data to be consistently saved, or we want to enable other people to run their own experiments based on our routines.

This is when the \emph{onion principle} starts making sense. We are slowly building in complexity, one layer at a time. We started with the driver, built some logic on top of it through a device model, and now we can keep growing the complexity by defining an Experiment model. There are many different steps needed in order to perform a reproducible measurement, and we will cover them one by one. One important aspect we missing, on top of the ones mentioned earlier is, for example, transforming the voltages we measure to a current, so we can give sense to the \textbf{I} on the I-V curve we are trying to measure.

\note{With a simple device and experiment such as the one we use in this book, sometimes is hard to put a limit on what should go in the device model and what into the experiment model. There are no strict rules, we should always reflect on what we believe will be useful on the long run. Once we are confortable working with classes in Python, splitting the code into reusable, smaller modules does not lead to much more typing.}

There are two extra advantages of developing an experiment model which will become apparent only after working on these topics long engouh. On the one hand, the models are going to lead to reproducible experiments. If we keep track of the parameters we, we can go back exactly to the same conditions in which we have performed a specific measurement. On the other hand, once we are sure we can perform a measurement from the command line, running a script or within the Python interpreter, it is going to be very easy to build a Graphical User Interface ({GUI}) on top of it, but let's not get ahead of ourselves.

\section{The Skeleton of an Experiment Model}\label{section:skeleton-experiment-model}
Every time we want to start developing a model, it is handy to start from an empty skeleton. This will help us know what parts of the code need to be developed, what things we don't know how to do yet and need to learn. It also allows us to have a quick glimpse at how we expect our program to be used. We did it for the device model in the previous chapter, and we can do the same for the experiment in this chapter. First, we create a file called \textbf{experiment.py} inside the \emph{Model} folder, and then we think about the steps needed to perform a measurement:

\begin{minted}{python}
class Experiment:
    def __init__(self, config_file):
        pass

    def load_config(self):
        pass

    def load_daq(self):
        pass

    def do_scan(self):
        pass

    def save_data(self):
        pass

    def finalize(self):
        pass

\end{minted}

Most of the code should be self-explanatory, but some steps are worth mentioning. First, we include a \texttt{load\_config} method, which will rely on the \texttt{config\_file} we specify at the \texttt{\_\_init\_\_}. Having a separated config file will be useful not only to change parameters between measurements, but it will help us with our code. Especially when the number of things we need to remember grows, it is always handy to have a file where to look at how we named things.

We have also included a \texttt{load\_daq} method. So far, we have only one DAQ to use, but we go a bit ahead of time and assume that at some point there may be more than one and therefore we should have a way of loading one or the other. It can also be a case of premature optimization, in which we anticipate a future that never comes. Nevertheless, it is pedagogically useful to define it there.

The rest of the methods may seem intuitive enough. If we are missing extra pieces, we can always come back and add them. Now it is time to start developing each one of the building blocks.

\section{The Configuration File}\label{section:configuration-file}
\subsection{Working with YAML files}\label{subsection:yaml-files}
Before we keep developing code, we need to stop for a second to think what do we want our program to do. We need to think about what inputs are needed for our program. For example, we know we need the port in which the device is connected. We also know that we need to define an output and input channel, a range for the scan, a delay between data points, etc. Before going into the details, let's see how to easily store all these parameters into a text file.

In the \emph{Examples} folder, create a file called \textbf{experiment.yml}. This file can be created with any text editor, the only difference is the extension \emph{yml}. This file will hold all the parameters of the experiment. We are going to use a format called {YAML}, which has a straightforward structure, it looks like this:

\begin{minted}{yaml}
Experiment:
  name: This is a test Experiment
  range: [1, 10, 0.1]
  list:
   - first Element
   - second Element
\end{minted}

{YAML} is very simple to read both by a person and by the computer. It has just a few rules, the most important one is that the indentation is done with \textbf{2} spaces. In the example above, there is a main element called \textbf{Experiment}, everything that is indented compared to that element will belong to it. To read the file we are going to use a package called PyYAML, which was installed in Chapter \ref{chapter:setting-up}. We can create a file called \textbf{test\_yaml.py} also in the Examples folder to understand how to use these files:

\begin{minted}{python}
import yaml

with open('experiment.yml', 'r') as f:
    e = yaml.load(f, Loader=yaml.FullLoader)

print(e['Experiment'])
for k in e['Experiment']:
    print(k)
    print(e['Experiment'][k])
    print(10*'-')
\end{minted}

We begin by opening the file using \mintinline{python}{open}. We use the \mintinline{python}{with} command because it is very handy for working with files and other resources that have the same pattern of opening/doing/closing. Yaml is then responsible for interpreting the information contained in the file. We store this information in a variable \texttt{e}, which turns out to be a dictionary.

The elements of dictionaries are addressed by keys. In the example above, there is a main key called \texttt{'Experiment'}, and the sub-keys \texttt{'name'}, \texttt{'range'} and \texttt{'list'}. If we want to use one of those elements, we can type \texttt{e['Experiment']['name']}, for example. The code prints out each element, separated by a horizontal line. Yaml imported the file directly as a dictionary but some of the elements are special. We can see that \texttt{'name'} is a string, but \texttt{'range'} and \texttt{'list'} are not. This will become very handy later on because YAML automatically detects what kind of information we are using.

\exercise{What type of variables has yaml generated for \texttt{'range'} and the \texttt{'list'}? (Remember that you can use \texttt{type(var)} to know the type of the variable.}

\exercise{YAML also supports numeric information. Create a new element and assign it a value of \texttt{1} or \texttt{3.14}. What kind of variable has YAML created in such cases?}

Of course, YAML can be used not only to read properties but also to save information generated in a program. Instead of loading data, we can use \texttt{yaml.dump} method to save it. For example, we can define a dictionary with the following information

\begin{minted}{python}
d = {'Experiment': {
    'name': 'Name of experiment',
    'range': [1, 10],
    'list': (1, 2, 3),}
}
\end{minted}

If we want to save it to a file, we can do the following:

\begin{minted}{python}
with open('data.yml', 'w') as f:
    f.write(yaml.dump(d, default_flow_style=False))
\end{minted}

We are using the \texttt{'w'} option to open the file, which means that every time we run the code, we will overwrite the file and lose the previous contents. After running the code we can open the file \textbf{data.yml} with any text editor and see that the contents are very similar to the one we created ourselves earlier. One of the advantages of the YAML format is that files are very easy to read, and don't require much typing.

\exercise{Read back the contents of \textbf{data.yml} and check that they are the same you saved.}

\exercise{Modify some of the values of \textbf{data.yml} directly with your text editor and see that those changes are reflected when you read again the file.}

\exercise{Create a numpy array and store it using yaml. How does it look like in the file? What happens if you read it back?}

\exercise{\textbf{Advanced}. Save a numpy array using yaml. Then activate a virtual environment in which PyYAML is available but not numpy. Try to load the contents of the file. What happens?}

Now that we know how to work with YAML files, it is time to start thinking about the experiment again. We need to stop and think about what do we need to know in order to perform an experiment.

\exercise{Create a new experiment.yml file in the \emph{Examples} folder. Use what you have learned about YAML files to write a file that contains all the information that you need to perform an experiment and interpret its data. For example, knowing \emph{who} performed an experiment may be important.}

\subsection{Loading the Config file}\label{subsection:loading-the-config}
We have decided to use YAML files because of their simplicity, and because it is easy to map them to dictionaries in Python. The main advantage of having a separated config file is not only that it will allow us to run different measurements changing the parameters, but that it will also help us keep our code organized. This will become much clearer later in this chapter.

First, we need to decide what are we going to include in the configuration file. The information is not static, it may very well happen that later we realize there is something important missing, and we added it, or something we thought was important is not necessary anymore. The idea is that every time we find ourselves making a decision about a value, that information should go to the config file. For example, if we need to decide in which port the DAQ is connected, that goes to the config file. We are going to use the \textbf{experiment.yml} file in the \emph{Examples} folder to store all this information. Below, we show how the config file could look like. We have included extra options that we haven't discussed yet, such as the user performing the experiment, which can be relevant for bookeeping:

\begin{minted}{text}
User:
  name: Aquiles

DAQ:
  name: AnalogDaq
  port: /dev/ttyACM0

Scan:
  start: 0V
  stop: 3.2V
  step: 400mV
  channel_out: 0
  channel_in: 0
  delay: 100ms

Saving:
  filename: data.dat # Files won't be overwritten, but renamed as data_001.dat, etc.
\end{minted}

We haven't used a main key such as \emph{experiment} because it does not add anything, and forces us to type more. If for some reason we needed to store parameters for two different experiments on the same file, then we could add two top-level keys such as \texttt{Experiment\_1}, \texttt{Experiment\_2}. The parameters above are enough to get started, and then slowly keep adding or modifying when we need. There are some obvious omissions, meant to trigger dicsussions further down the road. If you have already spotted them, you have done a good job, but don't stress yourself if you haven't.

We have to update the \texttt{Experiment} class to load the file. We are storing the filename within the class, so all our methods can be triggered without arguments. But this is just a choice we've made:

\begin{minted}{python}
import yaml

class Experiment:
    def __init__(self, config_file):
        self.config_file = config_file

    def load_config(self):
        with open(self.config_file, 'r') as f:
            data = yaml.load(f)
        self.config = data
\end{minted}

We have used the same code we showed in the previous section but as part of a method. When we load the configuration file, it will be stored as an attribute of the Experiment class, called \texttt{self.config}. Now that the experiment is starting to have shape, we can create a file to show how to use it and check whether we are doing things properly. In the \emph{Examples} folder, we can create a file called \textbf{run\_experiment.py}, and add the following:

\begin{minted}{python}
import sys
import os

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(base_dir)

from PythonForTheLab.model.experiment import Experiment

experiment = Experiment('experiment.yml')
experiment.load_config()
print(experiment.config)
\end{minted}

We use the strategy explained in Section \ref{section:appending-path} in order to let Python know where to find our program. The rest is easy to understand, we start an experiment, load the config file and print the parameters that we have loaded. So far, we are not doing much, but it is a good start.

Now we have a consistent interface for loading the configuration file into our programs. This gives us a great deal of flexibility and makes the code nicely reusable and extendable.

\exercise{When the function \texttt{load\_config} loads the configuration from a file, verify that some important parameters are defined. For example, verify that there is a user associated with an experiment. If there is something missing, print an error message or raise an Exception.}

\section{Loading the DAQ}\label{section:loading-daq}
To load the DAQ into our experiment, we can start with the simplest approach. We import the model for the daq, and we initialize it using the \texttt{load\_daq} method. We can update the experiment model, some parts of the code are omitted for brevity:

\begin{minted}{python}
from PythonForTheLab.Model.analog_daq import AnalogDaq

[...]

def load_daq(self):
    self.daq = AnalogDaq(self.config['DAQ']['port'])
    self.daq.initialize()
\end{minted}

The \texttt{load\_daq} method uses the information stored in the configuration file in order to instantiate and initialize the daq model. Having a config file in YAML format makes it very easy to navigate and find where the information of the port for the daq was located. The main key is \texttt{DAQ}, and the sub-key is \texttt{port}. In this way, there are much fewer things we need to keep in our heads, we can always go back to the file and read what we need to know. We have also decided that we initialize the device right after loading it. This could have been a separated method, but at this stage and for this experiment, there is no real need.

Since we are taking care of loading and initializing the DAQ, we can also develop the finalize method, which takes just one line:

\begin{minted}{python}
def finalize(self):
    self.daq.finalize()
\end{minted}

We can update the \textbf{run\_experiment.py} file to reflect the additions we have just made to the Experiment:

\begin{minted}{python}
[...]
experiment.load_daq()
print(experiment.daq)
experiment.finalize()
\end{minted}

When we run the code above, we will see that the output of of \texttt{print(experiment.daq)} is not pretty and it is hard to understand. We can update the device model in order to make the string that appears on screen nicer. We edit the \textbf{analog\_daq.py} file to include the following method in the \texttt{AnalogDaq} class:

\begin{minted}{python}
[...]

class AnalogDaq:
[...]

    def __str__(self):
        return "Analog Daq"
\end{minted}

The method \texttt{\_\_str\_\_} is called a \emph{dunder} method, because it has the double underscore before and after. These are magic methods in classes that allow us to change the behavior in a much more lower level. The \emph{str} method is responsible for letting Python know how to transform an object to string. This happens, for example, when we use the \texttt{print} function. If we run the experiment again, we will see that the output is much nicer.

\note{Adding a string representation to the classes we build is a nice addition but not mandatory. We should be careful not to derail on details that don't bring us closed to the goal of performing a measurement.}

\subsection{The Dummy DAQ}\label{subsection:loading-dummy-daq}
In the previous chapter we took a small detour when we discussed the creation of a base class for the device models. In Section \ref{section:base-model} we discussed also about creating a dummy device, a fake model that outputs random numbers when requested. This means that we have two different DAQ devices we can use, one real and one fake. Therefore, we can improve the Experiment model to accomodate the possibility of using one or the other. We are going to follow a non-standard approach, which does not comply with the general principles of Python, but that it is nevertheless very handy. In the config file, we included the name of the DAQ, it is time to use this information. There will be two possibilities, either \texttt{AnalogDaq}, or \texttt{DummyDaq}:

\begin{minted}{python}
def load_daq(self):
    name = self.config['DAQ']['name']
    port = self.config['DAQ']['port']
    if name == 'DummyDaq':
        from PythonForTheLab.Model.dummy_daq import DummyDaq
        self.daq = DummyDaq(port)

    elif name == 'AnalogDaq':
        from PythonForTheLab.Model.analog_daq import AnalogDaq
        self.daq = AnalogDaq(port)

    else:
        raise Exception('The daq specified is not yet supported')

    self.daq.initialize()
\end{minted}

The \texttt{load\_daq} method is now much more powerful than before, and we are doing something that may seem strange at first sight. We are importing Python modules not at the top of the file, but deep inside a method. This is not standard and in some contexts it is discoursaged, but it is important to understand why we have decided to follow this approach. When working with real devices, it can happen that the models depend on drivers that are not installed on the computer. If we import the device model at the top of the experiment file, we may get an error because of a device we are actually not intending to use.

On the other hand, this behavior is discouraged because if there is a problem in one of the modules being imported, we won't notice it until we are running the program, and that can make us lose time and, more importantly, data. For example, \texttt{AnalogDaq} depends on having a proper controller available. If we make the import at the top of the class, and the controller is not in place, we will get an error even before we instantiate the experiment class. If we plan to use only the dummy model, then we don't care about this. The balance between safety, best practices, and ease of development is sometimes hard to choose. What is important to remember is that Python is an incredibly flexible language.

We have also included a final clause in our if-statement to raise an exception if the specified model is not one of the two we know how to work with. The advantage of working with models that specify the same API is that after we load and instantiate them, they both will work in the same way, therefore the rest of our code will be completely independent from which model we are using.

\exercise{In Section \ref{section:pint} we included units for the \texttt{AnalaogDaq} class, but we didn't add units for the \texttt{DummyDaq}. This is an inconsistency, since both models will be generating different types of output. Update the dummy model to generate random values including units of volts.}

\section{Doing a Scan}\label{section:doing-scan}
The core of the experiment model is being able to perform a scan, changing the voltages on the output and reading the voltages in the input. This kind of measurement is very common in a lot of different experiments, not only in electronics. That is the reason we decided to call it \texttt{scan}, which is fairly general name.

\exercise{Think at least three different examples of experiments that you can perform by changing an analog output and recording an analog input.}

To perform a scan, we will use the parameters that we have defined in the \texttt{Scan} section of the config file. Since we already performed this type of measurement either from the command line or from example files, it is easy to adapt what we did to the method in the Experiment class:

\begin{minted}{python}
from PythonForTheLab import ur
[...]

def do_scan(self):
    start = ur(self.config['Scan']['start'])
    stop = ur(self.config['Scan']['stop'])
    step = ur(self.config['Scan']['step'])
\end{minted}

After the first few lines, we need to stop and think. After we introduced units to our model we didn't really try to perform a scan, and therefore we need to see how Pint works. We know start, stop, and step all have units of volts or related. However, if we try to use the start, stop, and step values as they are, we will fail. Nore the Python \texttt{range} function, nor numpy's \texttt{arange} know how to deal with quantities. However, Pint allows us to transform a quantity to a plain number in given units, by using the \texttt{m\_as} method. Therefore, if we want to have a range of values over which to perform the scan, we can do this:

\begin{minted}{python}
scan_range = np.arange(start.m_as('V'), stop.m_as('V'), step.m_as('V'))
\end{minted}

If we explore the \texttt{scan\_range} variable, we will see that it includes the numbers starting with \texttt{start}, going in increments of \texttt{step}, but it does not include the \texttt{stop} value. This is not a bug, but just how \texttt{arange} works. The documentation clearly states that arange generates values in the semi-open interval $[\textrm{start}, \textrm{stop})$. If we want to include the last point or not, is debatable. On possible strategy would be to do this:

\begin{minted}{python}
scan_range = np.arange(start.m_as('V'), stop.m_as('V')+step.m_as('V'), step.m_as('V'))
\end{minted}

But this has an associated risk. What happens if start is $0\,\textrm{V}$, stop is $3.3\,\textrm{V}$ and step is $0.5\,\textrm{V}$? The last value in the range would be higher than $3.3\,\textrm{V}$. This means that forcing the stop to be larger only works if the step divides the range in an integer number of intervals.

We could use numpy's \texttt{linspace}, which allows us to generate equally spaced values if we provide a start, stop and the number of points we want. This seems like a viable solution. We can do the following:

\begin{minted}{python}
num_points = int((stop.m_as('V')-start.m_as('V'))/step.m_as('V'))+1
scan_range = np.linspace(start.m_as('V'), stop.m_as('V'), num_points)
\end{minted}

We added a \texttt{+1} to the number of points to accomodate the last value. For example, if we wanted all the integer numbers from 0 to 10, we should use 11 data points. Again, this works fine if the number of points is an integer value, but as soon as the step we specified does not divide the interval in an integer number of points, we would have a problem. With the same values used before, we would get a scan range like this:

\begin{minted}{python}
array([0.  , 0.55, 1.1 , 1.65, 2.2 , 2.75, 3.3 ])
\end{minted}

Which is obviously not spaced by $0.5\,\textrm{V}$, but it respects the start and stop values. The last option to which we can resource is to change the config file. We thought that defining the step was a good idea, but perhaps it is a better idea to use the number of steps we want in our scan instead of the step size. Therefore, we have to update \textbf{experiment.yml} to include the number of steps and not the step size:

\begin{minted}{text}
Scan:
  channel_in: 0
  channel_out: 0
  start: 0V
  stop: 3.3V
  num_steps: 100
  delay: 100ms
\end{minted}

Before we proceed with the experiment class, we see that the array that numpy generates has no units, and this makes sense because we stripped the units from the parameters of the scan. But this can be easily solved by multiplying the array with the proper units, like the code below shows:

\begin{minted}{python}
from time import sleep
[...]

def do_scan(self):
    start = ur(self.config['Scan']['start']).m_as('V')
    stop = ur(self.config['Scan']['stop']).m_as('V')
    num_steps = int(self.config['Scan']['num_steps'])
    delay = ur(self.config['Scan']['num_steps'])
    scan_range = np.linspace(start, stop, num_steps) * ur('V')
    scan_data = np.zeros(num_steps)
    i = 0
    for volt in scan_range:
        self.daq.set_analog_value(self.config['Scan']['channel_out'], volt)
        measured_voltage = self.daq.get_analog_input(self.config['Scan']['channel_in'])
        scan_data[i] = measured_voltage
        i += 1
        sleep(delay.m_as('s'))
\end{minted}

The \texttt{do\_scan} method is very complete now. We use the number of steps specified in the config file, we are also using the delay and therefore we import \texttt{sleep} at the top of the file. Then we go through all the voltages. We also defined a variable called \texttt{scan\_data} to hold the values as we measure them. This is a big achievement, that needs to be reflected on the file we were using for testing the Experiment class. We can update \textbf{run\_experiment.py}:

\begin{minted}{python}
[...]
experiment.do_scan()
experiment.finalize()
\end{minted}

When we run the experiment, we will encounter a problem:

\begin{minted}{python}
...

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: setting an array element with a sequence.
\end{minted}

This is because of how Pint and numpy work together. We can't simply put into a numpy array a quantity. However, solving this problem is very straightforward. In the same way we defined the \texttt{scan\_range} as an array with units, we can define \texttt{scan\_data} to also include units:

\begin{minted}{python}
scan_data = np.zeros(num_steps) * ur('V')
\end{minted}

And we can go ahead now and run the experiment without errors. After we do the scan we can finalize the experiment, but there is no way for us to actually look at the data that we acquired. To make the data available to the outside world, or to other methods in the same class, we can define attributes instead of just variables that get destroyed when the method finishes. The \texttt{do\_scan} method can then look like this:

\begin{minted}{python}
def do_scan(self):
    start = ur(self.config['Scan']['start']).m_as('V')
    stop = ur(self.config['Scan']['stop']).m_as('V')
    num_steps = int(self.config['Scan']['num_steps'])
    delay = ur(self.config['Scan']['delay'])
    self.scan_range = np.linspace(start, stop, num_steps) * ur('V')
    self.scan_data = np.zeros(num_steps) * ur('V')
    i = 0
    for volt in self.scan_range:
        self.daq.set_analog_value(self.config['Scan']['channel_out'], volt)
        measured_voltage = self.daq.get_analog_input(self.config['Scan']['channel_in'])
        self.scan_data[i] = measured_voltage
        i += 1
        sleep(delay.m_as('s'))
\end{minted}

We altered both \texttt{scan\_range} and \texttt{scan\_data}, so we can now go back to the \textbf{run\_experiment.py} file and print the values we acquired:

\begin{minted}{python}
[...]

experiment.do_scan()
print(experiment.scan_range)
print(experiment.scan_data)
experiment.finalize()
\end{minted}

Finally we can see the data we acquired after the scan runs. This would allow us to do plenty of things like saving, plotting, analysing, etc. But we should not go ahead of ourselves at this stage. We had layed out a plan for the Experiment class and we should follow it as much as we can. The strategy of adding \texttt{self.} before a variable is very helpful, and this is the real power of objects. The idea is that we should use objects when we need to maintain the \emph{state}. It is not just a function that runs and returns a value, but it is actually updating the \emph{state} of the experiment, or of the device, etc.

Now we can proceed further, to the last missing step: saving data.

\section{Saving Data to a File}\label{section:saving-data}
After we perform a scan, we must save both the data and the \emph{metadata}. With metadata we mean inforation on the parameters used to perform an experiment and that would allow us or anybody else to repeat the measurement. Let's start by the beginning, just saving data to a file, we are going to use the built-in functions of numpy for this, because we have to save two arrays: \texttt{scan\_data} and \texttt{scan\_range}. And since we already know that Pint and Numpy interact in special ways, we anticipate the errors that may appear:

\begin{minted}{python}
def save_data(self):
	data = np.vstack([self.scan_range, self.scan_data]).T
    header = "Scan range in 'V', Scan Data in 'V'"
    filename = self.config['Saving']['filename']
    np.savetxt(filename, data.m_as('V'), header=header)
\end{minted}

The method above works. We can go ahead and run the experiment and we will have a file with two columns (that is the reason for the \texttt{vstack} and the \texttt{.T}) and a header specifying that the data is in units of Volts. However, if we run the experiment for a second time, the data will get overwritten. Moreover, we are saving the data to the same folder where we run the experiment, and this is a very bad idea, we would like to save the data in a dedicated place. Therefore, we need to update the config file first, and then the saving method. The folder we are using for saving data is only an example and should be changed according to each one's needs:

\begin{minted}{text}
Saving:
  filename: data.dat # Files won't be overwritten, but renamed as data_001.dat, etc.
  folder: /home/aquiles/Data
\end{minted}

Something that is very useful when saving data is to organize it by dates. We can create folder with the date the experiment was run inside the \emph{Data} folder. First we will see snippets in order to understand what we need and then we will add the modifications to the method itself. To get the date of today as a string, we can combine the \texttt{datetime} package and the formatting of strings:

\begin{minted}{pycon}
>>> from datetime import datetime
>>> print(datetime.today()
2020-04-13 12:22:34.895038
>>> print(f'{datetime.today():%Y-%M-%d}')
2020-04-13
\end{minted}

The first part is there, we know how to get the folder name based on todays date. Now we have to create the folder if it does not exist:

\begin{minted}{pycon}
>>> import os
>>> data_folder = '/home/aquiles/Data'
>>> today_folder = f'{datetime.today():%Y-%M-%d}'
>>> saving_folder = os.path.join(data_folder, today_folder)
>>> os.path.isdir(saving_folder)
False
>>> os.makedirs(saving_folder)
>>> os.path.isdir(saving_folder)
True
\end{minted}

Using the package \texttt{os} allows us to take care of the common problems that appear when dealing with directories. For example, Linux uses \texttt{/} to separate the structure, while Windows uses \texttt{\\}. Also, it may happen that we define the folder with a trailing \texttt{/} or not. \texttt{os} takes care of all this complexity for us. We join the data folder and today's folder and check if it exists, if it doesn't, we create it. The \texttt{makedirs} will create also the parent directories missing. If the \emph{Data} folder does not exist, it would be created.

Next, we have to be sure we will not overwrite the files when we save new scans. Ideally, we would like the files to look like \texttt{data\_001.dat}, \texttt{data\_002.dat}, etc. Using what we specified in the config file, we can achieve something like it:

\begin{minted}{python}
>>> filename = 'data.dat'
>>> base_name = filename.split('.')[0]
>>> ext = filename.split('.')[-1]
>>> i = 1
>>> new_filename = f'{base_name}_{i:04d}.{ext}'
>>> print(new_filename)
data_0001.dat
\end{minted}

It seems like a lot of work just to format the name, but once we have it, we can use it in all our experiments. We only need to know which is the first available name and save data there. We are now ready to save the data, and also the metadata:

\begin{minted}{python}
import os
from datetime import datetime
[...]

def save_data(self):
	data_folder = self.config['Saving']['folder']
	today_folder = f'{datetime.today():%Y-%M-%d}'
	saving_folder = os.path.join(data_folder, today_folder)
	if not os.path.isdir(saving_folder):
	    os.makedirs(saving_folder)

	data = np.vstack([self.scan_range, self.scan_data]).T
    header = "Scan range in 'V', Scan Data in 'V'"

    filename = self.config['Saving']['filename']
    base_name = filename.split('.')[0]
    ext = filename.split('.')[-1]
    i = 1
    while os.path.isfile(os.path.join(saving_folder, f'{base_name}_{i:04d}.{ext}'):
        i += 1
    data_file = os.path.join(saving_folder, f'{base_name}_{i:04d}.{ext}'
    metadata_file = os.path.join(saving_folder, f'{base_name}_{i:04d}_metadata.yml'
    np.savetxt(data_file, data.m_as('V'), header=header)
    with open(metadata_file, 'w') as f:
        f.write(yaml.dump(self.config, default_flow_style=False))
\end{minted}

The \texttt{save\_data} method may be the most complex in the program, but it is also very powerful. We start with a base folder, and create a folder with the current date, with the format Year-Month-Day. We format the data to make it easy to store as two columns on a text file, and we also add a header to explain what are we storing. We extract the base part of the filename and the extention as two separate variables, and we format the the filename in such a way that it can have a number appended to it. The syntax \texttt{i:04d} is the secret to formating numbers with an appropriate number of $0$ in front. We use a while loop to increase the counter until the first file is available, and use that value to store the data. We also create another file, with the same number and a similar name, to store the metadata. In our case, the metadata is nothing more than the \texttt{config} dictionary.

\note{A very handy by product of saving the config as a YAML file is that we can use it as the config file for the next experiment. If at some point we want to repeat a measurement we did in the past, we just need to point the experiment to the config we saved from that date.}

We can update the \textbf{run\_experiment.py} file, and perform a complete measurement:

\begin{minted}{python}
import sys
import os

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(base_dir)

from PythonForTheLab.model.experiment import Experiment

experiment = Experiment('experiment.yml')
experiment.load_config()

experiment.load_daq()

experiment.do_scan()
experiment.save_data()
experiment.finalize()
\end{minted}

Except for the part of appending the folder to the system path, we can run a relatively complex experiment in less than 10 lines of code, including saving data and metadata. Being able to reduce a complex problem to a relatively simple flow is thanks to the effort we put into defining the proper methods in the experiment and device models.

\section{Conclusions}\label{section:experiment-model-conclusions}
With this chapter, the core code for a functioning experiment is finished. Defining an Experiment model is one of the best strategies to simplify the work needed to perform a measurement. Once the complicated bits of code such as doing a scan or saving data are in place, our running script just needs one line of code and the rest will automatically be taken care of. If you share the code with a colleague, for example, and you show them the \texttt{run\_experiment} script, they will be able to perform their own measurements in no time.

We left still some more things that should be done in our experiment. For example, we are still acquiring voltages instead of currents. We are not going to explicitly solve this problem because it is a very good exercise to start thinking by yourself

\exercise{Update the config file to include information on the resistance that we are using. With that value, update the \texttt{do\_scan} method to acquire amperes (or milliamperes) instead of volts. Finally, you will need to update the save method to accomodate for the changes, not only in the header but also in how we transform the arrays to unitless before saving them.}

Some other topics which are still relevant, and that we are going to cover on the next chapter include how to change the parameters of the scan directly from within the running script. This would allow us to, for example, scan the voltages with varying delays to understand if there is some form of hysteresis, or scans with increasing resolution around specific features. We have also neglected what would happen if someone forgets to load the config file or the daq before starting a scan, for example.

The final missing bit, is how to stop the experiment while it is running. If we see something is going wrong, there is no way of deciding to stop it without losing data. There are a lot of different approaches for solving this, but the one we are going to explore is based on \emph{Threads}, a very useful tool for developing acquisition software but that may have a somewhat high entry barrier for newcomers to Python.
