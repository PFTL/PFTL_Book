%! Suppress = Ellipsis
\chapter{Writing the First Driver}\label{ch:first-driver}

\section{Introduction}\label{sec:driver-introduction}
The cornerstone of every experiment is the ability to communicate with real-world devices. However, the devices you might use are very different from one another. Not only is their behavior different (you can't compare a camera to an oscilloscope), but they also communicate in different ways with a computer. In this chapter, you'll build your first \textbf{driver} for communicating with a real-world device. You'll learn about low-level communication with a serial device, and then you'll build a reusable class that you can share with other developers.

You can split devices into different categories depending on how they communicate with a computer. One of the most common ways to communicate is through the exchange of \textbf{text-based messages}. The idea is that the user sends a specific command, usually in the form of a message, and then the device answers with specific information in the form of another message. Sometimes there won't be an answer as the message you sent simply tells the computer to perform an action, such as setting something automatically or switching itself off. Other times, the message you get back contains the information you requested.

For an idea of what these commands might look like, you can check the user manuals for devices such as oscilloscopes or function generators. Both Tektronics\footnote{You can check the manual of an oscilloscope here: https://www.tek.com/oscilloscope/tds1000-manual} and Agilent have complete sets of instructions. If you search through their websites, you'll find plenty of examples. A command that you can send to a device may look like this:

\begin{minted}{text}
 *IDN?
\end{minted}

This is asking the device to identify itself. An answer to that request would look like \py{Oscilloscope ID######}. In this chapter, you're going to see how you can exchange messages with devices using Python.

The devices that exchange information with the computer in this way are called \textbf{message-based} devices. Examples of these types of devices include oscilloscopes, lasers, function generators, lock-ins, and many more. The {PFTL DAQ} device that works with this book is also included in this category. If you obtained the book online and not as part of a workshop, then you can either build your own device, or you can contact us and we may be able to offer you one that's preprogrammed\footnote{courses@pythonforthelab.com}.

\tipsInfo{Device Drivers}{There's an entire world of devices that do not communicate through messages, but that instead specify their own drivers. These are typically devices like cameras, fast data acquisition cards, motorized mirrors and stages, and more. They depend on specific drivers and are harder to work with at this stage. If you're already confident in programming message-based devices and are ready to move on to non-message based ones, then you can check out the Advanced Python for the Lab materials.}

Remember, \textbf{message-based} refers only to how the device exchanges information with the computer, not to the actual connection between them. It's possible to connect a message-based device via RS-232, USB, GPIB, or TCP/IP. However, beware that this is not a reciprocal relation: not all devices connected through RS-232 or USB are message-based. If you want to be sure, check the device manual and see how it's controlled. In this chapter, you're going to build a driver for a message-based device.

\subsection{Understanding this chapter's scope}\label{subsec:scope-of-the-chapter}
In the introduction, you saw that the objective is to acquire the I-V curve of a diode. You need, therefore, to set an analog output (the V) and read an analog input (the I) with the device. In this chapter, you'll learn everything you need to perform your first measurement. However, keep the onion principle in mind, which tells you that you should always be prepared to expand your code later on should the need arise.

\section{Communicating with the Device}\label{sec:message-basedevices}
To communicate with the {PFTL DAQ}\footnote{PFTL is the shorthand notation for Python for the Lab} device, you're going to use a package called \py{PySerial}, which you should have already installed if you followed Chapter~\ref{ch:setting-up}. The first thing you can do is list all the devices connected to your computer to identify the one you're interested in. Plug your device into the USB port on your computer. You need to connect the {PFTL DAQ} device through the micro USB port closest to the power jack, also known as the \emph{programming port}. Then, run the following command in a terminal, making sure that you're in your virtual environment containing the required packages):

\begin{minted}{bash}
python -m serial.tools.list_ports
\end{minted}

\warningInfo{Warning}{From now on, you won't see explicit instruction telling you to open a terminal to run a command. If you see a command that starts with a dollar sign \$, it means that you should run it in the terminal.}

Depending on your operating system, the output can be slightly different. On Windows, you get something like this:

\begin{minted}{bash}
COM3
\end{minted}

If you're on Linux you'll see something like this:

\begin{minted}{bash}
/dev/ttyACM0
\end{minted}

The most important thing is to remember the number at the end. If you happen to see more than one device listed (this is very common on Mac), unplug the {PFTL DAQ}, run the command to list the ports again, and note which ones appear. Then, plug it back in and list the devices. The new one is the device you want.

Now it's time to start working with the device! Start Python by running the following command:

\begin{minted}{bash}
 python
\end{minted}

You can start working directly from the command line. First, you're going to import the package you need for communication:

\begin{minted}{pycon}
>>> import serial
\end{minted}

\checkInfo{Interpreter Symbols}{Earlier you learned that you must run everything prepended with a \$ in a terminal. Lines prepended by \mintinline{pycon}{>>>} are lines that you run in the Python interpreter. Note that there's no need to type the \mintinline{pycon}{>>>}, as the Python interpreter prints it out automatically.}

Then you can open a line of communication to the device. Bear in mind that you must change the port number to the one you retrieved earlier:

\begin{minted}{pycon}
>>> device = serial.Serial('/dev/ttyACM0') # <---- CHANGE THE PORT!
\end{minted}

Now you're ready to get started exchanging messages with the device. Before you read the explanation of each line, try to run the code yourself first. Note that the lines without \mintinline{pycon}{>>>} are the output generated by the code.

\begin{minted}{pycon}
>>> device.write(b'IDN\n')
4
>>> answer = device.readline()
>>> print(f'The answer is: {answer}')
The answer is: b'PFTL DAQ Device built by Python for the Lab v.1.2020\n'
>>> device.close()
\end{minted}

Even though they're short, many things are going on in the code blocks above. First, you import the PySerial package. Note that you're actually importing \py{serial} and not \py{PySerial}. Then you open the specific serial port that identifies the device. Keep in mind that serial devices can maintain only one connection at a time. If you try to run the line twice, it will give you an error letting you know that the device is busy. This could happen if, for instance, you try to run two programs at the same time, or if you were to start Python from two different terminals.

Once you've established the connection, you send the \textbf{{IDN}} command to the device. There are some caveats in the process. First, the \mintinline{python}{\n} at the end is a special character known as a \textbf{newline}. It's a way to tell the device that you're not going to send any more information afterward. When a device is receiving a command, it reads the input until it knows that no more data is arriving. If you were sending a value to a device such as a wavelength, the command could look like this: \py{SET:WL:1200}. However, the device needs to know when it has received the last number. It's not the same as setting the laser wavelength to $120\,\textrm{nm}$ or to $1200\,\textrm{nm}$.

The other caveat is the \mintinline{python}{b} before the command string. Adding the \mintinline{python}{b} in front of a string is one way of telling Python to encode a string as a \textbf{binary string}. Devices don't understand what the letter \textit{A} is. The serial communication can only send a stream of 1s and 0s. Therefore, you need to transform any information you're trying to send, such as \mintinline{python}{'IDN'}, into bytes before you can send it to the device. You'll see a lengthier discussion about encoding strings and what that means at the end of the chapter, in section~\ref{sec:unicode}.

After you write to the device, you get \py{4} as output. This is the number of bytes you sent, taking into account that \mintinline{python}{\n} is only one byte because it's only one character. To get the answer that the device is generating for you, you have to read from it. You use the \mintinline{python}{.readline()} method for this. Then, you print the answer to the screen. The answer you get also has a \py{\n} and a \py{b}. Finally, you close the connection to the device.

We decided to use the \py{IDN} command because we knew it existed. But if you're starting with a new device, it's always important to start by reading the manual. Manuals are the best and, perhaps, only friend you'll have when developing software for controlling instruments. The {PFTL DAQ} is no exception. The manual is part of the book, and you can find it in Appendix~\ref{ch:pftl-daq-manual}. It's a simple manual, but with enough information to get started, and it follows similar conventions to those you can find on more complex devices.

In the manual, the first thing you have to find is the line termination. We used the newline character because we knew it, but each device can specify something different. Some devices use the newline character as part of the commands you can send and specify that the line ending must be something else. Once you know how to terminate commands, you can go ahead and see the list of options.

Many devices (but not all) follow a standard called SCPI\footnote{https://bit.ly/wiki\_SCPI}. The standard makes devices easy to exchange, because the commands for all oscilloscopes are the same, as well as for all function generators, and so forth. Moreover, the SCPI standard follows a structure that makes messages modular and easy to understand. A more powerful oscilloscope, for example, has commands not available to a more basic device, but the common features are controlled by the same messages.

Now that you know how to get started with serial communication, it's time to move to more complex programs. Typing everything on the Python interpreter is inefficient and takes too much time. It's time to start working with files.

\subsection{Organizing files and folders}\label{subsec:organizing-files-and-folders}
When you start a new project, it's always a good idea to decide how you're going to organize your work. In the previous chapter, you've set up an environment for developing a program. That's the first step to be organized. The second step is deciding where you're going to save the files you need to write your program. The general advice is to have a folder for all the programs, for example, \py{Programs}. Inside of that folder, each project you work on has its own sub-folder, such as \py{PythonForTheLab}. Each person has their own way of organizing themselves, but from now on, every time we talk about creating a file, we're referring to that base folder for the project.

\section{Writing a Basic Python Script}\label{sec:basic-python-script}
The code you've developed above can also be written as a Python script, which you can run from the command line without needing to re-write everything. Create an empty file called \mintinline{bash}{communicate\_with\_device.py} and add the same code you saw earlier to it:

\begin{minted}{python}
import serial

device = serial.Serial('/dev/ttyACM0')
device.write(b'IDN\n')

answer = device.readline()
print(f'The answer is: {answer}')

device.close()
\end{minted}

Now you can run the file:

\begin{minted}{bash}
 python communicate_with_device.py
\end{minted}

\tipsInfo{Changing Directories}{To be able to run the file, you need to be in the same folder where the file is located. To change the folder in the terminal, you can use \py{cd}.}

\subsubsection{What happens when you run the file}

The program hangs, but there's no error message and no IDN information gets printed to the screen. This means that the program is waiting for something to let it continue. To force the program to stop, you can press Ctrl+C. If this does not work on Windows, you can press Ctrl+Pause/Break. This is the easiest way to debug when such a situation appears.

You want to know first when the program hangs, and then you can see how to fix it. Edit the file and add some print statements to check until which point the program is running:

\begin{minted}{python}
import serial
print('Imported Serial')

device = serial.Serial('/dev/ttyACM0')
print('Opened Serial')

device.write(b'IDN\n')
print('Wrote command IDN')

answer = device.readline()
print(f'The answer is: {answer}')

device.close()
print('Device closed')
\end{minted}

Rerun the script. Where is it hanging? Surprisingly, it's hanging during the \py{.readline()} execution. Can you understand what's going on?

There's something very different between writing in the Python interpreter and running a script, and that's the time it takes to go from one line to the next. While you type, everything happens slowly, but when you run a script, everything happens incredibly fast. Now, the \py{.readline()} is waiting to get some information from the device, but the devices aren't generating it. This means that the problem comes earlier when you send the \py{IDN} message. The command is not wrong in and of itself, but what's happening is that between opening the communication with the device and sending the first message, you're not giving it any time.

When you establish communication with most devices, there's a small delay until you can start using it. In this case, you must add a delay between starting the communication and sending the first message. You can achieve this by doing the following:

\begin{minted}{python}
import serial
from time import sleep

device = serial.Serial('/dev/ttyACM0')
sleep(1)

device.write(b'IDN\n')
answer = device.readline()
print(f'The answer is: {answer}')
device.close()
print('Device closed')
\end{minted}

If you rerun the program, you can see that it takes a bit of time to run, but it outputs the proper message. The \py{sleep()} function makes the program wait for a given number of seconds (which you can also input as fractions) before continuing. You can try lowering the number until you get the minimum possible value. Still, in most typical cases, you start the communication only once, so waiting 1 second or .5 seconds won't have a significant impact on the overall execution time.

\subsubsection{Reading an analog value}
Before you continue, it would be great to also read a value from the device, not just the serial number. If you refer again to the manual, you see that the way of getting an analog value is using the \py{IN} command. You can modify the code on your previous program to read a value from the device:

\begin{minted}{python}
import serial
from time import sleep

device = serial.Serial('/dev/ttyACM0')
sleep(1)

device.write(b'IDN\n')
answer = device.readline()
print(f'The answer is: {answer}')

device.write(b'IN:CH0\n')
value = device.readline()
print(f'The value is: {value}')
device.close()
print('Device closed')
\end{minted}

The value you're reading won't make much sense, especially if there's nothing connected to the input number 0; it's just noise. But it's an excellent first step! You can acquire a value from the real world using the device. You'll take care of all the things that you need to address in the following chapters. In the meantime, try your hand at the following exercises.

\questionInfo{Exercise}{What happens if you use \mintinline{python}{.read()} instead of \mintinline{python}{.readline()}?}

\questionInfo{Exercise}{What happens if you use \py{.read()} once, and then \py{.readline()}?}

\questionInfo{Exercise}{What happens if you call \py{.readline()} before writing the \py{IDN} command?}

\questionInfo{Exercise}{What happens if you try to write to the device after you have closed it?}

\warningInfo{Important note about ports}{If you're using the old {RS}-232 (also simply known as \emph{serial}), the number refers to the physical number of the connection. On Windows, it's something like {COM1}, whereas on Linux and Mac, it should be something like /dev/ttyACM1. In modern computers, there are no {RS-232} connections, and most likely, you have to use a {USB} hub for them. This means that there's no physical connection straight from the device into the motherboard. The numbering can change if you plug or unplug the cables.

The {PFTL DAQ} device, since it acts as a hub for a serial connection, can show the same behavior. If you plug or unplug the device while it's being used, the port you get the second time will likely be different. The second time you run the program, you'll need to update the information.}

\questionInfo{Exercise}{Read the {PFTL DAQ} manual and find a way to set an analog output to 1 Volt.}

\section{Preparing the Experiment}\label{sec:preparing-the-experiment}
Before you move forward with programming, you first need to set up the measurement you want to perform and determine what you need to achieve it. This book revolves around the idea of measuring the I-V curve of a diode. If you're not too familiar with electronics, don't worry! It's not essential for you to be able to follow the book. You can just copy the connections as shown below. If you're a bit more familiar with electronics, then it's worth explaining what you're going to do.

\textbf{Diodes} are elements that let current flow only in one direction, but their behavior is highly non-linear. The current flowing is not proportional to the voltage applied. We chose to use an LED for the experiments because it's easy to have visual feedback on what is going on. On the other hand, you can't measure current directly. First, you need to transform it into a voltage. If you're familiar with Ohm's law, then you remember this relationship:

\begin{equation}
V = I \cdot R
\end{equation}

Voltage is current times resistance. In other words, if you want to transform a current to a voltage, you just need to add resistance to the circuit.

To perform the experiment, you need to apply a given voltage and read another voltage. This pattern is common to a wealth of experiments. The underlying meaning is what matters.

With the {PFTL DAQ} device, the connections that will allow you to apply a voltage and read a voltage are as follows:

\begin{figure}
\centering
\includegraphics[width=.5\textwidth]{images/Chapter_03/IV_scheme_bb.png}
\caption{Schematic of the connections to perform the experiment}
\end{figure}

All you need to follow the rest of the book are three cables, an LED, and a resistance. You apply the voltage to the LED through \py{DAC0}. The current flows through the diode and the resistance. The voltage that you acquire at the \emph{Analog In} \py{A0} is proportional to the current flowing through the resistance.

\questionInfo{Exercise}{Now that you have set up the experiment, you know how to set and read values. Acquire the I-V curve of the diode. It's a challenging exercise, aimed at showing you that it doesn't take a long time to be able to achieve an essential goal.}

\section{Making Improvements}\label{sec:going-higher-level}
You saw that communicating with a device implies taking into account parameters such as the line ending, or adding the \py{b} in front of messages for encoding. If the number of commands is large, this becomes very unwieldy. The {PFTL DAQ} device is an exception because it's minimal, but there are still a lot of possible improvements.

If you still remember the \emph{Onion Principle} (Section~\ref{sec:onion-principle}), it's now the time to start applying it. If you completed the last exercise, you probably have written a lot of code to do the measurement. Perhaps you used a for loop and acquired values in a sequence. However, if you want to change any of the parameters, you need to alter the code itself. This approach is not very sustainable for the future, especially if you're going to share the code with someone else.

Since you know how to communicate with the device, you can transform that knowledge into a reusable Python code by defining a \textbf{class}. Classes have the advantage of being easy to import into other projects, and they're easy to document and to understand. Moreover, it's quite simple to expand on them later on. If you're not familiar with what classes are, check Appendix~\ref{ch:classes-in-python} for a quick overview. With a bit of patience and critical thinking, you can follow the rest of the chapter and understand what is going on as you keep reading.

Create a new, empty file called \textbf{pftl\_daq.py} and write the following into it:

\begin{minted}{python}
import serial
from time import sleep


class Device:
    def __init__(self, port):
        self.rsc = serial.Serial(port)
        sleep(1)

    def idn(self):
        self.rsc.write(b'IDN\n')
        return self.rsc.readline()

\end{minted}

The code above shows you how to start a class to communicate with a device and get its serial number. However, if you run the file, nothing happens. At the end of the file, add the following code:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
\end{minted}

If you rerun the code, you get the serial number of the device. Let's go line by line to understand what is going on. First, you create a class, and you define what you want to happen when you call \py{Device()}. In the \py{__init__} method, you specify that the class needs a port, and you use that port to start the serial communication. The serial communication is stored as \py{self.rsc} in the class itself, where \py{rsc} is just a shorthand notation for \textit{resource}. Then you sleep for one second to give time for the communication to be established.

The second method, \py{idn()}, just repeats what you have done earlier: you write a command, you read the line, and you return the output. If you look at the few lines at the bottom of the file, you now see that this way of working with this class is simpler. You just use \py{.idn()} instead of having to write and read every time.

\questionInfo{Exercise}{Once you read the serial number from the device, it does not change. Instead of just returning the value to the user, store it in the class in the attribute \mintinline{python}{self.serial_number}.}

\questionInfo{Exercise}{When you use the method \mintinline{python}{.idn()}, instead of writing to the device, check if the command was already used and return the value stored. This behavior is called \textbf{caching}, and it's very useful for not overflowing your devices with useless requests for data.}

\subsubsection{Reading and setting values}
You have just developed the most basic class, one that allows you to start communicating with the device and reading its identification number. You can also write methods for reading an analog input or generating an output. The most important thing is to decide what argument each method needs. For example, reading a value only needs the channel that you want to read. Setting a value needs not only a channel but also the value itself. Also, reading a means that the method returns something. When you set an output, there's not much to return to the user.

\questionInfo{Exercise}{Write a method \mintinline{python}{get_analog_input} which takes two arguments, \mintinline{python}{self} and \mintinline{python}{channel}, and which returns the value read from the specified channel.}

\questionInfo{Exercise}{Write a method \mintinline{python}{set_analog_value} which takes three arguments (\mintinline{python}{self}, \mintinline{python}{channel}, and \mintinline{python}{value}) and that sets the output value to the specified port.}

Even though the exercises are important for you to start thinking by yourself, they have some caveats that are very hard to iron out if you don't have a bit of experience. First, let's look at the way of reading an analog input. You can try to develop a method that looks like this:

\begin{minted}{python}
def get_analog_input(self, channel):
    message = f'IN:CH{channel}\n'
    self.rsc.write(message)
    return self.rsc.readline()
\end{minted}

However, it won't work, because even though you're adding the line ending, you're missing the \py{b} that you were using in the other examples. On the other hand, say you try to do something like this:

\begin{minted}{python}
message = b'IN:CH{}\n'.format(channel)
\end{minted}

This will also fail, because \py{format} only works with strings, and as soon as the \py{b} is added in front of a string, it's encoded to bytes. This means that you have to do it in two steps:

\begin{minted}{python}
def get_analog_input(self, channel):
    message = f'IN:CH{channel}\n'
    message = message.encode('ascii')
    self.rsc.write(message)
    return self.rsc.readline()
\end{minted}

First you form the message you want to send to the device, then you \textbf{encode} it, which is the same as adding the \py{b} in front of a string. Then you write it to the device. After writing, you return the line with the value. You could use it as follows:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
volts = dev.get_analog_input(0)
print(volts)
\end{minted}

If you run the code above, you will notice that the output still has the \py{b} and the \py{\n}. You will work on this later. The next step is to generate an output:

\begin{minted}{python}
def set_analog_output(self, channel, output_value):
    message = f'OUT:CH{channel}:{output_value}\n'
    message = message.encode('ascii')
    self.rsc.write(message)
\end{minted}

You can use it as follows:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
volts = dev.get_analog_input(0)
print(volts)
dev.set_analog_output(0, 1000)
\end{minted}

This would be all, unless you add something extra, like reading the input after setting the output:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
volts = dev.get_analog_input(0)
print(volts)
dev.set_analog_output(0, 1000)
volts = dev.get_analog_input(0)
print(volts)
\end{minted}

The second time you read the analog input, you get the same value you passed to the analog output. It does not matter if it's $1000$ or $999$; it does not matter if the cables are connected or not. The value is always the same.

\questionInfo{Exercise}{Explain why, when getting the analog input, you get the same value that you set earlier.}

This question is very tricky and requires that you read the manual of the device. In the documentation for the \py{OUT} command, you can see that it returns something: the same value that was passed to it. However, in this method, you're just writing to the device and not reading from it. The message waits in the queue until the next time you read from it, and this happens when you try to read an analog input.

As you can see, the number of possible mistakes that you can make when developing this kind of program is huge. On top of that, many mistakes do not generate an error and can easily go unnoticed. When performing measurements, perhaps you won't realize the mistake on \py{.set_analog_output()} until you're analyzing the data you acquired.

To solve the problem while setting the output, you just need to read from the device after setting the output:

\begin{minted}{python}
def set_analog_output(self, channel, output_value):
    message = f'OUT:CH{channel}:{output_value}\n'
    message = message.encode('ascii')
    self.rsc.write(message)
    self.rsc.readline()
\end{minted}

You are not doing anything with the information you get. You just clear it from the device.

\subsubsection{Transforming bytes to strings}
To have a more functional class, it would be great if you could get rid of the extra \py{b} and \py{\n} that you get every time you use the \py{.readline()} method. First, you need to transform bytes to strings. In the previous section you transformed strings to bytes by using \py{.encode('ascii')}. To no surprise, if you want to transform bytes to a string, you can do the opposite in the \py{.idn()} method itself:

\begin{minted}{python}
def idn(self):
    self.rsc.write(b'IDN\n')
    answer = self.rsc.readline()
    answer = answer.decode('ascii')
    return answer
\end{minted}

If you try this out, you will see that it took care of the initial \py{b}, but the \py{\n} is still there. You need one more step to get rid of it:

%! Suppress = Ellipsis
\begin{minted}{python}
def idn(self):
    [...]
    answer = answer.strip()
    return answer
\end{minted}

Note that we have used %! Suppress = Ellipsis
\py{[...]} to hide the code that didn't change. Now you can go ahead and see that the output is formatted correctly.

\questionInfo{Exercise}{By using what you've learned for the \py{.idn()} method, improve the \py{.get_analog_input()} method so that it returns an integer. \textbf{Hint:} To transform a string to an integer, you can use \py{int()}, for example: \py{int('12')}.}

\subsection{Abstracting repetitive patterns}\label{subsec:abstracting-repetitive-patterns}
There's a programming principle called \textbf{DRY}, which stands for \emph{Don't Repeat Yourself}, which many developers use to help them build programs. Sometimes it's clear that code is repeating itself, for example, if you copy-pasted some lines. However, oftentimes the repetition is not about code itself but a pattern. {DRY} is not a matter of just typing fewer lines of code. It's a way of reducing errors and making the code more maintainable. Imagine that after an upgrade, the device requires a different line ending. You would need to go through all your code to find out where the line ending is used and change it. If you would specify the line ending in only one location, changing it would require that you just change one line.

Let's use the DRY principle to refactor your code. First, you can specify the default parameters for your device. They will be all the constants that you need in order to communicate with it, such as line endings. You can define them just before the \mintinline{python}{__init__} method, like this:

\begin{minted}{python}
class Device:
    DEFAULTS = {'write_termination': '\n',
                'read_termination': '\n',
                'encoding': 'ascii',
                'baudrate': 9600,
                'read_timeout': 1,
                'write_timeout': 1,
                }
    def __init__(self, port):
        [...]
\end{minted}

You can see that there's a lot of new information in the class. You have established a clear place where both the read and write line endings are specified (in principle, they don't need to be the same). You also specify that you want to use ascii to encode the strings and that the baud rate is 9600. This value is the default of PySerial, but it's worth making it explicit in case newer devices need a different option. You also specify timeouts, which are allowed by PySerial and would prevent the program from freezing if writing or reading takes too long.

It's normally good practice to separate the instantiation of the class with the initialization of the communication. One task is to create an object in Python, and the other is to establish communication with a real device. Therefore, you can rewrite the class like this:

\begin{minted}{python}
def __init__(self, port):
    self.port = port
    self.rsc = None

def initialize(self):
    self.rsc = serial.Serial(port=self.port,
                    baudrate=self.DEFAULTS['baudrate'],
                    timeout=self.DEFAULTS['read_timeout'],
                    write_timeout= self.DEFAULTS['write_timeout'])
    sleep(1)
\end{minted}

You can see that there are some major changes to the code, but the arguments of the \mintinline{python}{__init__} method are the same. In this way, code already written does not fail if you change the number of arguments of a method. When you do this kind of change, it's called \textbf{refactoring}. It's a complex topic, but one of the best strategies you can adopt is to not change the number of arguments functions take and to keep the output the same.

In the class, the \mintinline{python}{__init__} definition looks the same, but its behavior is different. Now, it just stores the \mintinline{python}{port} as the attribute \mintinline{python}{self.port}. Therefore, to start the communication with the device, you need to do \mintinline{python}{dev.initialize()}. You can also see that you have used almost all the settings from the \mintinline{python}{DEFAULTS} dictionary to start the serial communication.

After you do these changes, you should also update the code you use to test the device:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
dev.initialize()
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
volts = dev.get_analog_input(0)
print(volts)
dev.set_analog_output(0, 1000)
volts = dev.get_analog_input(0)
print(volts)
\end{minted}

\sloppy So far the only difference with the previous code is the \mintinline{python}{__init__} method. You have to improve the rest of the class. You already know that for message-based devices there are two operations: \textbf{read} and \textbf{write}. However, you will only read after a write, since you should always ask something from the device first. It's possible to update the methods of the class to reflect this behavior. Since all the commands of the device return a value, you can develop a method called \py{.query()}:

\begin{minted}{python}
def query(self, message):
    message = message + self.DEFAULTS['write_termination']
    message = message.encode(self.DEFAULTS['encoding'])
    self.rsc.write(message)
    ans = self.rsc.readline()
    ans = ans.decode(self.DEFAULTS['encoding']).strip()
    return ans
\end{minted}

In this way, you take the message, append the proper termination, and encode it as specified in the \py{DEFAULTS}. Then, you write the message to the device exactly as you did before. Finally, you read the line, decode it using the defaults, and strip the line ending. Now it's time to update the other methods of the class to use the \py{.query()} method you have just developed. Let's start with \py{.idn()}, which now looks like this:

\begin{minted}{python}
def idn(self):
    return self.query('IDN')
\end{minted}

You can do the same for the other methods:

\begin{minted}{python}
def get_analog_input(self, channel):
    message = 'IN:CH{}'.format(channel)
    ans = self.query(message)
    ans = int(ans)
    return ans

def set_analog_output(self, channel, output_value):
    message = 'OUT:CH{}:{}'.format(channel, output_value)
    self.query(message)
\end{minted}

For such a simple device, perhaps the advantages of abstracting patterns are not evident. It's something that happens very often in more extensive programs, and being able to identify those patterns can be the difference between a successful program and something only one person can understand. Note that even if you have changed the methods for identifying, reading, and setting analog values, there's no need to update the example code.

It's important to see that you achieved communication with the device through the resource \mintinline{python}{self.rsc} that's created with the method \mintinline{python}{.initialize()}. There is a common pitfall with this command. If you try to interact with the device before you initialize it, you get an error like the following:

\begin{minted}{python}
AttributeError: 'NoneType' object has no attribute 'write'
\end{minted}

You now remember why this happened, but it's very likely that in the future, either you or someone else using your code runs across this error message that appears, and it's incredibly cryptic. Therefore, it's recommended that you do the following:

\questionInfo{Exercise}{Improve the \py{.query()} method to check whether communication with the device has initialized. If it hasn't, you can print a message to the screen and prevent the rest of the program from running.}

When you develop code, you must always keep an eye on two people: the future you and other users. It may seem obvious now that you must initialize communication before attempting anything with the device, but in a month, or a year from now, when you dig up the code and try to do something new, you're going to be different person. You won't have the same ideas in your mind as you do right now. Adding safeguards is a great way of preserving the integrity of your equipment. It also cuts down on the time it takes to find out what the error was.

There's only one last thing that you're missing. You have completely forgotten to add a proper way of closing the communication with the device. You can call that method \py{.finalize()}:

\begin{minted}{python}
def finalize(self):
    if self.rsc is not None:
        self.rsc.close()
\end{minted}

You first check that you have actually created the communication by verifying that the \mintinline{python}{rsc} is not \mintinline{python}{None}. Then, you can update your example code at the bottom of the file to actually use the \py{.finalize()} method:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
dev.initialize()
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
volts = dev.get_analog_input(0)
print(volts)
dev.set_analog_output(0, 1000)
volts = dev.get_analog_input(0)
print(volts)
dev.finalize()
\end{minted}

You may wonder why things work out fine even though you didn't have the \py{finalize} method in place. The answer is that PySerial is smart enough to close the communication with the device when it realizes you will no longer use it. However, it's not always the case if the program crashes. Sometimes the communication stays open, and the only way to regain control of the device is by manually shutting it off and on again. If this happens, you must always check whether the port changed.

\section{Interacting with the Real World}\label{sec:doing-something-in-theemph}
Until now, everything looked like a big exercise of programming but now it's time to start interacting with the real world. As you know from reading the manual, the {PFTL DAQ} device can generate analog outputs, and the values you can use go from $0$ to $4095$. You can expand slightly the code below the class in order to make the LED blink for a given number of times, and report the measured voltage when it's either on or off:

\begin{minted}{python}
dev = Device('/dev/ttyACM0') #<---- Remember to change the port
dev.initialize()
serial_number = dev.idn()
print(f'The device serial number is: {serial_number}')
for i in range(10):
    dev.set_analog_output(0, 4000)
    volts = dev.get_analog_input(0)
    print(f'Measured {volts}')
    sleep(.5)
    dev.set_analog_output(0, 0)
    volts = dev.get_analog_input(0)
    print(f'Measured {volts}')
    sleep(.5)
\end{minted}

With this simple code, you can switch on and off the LED 10 times, and you print to screen the values that you're reading when it's on or off. There are two things to note: first, you are switching it ON by using a value of $4000$. You have selected it because it's high enough to switch the LED on, but it has no units, it's not a voltage. The same with the value reported by the \py{get_anlog_input}, which is just an integer, but you have no idea, yet, of what it means.

Before you can proceed, you must understand how to transform Analog signals to digital values and the opposite.

\subsection{Digitizing Signals}\label{subsec:adc-dca}
Almost every device that you find in the lab transforms a continuous signal to a value that can be understood by the computer. The first step is to transform the quantity you're interested in a voltage. Then, you need to transform the voltage (an analog signal) to something with which the computer can work. Going from the real world to the computer space is normally called \emph{digitizing} a signal. The main limitation of this step is that the space of possible values is limited, and therefore you have discrete steps in our data.

For example, the {PFTL DAQ} device establishes that when reading a value, it uses 10 bits to digitize the range of values between $0\,\textrm{V}$ and $3.3\,\textrm{V}$. In the real world, the voltage is a real number that can take any value between $0\,\textrm{V}$ and $3.3\,\textrm{V}$. In the digital world, the values are going to be integers between $0$ and $1023$ ($2^{10}-1$). It means that if the device gives us a value of $0$, you can transform it to $0\,\textrm{V}$. A value of $1023$ corresponds to $3.3\,\textrm{V}$, and there's a linear relationship with the values in between.

\begin{center}
\includegraphics[width=.6\textwidth]{images/Chapter_03/digitalization.png}
\end{center}

The figure above shows a detail of how the digitalization looks like for a range of voltages. You see the discrete steps that the digital value takes for different voltages. Digitizing signals is a critical topic for anybody working in the lab. There is a whole set of ramifications regarding visualization, data storage, and more.

Particularly, the {PFTL DAQ} has a different behavior for reading than for setting values. The output channels take $4095$ ($2^{12}-1$) different values, i.e.\ they work with 12 bits instead of 10. Knowing the number of bits, also allows us to calculate the minimum difference between two output values:

\begin{equation}
 \frac{3.3\,\textrm{V} - 0\,\textrm{V}}{4096} \approx 0.0008\,\textrm{V} = 0.8\,\textrm{mV}
\end{equation}

The equation above shows how the resolution of the experiment is affected by the digitalization of the signals. You can't create voltages with a difference between them below $0.8\,\textrm{mV}$, and you're not able to detect changes below $3\,\textrm{mV}$. Later in the book, you come back to this discussion when you need to decide some parameters for visualizing our data.

Digitizing is everywhere. Digital cameras have a certain \emph{bit depth}, which tells us which range of values they can cover or, in other words, their dynamic range. Oscilloscopes, function generators, acquisition cards, they all have a precise digital resolution. When planning experiments, you always need to keep an eye on these values to understand if the devices are appropriate for the measurement you want to perform.

\questionInfo{Exercise}{You have used a for-loop to switch on and off the LED, and you have also displayed the voltage measured, but without units. Update the code so that instead of printing integers it prints the read value in volts.}

\section{Performing an Experiment}\label{sec:doing-an-experiment}
At this stage, you can easily communicate with the device; you can set an output and measure a voltage. It means that you have developed everything that you needed to measure the current that goes through the LED. You only need to combine setting an analog output and then reading an analog input. Since you're going to develop this with a more consistent approach, you leave it as an exercise:

\questionInfo{Exercise}{Write a method that allows you to linearly increase an analog output in a given range of values for a given step. \textbf{Hint:} the function \py{range} allows you to do this:

\py{range(start, stop, step}.

If you use this method, you should be able to see the LED switching gradually on.}

\questionInfo{Exercise}{Improve the method so that you can read analog values and store them once the measurement is complete. Returning the values can be a good idea so that you can use them outside of the object itself.}

\questionInfo{Exercise}{If you already have some experience with Python, you can also make a plot of the results. You cover this topic, later on, so don't stress too much about it now.}

If you tried to solve the exercises, you probably noticed that by having classes, our code is straightforward to use. It would be simple to share it with a colleague that has the same device, and they can adapt and expand it according to their needs. You should also keep in mind that when working with devices, it may very well be that someone else has already developed a Python driver for it, and you can just use it. One of the keys to developing sustainable code is to compartmentalize different aspects of it. Don't mix the logic of a particular experiment with the capabilities of a device, for example, is precisely the topic of the following chapter.

\textbf{Remember the Onion}: You have discussed in the Introduction, that you should always remember the onion principle when developing software. If you see the outcome of these last few exercises, you notice that you're failing to follow the principle. We have added much functionality to the driver class that does not reflect what the device itself can do. The {PFTL DAQ} doesn't have a way of linearly increasing an output, and you have achieved that new behavior with a loop in a program. Therefore, the proper way of adding extra functionality would be by adding another layer to the program, as you see in the next chapter.

Before moving forward, it's also important to discuss other libraries that may come in handy. We are not the first ones who try to develop a driver for a device. The pattern of writing and reading, initializing, and many more that you haven't covered, were faced by many developers before ourselves. It means that there are libraries already available that can speed up a lot the development of drivers. Let's see some of them.

\section{Using PyVISA}\label{sec:pyvisa}
Some decades ago, prominent manufacturers of measurement instruments sat together and developed a standard called Virtual instrument software architecture, or VISA for short. This standard allows communicating with devices independently from the communication channel selected, and from the backend chosen. Different companies have developed different backends, such as NI-VISA, or TekVISA, but they \emph{should} be interchangeable. The backends are generally hard to install and do not work on every operating system. But they do allow to switch from a device connected via Serial to a device connected via USB or GPIB without changing the code.

To work with VISA instruments, you can use a library available for Python called \py{pyvisa}. There is also a pure Python implementation of the VISA backend called \mintinline{python}{pyvisa-py}, which is relatively stable even if it's still work in progress. It does not cover 100\% of the VISA standard, but for simple devices like the {PFTL DAQ} it should be more than enough. For complex projects, the solutions provided by vendors such as Tektronix or National Instruments may be more appropriate. In the next few paragraphs, you see how to get started with pyvisa-py, but it's not a requirement of the book. We decided to show it here to have it as a reference for other projects.

First, you need to install \mintinline{python}{pyvisa}, which is a wrapper around the VISA standard. Either with pip:

\begin{minted}{bash}
 pip install pyvisa
\end{minted}

Or with conda:

\begin{minted}{bash}
 conda install -c conda-forge pyvisa
\end{minted}

In case you don't have a VISA backend on our computer, you need to install one, and the easiest is the python implementation:

\begin{minted}{bash}
 pip install pyvisa-py
\end{minted}

or with conda:

\begin{minted}{bash}
 conda install -c conda-forge pyvisa-py
\end{minted}

There is also an interesting dependency missing: PySerial. Neither Pyvisa nor Pyvisa-py depend on PySerial. If you're going to communicate with serial devices, you should install that package ourselves (and the same is true for USB, GPIB, or any other communication standard.) The documentation of pyvisa-py\footnote{https://pyvisa-py.readthedocs.io} has handy information.

To quickly see how to work with PyVISA, you can start in a python interpreter, before going to more complex code. VISA allows you to list your devices:

\begin{minted}{pycon}
 >>> import visa
 >>> rm = visa.ResourceManager('@py')
 >>> rm.list_resources()
 ('ASRL/dev/ttyACM0::INSTR',)
 >>> dev = rm.open_resource('ASRL/dev/ttyACM0::INSTR')
 >>> dev.query('IDN')
 'PFTL DAQ Device built by Python for the Lab v.1.2020\n'
\end{minted}

\sloppy You make explicit the backend you want to use by calling \py{ResourceManger}. In some cases, visa can automatically identify the backend on the computer. Then, you list all the devices connected to the computer. Bear in mind that this depends on the other packages that you installed. For example, you have only PySerial, and therefore pyvisa-py only lists serial devices. We can install PyUSB to work with USB devices, or GPIB, and so forth. The rest of the code is very similar to what you have done before. It becomes clear why you decided to call \emph{resource} the communication with the device.

Pay attention to the \py{query} method that you use to get the serial number from the device. We didn't develop it. PyVISA already took care of defining query for us. Not only PyVISA takes care of the query method, but they have plenty of options that you can use, such as transforming the output according to some rules or establishing the write termination. If you were to follow the pyVISA path, you could start by reading their documentation\footnote{https://pyvisa.readthedocs.io}.

\textbf{Why didn't you start with pyVISA?}. There are several reasons. One is pedagogical. It's better to start with as few dependencies as possible, so you can understand what is going on. You had to understand not only what commands are available, but you also had to be aware of the encoding and line termination. We made explicit the fact that to read from a device, you first have to write something to it. Once you gain confidence with the topics covered in this chapter, you can explore other solutions and alternatives. PyVISA is only the tip of the iceberg.

\section{Introducing Lantz}\label{sec:lantz}
Defining a class for your device was a massive step in terms of usability. You can easily share your code with your colleagues, and they can immediately start using what you have developed with really few extra lines of code. However, there are many features that you may want but that someone needs to develop. For example, imagine that you want to limit the number of times the output voltage can change, or you don't want to write to the device always the same value, the first time was enough.

You may want to establish some limits, for example, to the analog output values. Imagine that you have a device that can handle up to $2.5\,\textrm{V}$. If you set the analog output to $3\,\textrm{V}$, you would burn it. Fortunately, there are some packages written especially to address this kind of problem. We are going to mention only one because it's a project with which you collaborate: Lantz\footnote{https://github.com/lantzproject}. You can install it by running:

\begin{minted}{bash}
pip install lantzdev
\end{minted}

\infoInfo{About Lantz}{We introduce Lantz here for you to see that there's much room for improvement. However, through this book, you're not going to use it, and that is why it was not a requirement when you were setting up the environment. Lantz is under development, and therefore some of the fine-tuned options may not work correctly on different platforms. Using Lantz also shifts a lot of the things you need to understand under-the-hood, and it's not what you want for an introductory course. If you're interested in learning more about Lantz and other packages, you should check for the Advanced Python for the Lab book when you finish with this one.}

Lantz is a Python package that focuses exclusively on instrumentation. We suggest you check their documentation and tutorials since they can be very inspiring. Here you just show you how to write your driver for the {PFTL DAQ} device using Lantz, and how to take advantage of some of its options. Lantz can do much more than what you show you here, but with these basics, you can start in the proper direction. You can also notice that some of the decisions you made earlier were directly inspired by how Lantz works.

Let's first re-write our driver class to make it Lantz-compatible, you start by importing what you need and define some of the constants of our device. You also add a simple method to get the identification of the device. Note that the first import is \py{MessageBasedDriver}, precisely what you have discussed at the beginning of the chapter.

\begin{minted}{python}
from time import sleep

from lantz import MessageBasedDriver, Feat


class MyDevice(MessageBasedDriver):

    DEFAULTS = {'ASRL': {'write_termination': '\n',
                        'read_termination': '\n',
                        'encoding': 'ascii',
                        }}

    @Feat()
    def idn(self):
        return self.query('IDN')


dev = MyDevice.via_serial('/dev/ttyACM0')
dev.initialize()
sleep(1)
print(dev.idn)
\end{minted}

There are several things to point out in this example. First, you have to note that you're importing a special module from Lantz, the \mintinline{python}{MessageBasedDriver}. Our class \mintinline{python}{MyDevice} inherits from the \mintinline{python}{MessageBasedDriver}. There is no \mintinline{python}{__init__} method in the snippet above. The reason for this is that the instantiation of the class is different, as you see later. The first thing you do in the class is to define the \mintinline{python}{DEFAULTS}. At first sight, they look the same as the ones you have defined for our driver. The \mintinline{python}{ASRL} option is for serial devices. In principle, you can specify different defaults for the same device, depending on the connection type. If you were using a {USB} connection, you would have used \py{USB}, or \py{GPIB} instead of, or in addition to \py{ASRL}.

The only method that you have included in the example is \mintinline{python}{idn} because, even if simple, it already shows some of the most interesting capabilities of Lantz. First, you can see that you have used \py{query} instead of \py{write} and \py{read}. Indeed, Lantz depends on pyVISA, so what is happening here is that under the hood, you're using the same command that you saw in the previous section. Bear in mind that Lantz automatically uses the write and read termination.

An extra syntactic thing to note is the \py{@Feat()} before the function. It's a \py{decorator}, one of the most useful ways of systematically altering the behavior of functions without rewriting. Without entering too much into details, a decorator is a function that takes as an argument another function. In Lantz, when using a \py{Feat}, it checks the arguments that you're passing to the method before actually executing it. Another advantage is that you can treat the method as an attribute. For example, you can do something like this \py{print(dev.idn)} instead of \py{print(dev.idn())} as you did in the previous section.

\questionInfo{Exercise}{Write another method for getting the value of an analog input. Remember that the function should take one argument: the channel.}

To read or write to the device, you need to define new methods. If you're stuck with the exercise, you can find inspiration from the example on how to write to an analog output below.

\begin{minted}{python}
output0 = None

[...]

@Feat(limits=(0,4095,1))
def set_output0(self):
    return self.output0

@set_output0.setter
def set_output0(self, value):
    command = "OUT:CH0:{}".format(value)
    self.write(command)
    self.output0 = value
\end{minted}

What you have done may end up being a bit confusing for people working with Lantz and with instrumentation for the first time. When you use \py{Features} in Lantz, you have to split the methods in two: first, a method for getting the value of a feature, and then a method for setting the value. You have to trick Lantz because our device doesn't have a way of knowing the value of an output. When you initialize the class, you create an attribute called \py{output0}, with a \py{None} value. Every time you update the value of the output on channel 0, you're going to store the latest value in this variable.

The first method reads the value, pretty much in the same way than with the \py{idn} method. The main difference here is that you're specifying some limits to the options, exactly as the manual specifies for the {PFTL DAQ} device. The method \py{set_output0} returns the last value that has been set to the channel 0, or \py{None} if it has never been set to a value. The \py{@Feat} in Lantz, forces us to define the first method, also called a \py{getter}. It's the reason why you have to trick Lantz, and you couldn't simply define the \py{setter}. On the other hand, if the setter is not defined, it means that you have a read-only feature, such as with \py{idn}. The second method determines how to set the output and has no return value. The command is very similar to how the driver you developed earlier works. Once you instantiate the class, you can use the two commands like this:

\begin{minted}{python}
print(dev.set_output0)
dev.set_output0 = 500
print(dev.set_output0)
\end{minted}

Even if the programming of the driver is slightly more involved, you can see that the results are clear. A property of the real device also appears as a property of the Python object. Remember that when you execute \py{dev.set_output0 = 500}, you're changing an output in your device. The line looks very innocent, but it isn't. Many things are happening under the hood both in Python and on your device. I encourage you to see what happens if you try to set a value outside of the limits of the device, i.e., try something like \py{dev.set_output0 = 5000}.

The method you developed works only with the analog output 0. It means that if you want to change the value of another channel, wet have to write a new method. It's both unhandy and starts to violate the law of the copy/paste. If you have a device with 64 different outputs, it becomes incredibly complicated to achieve a simple task. Fortunately, Lantz allows us to program such a feature without too much effort:

\begin{minted}{python}
_output = [None, None]

[...]

@DictFeat(keys=[0, 1], limits=(0, 4095, 1))
def output(self, key):
    return self._output[key]

@output.setter
def output(self, key, value):
    self.write(f'OUT:CH{key}:{value}')
    self._output[key] = value
\end{minted}

Because the {PFTL DAQ} device has only two outputs, you initialize a variable \py{output} with only two elements. The main difference here is that you don't use a \py{Feat} but a \py{DicFeat}, which ill take two arguments instead of one: the channel number and the value. The \py{keys} are a list containing all the possible options for the channel. The values, such as before, are the limits of what You can send to the device. The last \py{1} is there just to make it explicit that you take values in steps of 1. We can use the code in this way:

\begin{minted}{python}
dev.output[0] = 500
dev.output[1] = 1000
print(dev.output[0])
print(dev.output[1])
\end{minted}

And now it makes much more sense, and it's cleaner than before. You can also check what happens if you set a value outside of what you have established as limits. The examples above only scratch the surface of what Lantz can do. Sadly, at the moment of writing, the documentation for the latest version of Lantz is missing. The best starting point is the repository with the code: https://github.com/lantzproject.

With the examples above, there's a small step to understand how to solve the following:

\questionInfo{Exercise}{Write a \py{@DictFeat} that reads a value of any given analog input channel.}

\section{Conclusions}\label{sec:conclusions2}
You have covered many details regarding the communication with devices. We have seen how to start writing and reading from a device at a low level, straight from Python packages such as \emph{PySerial}. We have also seen that it's handy to develop classes and not only plain functions or scripts. We have briefly covered pyVISA and Lantz, two Python packages that allow you to build drivers in a systematic, clear, and easy way. The rest of the book doesn't depend on them, but you must know of their existence.

It's impossible in a book to cover all the possible scenarios that you're going to observe over time in the lab. You may have devices that communicate in different ways. You may have devices that are not message-based. The important point, not only in this chapter but also throughout the book, is that once you build a general framework in your mind, it's going to be much easier to find answers online and to adapt others' code.

Remember, documentation is your best friend in the lab. You always have to start by checking the manual of the devices you're using. Sometimes some manufacturers already provide drivers for Python. Such is the case of National Instruments and Basler, but they are not the only ones. Checking the manuals is also crucial because you have to be careful with the limits of your devices. Not only to prevent damages to devices but also because if you employ an instrument outside of the range for which it was designed, you can start generating artifacts in your data. When in doubt, always check the documentation of the packages you are using. PySerial, PyVISA, PyUSB, Lantz, they are quite complex packages, and they have many options. In their documentation pages, you can find a lot of information and examples. Moreover, you can also check how to communicate with the developers because they are very often able to give you a hand with your problems.

\section{Addendum 1: Unicode Encoding}\label{sec:unicode}
You have seen in the previous sections that when you want to send a message to the device, you need to transform a string to binary. This process is called encoding a string. Computers do not understand what a letter is, they just understand binary information, 1s and 0s. It means that if you want to display an \py{a}, or a \py{b}, you need to find a way of converting bytes into a character, or the other way around if you want to do something with that character.

A standard that appeared several years ago is called ASCII. ASCII contemplates transforming 128 different characters to binary. Characters also include punctuation marks such as \py{.}, \py{!}, or \py{:}, and numbers. 128 is not a random number, but it's $2^7$. For the English language, 128 characters are enough. But for languages such as Spanish, which have characters such as \py{}, French with its different accents, and without even mentioning languages that use a non-Latin script, forced the appearance of new standards.

Having more than one \textit{standard} is incompatible with the definition of a standard. Imagine that you write a text in French, using a particular encoding, and then you share it with someone else. That other person does not know which encoding you used and decides to decode it using a Spanish standard. What will the output be? Very hard to know, and probably very hard to read by that person. It's without considering what would happen if someone writes in Thai and shares it with a Japanese, for example.

It still happens with some websites which handle special characters very poorly. Depending on how people configure databases, some characters which do not conform to the English script are just trimmed. This unbearable situation gave rise to a new encoding standard called, as the title of this section suggests: \textbf{Unicode}.

Unicode uses the same definition as ascii for the first 128 characters. It means that any ascii document looks the same if decoded with Unicode. The advantage is that Unicode defines the encoding for millions of extra characters, including all the modern scripts, but also ancient ones such as Egyptian hieroglyphs. Unicode allows people to exchange information without problems.

Thus, when you want to send a command to a device such as the {PFTL DAQ}, you need to determine how to encode it. Most devices work with ASCII values, but since they overlap with the Unicode standard, there's no conflict. Sometimes devices manufactured outside of the US may also use characters beyond the first 128, and thus choosing Unicode over ascii is always an advantage. In Python, if you want to choose how to encode a string, you can do the following:

\begin{minted}{python}
 var = 'This is a string'.encode('ascii')
 var1 = 'This is a string'.encode('utf-8')
 var2 = 'This is a string with a special character '.encode('utf-8')
\end{minted}

Utf-8 is the way of calling the 8-bit Unicode standard. The example above is quite self-explanatory. You may want to check what happens if, on the last line, you change \py{utf-8} by \py{ascii}. You can also see what happens if you decode with \py{ascii} a string encoded as \py{utf-8}.

One of the changes between Python 2 and Python 3 that generated some headaches to unaware developers was the out-of-the-box support for Unicode. In Python 3, you're free to use any utf-8 character not only in strings but also as variable names, while in Python 2, this is not the case. For example, this is valid in Python 3:

\begin{minted}{python}
 var_ = 1
\end{minted}

If you're curious to see how Unicode works, the Wikipedia article is very descriptive. Plus, the Unicode consortium keeps adding new characters based on the input not only from industry leaders but also from individuals. You can see the latest emojis added and notice that some were proposed by local organizations that wanted to have a way of expressing their idiosyncrasies.
