\chapter{Writing the first Model for a Device}\label{writing-the-first-model-for-adevice}

\section{Objectives}
In this chapter, we are going to develop a model for a real device. You are going to start seeing why the Model-View-Controller pattern is so useful. In the previous chapter we discussed that models specify the ways in which the user can interact with devices. The logic of the experiment that we are going to perform is going to manifest in the models that we develop. 

Even if hard to realize at the beginning, most of the development time will be spent working and improving the models. Many controllers can be downloaded, installed, or quickly developed. The view, once developed, is going to stay more or less the same over long periods. Models, on the other hand, is where your true experiment is defined. In the models you are going to decide the order of the steps to perform an experiment, is where you are going to automatize tasks, etc. 

In this chapter we are going to develop a model for the device based on the controller that we wrote on Chapter \ref{chapter:controller}. 

\section{Introduction}
The secret to succesfully develop a model is to think beforehand what do we expect from the device, how are we actually planning to use it. The first time you start thinking about models it can be complicated, because you need to anticipate your future needs. For example, the PFTL DAQ device doesn't handle units. It would be great if the model would allow us to specify the output voltage instead of converting it to an integer because it is what the driver uses. This requirement seems trivial and probably is the first one that comes to mind. Later, once you really start using the program, you will see that some other useful options were missing, and you could have saved a lot of time if you would have thought about them. 

Sadly, there is no magical recipe to teach you exactly how to develop models for your devices. The best we can do is to guide you through the processes of developing a model for the first time. With practice you will get better at it, and you will learn how to anticipate your future needs. It is very important to separate what you expect from the device and what you expect from the experiment as a whole. If you master this technique, you will be able to use the models and controllers for very different purposes, without needing to re-write the entire program. 

In this book we are going to see how to linearly change an analog output while recording an analog input. You know that the ultimate goal is to measure the I-V curve of a diode, but if you would hook the analog output to a piezo stage, you could be doing a scan in a confocal microscope. When the software is well designed, you will have plenty of smaller building blocks that you can keep using in your future projects. You won't need to write and think everything from scratch. Moreover, an improvement because of a new experiment can still benefit the program that controls your previous setup. 

All the predicates in this chapter rely on the fact that you really understand your own experiment before you start coding. Remember that what you are developing in this book is the simplest of the examples. In your own lab, there are going to be several devices, each will have a manual, they are going to be connected to each other. Be sure you understand not only the science behind what you are trying to measure, but also the technical aspects of your setup, its limitations and characteristics. 

\warning{It is impossible to overestimate the importance of reading the manuals of your devices. Hardware in the lab is not the same as consumer hardware. Things can brake, signals may not make sense. Be always sure to understand the limits under which each component operates.}

\section{Base Model}\label{basemodel}
In practical terms, a model for a device is nothing more than a class. Remember that whenever a user is going to interact with the device, it is going to happen through the model and never directly to the controller (i.e. the driver). The first step is to think what methods we are going to need and, if possible, the output that each method is going to produce. If you haven't already, create a folder called \textbf{DAQ} inside the \emph{Model} folder and remember to also add an empty \texttt{\_\_init\_\_.py} file. 

We want all the DAQ models that we develop to have exactly the same methods. If we ever change the PFTL DAQ card for a different one, we would like our experiment to keep running. Therefore, the best strategy is to create a base class. This class will hold all the methods that are going to be used during our experiments. Create a file called \textbf{base.py} inside the DAQ folder, and define a class called \mintinline{python}{DAQBase}:

\begin{minted}{python}
class DAQBase:
    def __init__(self):
        pass
    
    def idn(self):
        pass
    
    def get_analog_value(self, channel):
        pass
    
    def set_analog_value(self, channel, value):
        pass
    
    def finalize(self):
        pass
\end{minted}

This class doesn't do anything by itself, it is only the schematics of what a model should contain. The \mintinline{python}{pass} that was added after every definition takes care of functions in which nothing happens. The step of defining a base class may not seem important at first, but it will become clearer later. The base class defines the common interface for all our devices. We have chosen to implement $5$ methods: An instantiation that will start the comunication with our device. An identification, that will allow us to be sure which device we are communicating with. Two methods for setting and reading an analog channel. Pay attention to the fact that we define also the arguments needed. And lastly, a method to finalize the communication with the device.  

\section{Device Model}\label{devicemodel}
After defining what are the methods that a DAQ model should implement, we can start developing the true model for the {PFTL DAQ}. Let's start by creating a new file called \textbf{analog_daq.py}. You can add the following:

\begin{minted}{python}
from PythonForTheLab.Controller.simple_daq import SimpleDaq 
from PythonForTheLab.Model.daq import DAQBase

class AnalogDaq(DAQBase):
    def __init__(self, port):
        self.port = port
\end{minted}

First, you have to notice that we are using absolute imports. We start with \mint{python}|from PythonForTheLab.Controller.simple_daq import SimpleDaq |, wich means that it is important that you added the root folder of your project to the PYTHONPATH as we discussed in the previous chapter. The \mintinline{python}{AnalogDaq} class inherits the \mintinline{python}{DAQBase} class, meaning that all the methods defined in it are going to be available in the new class. You can see this by running the following code:

\begin{minted}{python}
 from analog_daq import AnalogDaq
 daq = AnalogDaq('/dev/ttyACM0')
 print(daq.port)
 # /dev/ttyACM0
 daq.idn()
 # Nothing will happen, but it doesn't give an error
\end{minted}

The snippet above shows you that even if \mintinline{python}{AnalogDaq} doesn't define any methods besides \mintinline{python}{__init__}, you can use \mintinline{python}{daq.idn()} and it won't give you an error. This is happening, because when you inherit the \texttt{DAQBase} class, the methods defined in it are readily available in the child class. 

Note, however, that the \mintinline{python}{__init__} method takes \texttt{port} as an argument, while the DAQBase doesn't. In order to be consistent, you should modify DAQBase to reflect this need. Remember that the base and the model should always be synchronized, even if lazyness dictates the contrary. 

\exercise{Change \texttt{DAQBase} in order to have an \texttt{\_\_init\_\_} method that takes the port as an argument}

To make our class actually do something, we need to add more code. For example, we need to start communicating with the device on the specified port. Let's assume that we want to start the communication right away, when the class gets instantiated. We can do the following:

\begin{minted}{python}
class AnalogDaq(DAQBase):
    def __init__(self, port):
        super().__init__()
        self.port = port
        self.driver = SimpleDaq(self.port)
        self.driver.initialize()
\end{minted}

You can see that in the \mintinline{python}{__init__} method, we are instantiating the SimpleDaq with the specified port. You store the
object in an attribute called \mintinline{python}{driver}. The driver is going to handle all the communication with the device. Remember that the {MVC} pattern imposes that the user will never communicate with the device directly, but always through the model. If there is something that the device can do but the model can't, you should expand your model before bypassing it. Remember that when we developed the driver, we split the creation of the class and the beginning of the communication. 

\exercise{Add the \texttt{idn} method to your model in order to return the serial number from the device.}

The next step would be to be able to read a value from the device. We could add the following to the \texttt{AnalogDaq} model:

\begin{minted}{python}
def get_analog_value(self, port):
   value = self.driver.get_analog_value(port)
   return value
\end{minted}

Having a \emph{model} as a relay for methods defined in the \emph{controller} doesn't look too useful. So far, both the \texttt{idn} and \texttt{get_analog_value} methods do \emph{exactly} the same as the methods in the driver. However, this is exactly the point where things start to get interesting. The controller returns values that are simply integers, but at the beginning of the chapter we said that we wanted to interact with the device in volts, including the values being read. 

If you go through the manual of the {PFTL DAQ}, you will see that 

\exercise{Complete the \mintinline{python}{get_analog_value} by setting the proper units to the
returned value. Don't forget to use Pint.}

\exercise{Overwrite the method \mintinline{python}{set_analog_value} from the base class to
actually communicate with the device. Use units! Think about the limits,
and what happens if a user sends a plain number instead of a
\emph{Quantity}}

After you have defined the methods, you can test that everything is
working. You can write a simple script that initializes the
communication with the device, sends some outputs and reads some inputs.
Create a file called \textbf{test\_daq.py} and write something like the
code below:

\begin{minted}{python}
import numpy as np
import pint

from analog_daq import AnalogDaq

ur = pint.UnitRegistry()
V = ur('V')

daq = AnalogDaq('/dev/ttyACM0') # <-- Remember to change the port
daq.initialize()
print('The DAQ serial number is {}'.format(daq.idn()))

# 20 Values with units in a numpy array
volt_range = np.linspace(0, 3, 20) * V 
current = [] # Empty list to store the values

for volt in volt_range:
    daq.set_analog_value(0, volt)
    current.append(daq.get_analog_value(0))

print(current)
\end{minted}

At this stage, you should be able to go through the code yourself. It is
not very handy because if you need to change which port you are using
you need to go through the code, or if the device is connected to a
different port. However, you can see that it is very simple to perform a
measurement. If you would be working with a confocal microscope, you
could have done basically the same. Probably you have noticed that when
you try to get the serial number of your device nothing happens. This is
because you didn't define an \mintinline{python}{idn()} method in your class, but it
is important to point out that there were no errors because the method
exists in the class, inherited from the base.

\exercise{Fix the \mintinline{python}{idn()} method to display the correct information.}


\section{Adding Units to the code}\label{adding-units-to-thecode}

There is one great example of why using the proper units is important: a
multi-million satellite fell from its orbit because of a mix up of
\href{http://articles.latimes.com/1999/oct/01/news/mn-17288}{metric and
imperial units}. Fortunately, there is a Python package called
\emph{Pint}, that allows you to work with units. By using \emph{Pint},
you will be adding a new type of variable called a \texttt{Quantity},
which is a combination of a number and a unit. \emph{Pint} has a lot of
options that you should explore yourself by reading their documentation.
We are going to point out some of the more important ones that can be
useful for your developments.

\begin{minted}{pycon}
>>> import pint

>>> ur = pint.UnitRegistry()
>>> meter = ur('meter')
>>> b = 5*meter
>>> print(b)
5 meter
>>> c = b.to('inch')
>>> print(c)
196.8503937007874 inch
\end{minted}

In the example above, you can already grasp the potential of
\emph{Pint}. First, you import the package and start the \emph{Unit
Registry}. In principle, Pint allows you to work with custom-made units,
but the fundamental ones are already included in their \emph{Unit
Registry}. Then, because of convenience, we define the variable
\texttt{meter}, as actually the unit meter. Finally, we assigned the
value \texttt{5\ meters} to a variable \texttt{b}. Remember that
\texttt{b} is a \texttt{Quantity}, therefore it is not just a number,
but a number and a unit attached to it. \emph{Pint} allows you to
convert between units, and this is how we create the variable
\texttt{c}, which is 5 meters converted to inches. But this is not all,
look at the following example:

\begin{minted}{pycon}
>>> d = c*b
>>> print(d.to('m**2'))
25.0 meter ** 2
>>> print(d.to('in**2'))
38750.07750015501 inch ** 2
>>> t = 2.5*ur('s')
>>> v = c/t
>>> print(v.to('in/s'))
78.74015748031496 inch / second
\end{minted}

You can see in the example above that \emph{Pint} can handle complex
units such as speed, current, etc. You can operate on them as you would
with pen and paper, and you can convert from one to another very easily.
Converting from one unit to another will become very handy later on when
you want to pass a value to your device, and you want to be sure that
the value you are passing has the proper units. An important feature
that you may also need at some point is to get the number associated
with a \emph{Quantity}, without the units:

\begin{minted}{pycon}
>>> current = 5*ur('A')
>>> res = 10*ur('ohm')
>>> voltage = current*res
>>> print(voltage)
50 ampere * ohm
>>> print(voltage.to('V'))
50.0 volt
>>> print(voltage.m_as('mV'))
50000.0
\end{minted}

\exercise{In the device driver that you have developed, change the way you 
return
the value of an analog input to include its units. You will have to
transform from integers to the real voltage.}

\exercise{Change the way you handle the setting of an analog output in order to
account for real-world units.}

\section{Dummy DAQ}\label{dummy-daq}
You have just seen how to develop a model for a device such as the
{PFTL} {DAQ}. However, when you develop software for the lab, sometimes
you would like to test your program without having the real device
connected to the computer. It can be a safety precaution or simply
because you are not working on the lab computer. To achieve this, you
can define a fake model that generates data without interacting with a
device. You can call these devices whatever you like, in this case, we
use \textbf{dummy}. The code will look like this:

\begin{minted}{python}
from .base import DAQBase

class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    
    def __init__(self):
        super().__init__()
\end{minted}

You start by importing the base class \mintinline{python}{DAQBase}, as you did for
the real \emph{model}, but you don't need the controller since you are
not going to communicate with any device. The class defines a fake
serial, just to be able to return it as if it was the real device. Now
you have to think what do you actually expect from a fake device. Since
you are developing a dummy {DAQ}, you don't need to do anything when
setting a value to an output, but you do need to get a value when you
read back. And you need to use the proper units as well. It can look
something like this:

\begin{minted}{python}
import numpy as np
import pint

from .base import DAQBase

ur = pint.UnitRegistry()
V = ur('V')

class DummyDaq(DAQBase):
    serial_number = '1234ABC'
    
    def __init__(self):
        super().__init__()
    
    def idn(self):
        return self.serial_number
    
    def get_analog_value(self, port):
        return np.random.random(1)*V
\end{minted}

The \mintinline{python}{idn} is quite clear, it just returns the serial number that
was defined during initialization. The \mintinline{python}{get_analog_value}
accepts a port as a parameter, even if they don't use it, but you need
to keep the compatibility with what was already defined. The value that
is returned is a random number with volts as units. Remember that the
random generator outputs values only between 0 and 1. You can try to run
the test, but using this DummyClass instead. Open the file
\textbf{test\_daq.py}, and replace the line:

\begin{minted}{python}
# from analog_daq import AnalogDaq
from dummy_daq import DummyDaq as AnalogDaq
\end{minted}

And run \textbf{test\_daq.py}. You will see that an error appears
because you are using the \mintinline{python}{initialize} method in the test, but it
is not defined within the class. This happened because you included
\mintinline{python}{initialize} in the
\mintinline{python}{AnalogDaq} but you never added it to the DAQBase.
Now you see the power that being organized and systematic has. Keeping
track of the methods in a general, base class, allows you not to make
the same mistakes. Moreover, it would have allowed you to run the test
without issues.

\exercise{Add an \mintinline{python}{initialize} method into the base class.}

If you run the test after completing the exercise, you will see that
there are no errors appearing, even if you don't modify the dummy class.
Now you see that you can exchange the models in a relatively simple way,
and the script that is responsible for measuring works without problems.
Of course, this is a simple example, where you exchange a real device
for a dummy one, but if you would have two different devices, exchanging
them would have been just as simple and the measurement would have
been performed.

\exercise{Make the \mintinline{python}{get_analog_value} return the value of a sine function
and not just a random value.}

\section{Conclusions}\label{conclusions}
This chapter is focused on showing you what does \emph{Model} mean in
the {MVC} pattern when developing software for the lab. Of course, the
examples proposed in this book are very simple and sometimes the gain is
not going to be apparent. However, as soon as you start building more
complex applications, you will see the benefits of splitting the Model
from the Controller, and later on, the View from the Model.

You have built three classes, a base class that helps you keep track of
the methods and properties that each device is going to have. Keeping
this class up to date and clean is very useful because it allows you and
other developers to have a clear starting point. You have seen that by
skipping some steps you run into errors, that at this moment are easy to
debug and solve, but later they may become more obscure, depending on
what triggered them.

In this chapter, you have also started to use more complex options of
classes in Python. Hopefully, you can understand what is going on and
learn from the examples. Once you see the potential that defining
classes have, you will never stop thinking about them. This has also
been a chapter where you had to code a lot yourself, making your own
decisions. If you ever get lost or think that you are departing too much
from what we are asking, you can always check the GitHub repository of
the book, where you can find the code for every chapter.
