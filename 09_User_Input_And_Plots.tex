\chapter{User Input and Designing}\label{ch:user-input-designer}


\section{Introducion}\label{sec:user-input-introduction}
We started building a GUI by programming every aspect of the interface. We built a \texttt{MainWindow} class, added some buttons and a plot. A logical next step would be to add a way to change the parameters that build up the scan. We would like to be able to change the \texttt{start}, \texttt{stop}, and \texttt{num\_points} values directly from the user interface and not from a config file that gets read only at the beginning.

We could continue adding elements to the program as we did in the previous chapter, but that is time consuming. In this chapter we are going to introduce a program called \textbf{Qt Designer}, that is targeted precisely at speeding up the design of user interfaces. We will see not only how to make the program better looking, we are also going to see what happens when we let users input data, what problems may arise, and we will leave show the way for keep improving based on what we will achieve by the end of the chapter.

\section{Getting Started with Qt Designer}\label{sec:getting-started-with-qt-designer}
We explained how to install Qt Designer in Section~\ref{sec:install-qt-designer}. Different operating systems and different Python versions will have a slightly different way of opening the program.

If you are using \textbf{Anaconda on Windows} you only have to open the start menu and type \textit{Designer}, press \texttt{}enter once it finds it. \textbf{Anaconda on Linux} is similar, open a terminal, either from the base environment or the environment used for this book, type \texttt{designer}, press enter and a window should open.

If you are using \textbf{plain Python on Windows}, and you installed \texttt{pyqt5-tools}, you only need to start the \emph{Command Prompt}, activate the environment where you work, type \texttt{designer.exe}, and press enter. If you are using \textbf{plain Python on Linux}, you installed the designer as part of the package \texttt{qttools5-dev-tools}. In this case the designer is an actual application that you can find within the installed apps in your distribution.

Designer will welcome us with a screen like the one below. In between the template/forms options we can already see two familiar options: Widget and Main Window.

\begin{center}
    \includegraphics[width=.5\textwidth]{images/Chapter_09/01_Designer_Welcome.png}
\end{center}

We will start by recreating the window we developed in the previous chapter. We start by selecting \textbf{Main Window} and clicking create. The Designer opens the working area with an empty main window. That space will be our canvas to start adding elements. In the previous chapter, we created a central widget explicitly. The Designer already did this for us, we can see it on the object inspector at the right sidebar:

\begin{center}
    \includegraphics[width=.5\textwidth]{images/Chapter_09/02_central_widget.png}
\end{center}

Note that the Designer named the central widget \texttt{centralWidget} instead of \texttt{central\_widget}. Naming classes, variables, methods and functions is completely free in Python, but there are some conventions that make code easier to understand at first sight. One is naming classes with the Camel Case convention, such as \texttt{MainWindow}, and attributes in lower-case with words separated by underscores. We can change the name of the central widget by clicking on it and changing the \texttt{objectName} name property:

\begin{center}
    \includegraphics[width=.5\textwidth]{images/Chapter_09/03_central_widget_name.png}
\end{center}

Now we have the central widget with the same name we used in our Python class. We can add the buttons widget by dragging and dropping an empty widget to the window, that can be found in the containers group of elements. After we add the widget, we can also see it appears in the object inspector on the right sidebar. We can change its name to \texttt{button\_widgets}.

\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/04_empty_widget.png}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/04_empty_widget_structure.png}
\end{minipage}

To add the start and stop buttons, we can just drag and drop two \texttt{QPushButton}s to the window. We have to be sure we drop them inside the buttons widget we created earlier. To change the text that appears on the button, we can double click on it and edit the text. We can make one button with the text \emph{Start}, and the other with the text \emph{Stop}. The text on the button is not the name of it. We must change the name of the buttons and to repeat the same structure of the previous chapter we are going to call them \texttt{start\_button} and \texttt{stop\_button}. The window and the structure should look like this:

\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/05_main_window_buttons.png}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/05_main_window_structure.png}
\end{minipage}

\note{Explaining how to use a designing program through screen captures requires a lot of patience from the reader. We try to highlight the checkpoints that allow to compare what the reader does with what is expected to have. Practice with a critical view is the best that can be done at this stage.}

We have a window with the buttons, but we are missing the layout to make it look as good as we had in the previous chapter. The Designer has a toolbar dedicated exclusively to the layouts, you can find it at the top of the main window space, it looks like this:

\begin{center}
    \includegraphics[width=.4\textwidth]{images/Chapter_09/06_layouts.png}
\end{center}

To apply a layout to a widget, we can click first on the widget inside the Object Inspector, and then click on the desired layout. We can apply a vertical layout to the \texttt{central\_widget} and a horizontal layout to the \texttt{button\_widgets}. When we apply a layout to widgets, this will be reflected as a different icon on the Object Inspector.

\begin{center}
    \includegraphics[width=.4\textwidth]{images/Chapter_09/07_widgets_with_layouts.png}
\end{center}

We are ready to save the window. Let's create a new folder called \textbf{GUI} inside the \emph{View} folder, and we can call the file \texttt{main\_window.ui}. Once we save the designer file, we are ready to go back to Python to use this window. We can go back to \textbf{main\_window.py}, and we can start editing the \texttt{MainWindow} class. Since some of the elements are now defined directly on the designer file, we will remove them from the class:

%! Suppress = Ellipsis
\begin{minted}{python}
    import os
    from PyQt5 import uic
    [...]

    class MainWindow(QMainWindow):
        def __init__(self, experiment=None):
            super().__init__()

            base_dir = os.path.dirname(os.path.abspath(__file__))
            ui_file = os.path.join(base_dir, 'GUI', 'main_window.ui')
            uic.loadUi(ui_file, self)

            self.experiment = experiment

            self.plot_widget = pg.PlotWidget()
            self.plot = self.plot_widget.plot([0], [0])
            layout = self.central_widget.layout()
            layout.addWidget(self.plot_widget)
    [...]
\end{minted}

Besides the new imports, the fundamental change to the \texttt{MainWindow} class is that we load the file using \texttt{uic.loadUi}. When we try to import files in Python, we always have to be careful with determining the path from which we are importing. We already encountered the syntax of \texttt{dirname} when we were adding the root folder to the path in Section~\ref{sec:appending-path}. The idea is the same, but we are interested in the folder where the current Python file is located.

The command \texttt{uic.loadUi} takes two arguments, the first is the file we want to load and the second the object to which it will be applied. We use the \texttt{self} to indicate that we want the layout to be applied to the entire \texttt{MainWindow}. If we develop a more modular program, such as defining individual widgets, we could apply the Designer file just to the widget we are interested in.

The rest of the window stays the same, we only removed the definition of \texttt{central\_widget} and the buttons. Since we have the layout of the central widget specified in the designer, we need to access it to be able to append the plot widget. This is what this line is doing:

\mint{python}{layout = self.central_widget.layout()}

We can go ahead and run the program and we will see that the window appears as it did before, without changes, even though we are now pulling the elements from the Designer file.

\subsection{Compiling or not Compiling ui files}\label{subsec:compiling-or-not-compiling-ui-files}
Most tutorials online add one step after creating the Designer's file. They normally suggest transforming the \texttt{.ui} files into a \texttt{.py} file. There is a program able to do it for us, that can be triggered from the command line:

\begin{minted}{bash}
    pyuic5 main_window.ui -o compiled_window.py
\end{minted}

We can explore both files and see the differences. If we open the \emph{ui} file with a text editor we will find out it is plain text and formatted following a standard called \emph{XML}, or extended markup language. This format is very similar to how websites are built, \emph{HTML} stands for hypter text markup language. Going through the file, we will find the place where we defined the buttons, surrounded by some more information, such as the layout, and the text of the button.

If we open the generated Python file, we will find exactly the same information, but formatted in the same way we have done it in the previous chapter. We can go to the declaration of the start button and we will find a line almost identical to the one we used in the previous chapter

\mint{python}{self.start_button = QtWidgets.QPushButton(self.button_widget)}

The question is whether we \textbf{need} to compile the \emph{ui} files to Python files or not. Qt was developed with C++ programmers in mind, and for a C++ program it is very important to have each variable defined, with a specific type before compiling the code. Qt offers a program, \texttt{uic} to transform \emph{ui} files to \emph{C++} compatible files. Most Python tutorials built on that experience and kept the recommendation. But for Python this step is not necessary at all.

There is one caveat, though. If we don't transform the file to a Python file, editors won't be able to know which attributes are available on the windows and widgets. The editor won't have any idea whether there is a \texttt{start\_button} or not defined. This means that to be sure, we should keep opening the designer program and see how we named the buttons and elements. But this is the only drawback that non-compiling has.

In our experience, being able to modify the designer files and see the changes as soon as we restart the program outweights the problems of not being able to auto-complete. If we are systematic with the naming conventions, we won't face many issues. And if we do encounter issues with attributes not defined, we know that the root of the problem is probably that we used one name in the Designer and a different one in Python.

\section{Adding User Input}\label{sec:adding-user-input}
\begin{center}
    \includegraphics[width=.5\textwidth]{images/Chapter_09/08_final_window_example.png}
\end{center}

It is time to bring our program to the next level, by adding the possibility of entering the values of the scan before triggering it. The goal is to have a window that looks like the image above. We structured the window in three rows, one for selecting the range of the scan and the channel, one for the input and delay between points and finally the buttons. Below it, we will append the plot, as we have done before.

First, we will start by designing the window. We will not cover every single detail as we did in the previous section, because it would become too cumbersome to follow, therefore we leave to the discretion of the reader whether they want to try it by themselves, or get the designer file from the online repository. The easiest way to reproduce the window is by looking at the structure we should obtain after placing all the elements:

\begin{center}
    \includegraphics[width=.5\textwidth]{images/Chapter_09/09_final_window_structure.png}
\end{center}

The central widget and the buttons are there, as always, bu we added two more widgets now, they are of a special type called \texttt{QGroupBox}, meant exactly for grouping elements together. They also have a title, that appear at the top left, and become very handy to quickly understand what needs to be edited. To handle input from the user, we chose \texttt{QLineEdit} widgets. These widgets allow the user to input any type of text, exactly as we need.

The rest of the elements are to give consistency to the user experience. Before each line edit, we included a label, to show what information is supposed to go in each box. In the bottom group, we also used a \texttt{Spacer}, to push the elements to the left. If we don't do this, the boxes for editing would take the entire space and wouldn't look nice. It is, however, a purely aesthetic decision.

The most important thing to pay attention are the names of each input line, because they are going to be fundamental for the Python code. What we normally use is a distinctive name followed by the type of element we are dealing with. That is why have the \texttt{start\_button}, but also the \texttt{stop\_line}, \texttt{delay\_label}, etc. In this way we can avoid confusion between the starting value of the scan and the button that is supposed to trigger it.

\warning{Consistency with the names is very important. An incredibly common bug is to change the names and then use the wrong value for the experiment. If we were to swap the in and out channels, the error may go unnoticed until we use two different values. By that point, it will be very hard to understand if the problem is within the program or within the experiment.}

After improving the window design, we can run again the program and we will see that the window has a different aspect, with inputs, labels and groups. However, they can't do much yet. If we trigger a scan, the plot will update, but it will always be with the values set in the config file. First, let's learn how to populate the different elements with the values we start when we load the config file. We must edit the \texttt{\_\_init\_\_} of the \texttt{MainWindow} class to take care of the values:

\begin{minted}{python}
    self.start_line.setText(self.experiment.config['Scan']['start'])
    self.stop_line.setText(self.experiment.config['Scan']['stop'])
    self.num_steps_line.setText(str(self.experiment.config['Scan']['num_steps']))
\end{minted}

The \texttt{QLineEdit} objects have a method called \texttt{setText} that allows us to change what is displayed. For the start and stop values there are no problems, because their values are already strings (remember they include the units), but the number of steps is an integer. PyQt is a very thin wrapper and won't try to convert a number to a string, we need to force it ourselves, adding the \texttt{str} function.

\exercise{We have shown how to add the values of start, stop, and number of steps, but we are still missing the input and output channels, and the delay between points. Add them following the example above.}

We know how to set the values to the lines, we can change them, but the we still use the ones defined in the config file. We already saw in Section~\ref{sec:running-experiment} that thanks to our strategy of having a robust experiment class, we can change the values of the parameters after the experiment was defined. We can do the same within the user interface. Let's improve the \texttt{start\_scan} method of the \texttt{MainWindow}:

\begin{minted}{python}
    def start_scan(self):
        start = self.start_line.text()
        stop = self.stop_line.text()
        num_steps = int(self.num_steps_line.text())

        self.experiment.config['Scan'].update(
            {'start': start,
             'stop': stop,
             'num_steps': num_steps}
        )
        self.experiment.start_scan()
\end{minted}

In exactly the same way we used \texttt{setText} to set the text on the QLineEdit objects, we can use \texttt{text()} to retrieve what is written. For start and stop there are no problems, but for the number of steps we need to have an integer, not a string. Once we got the values, we update the \texttt{experiment.config}, specifically the group of properties that belong to \texttt{Scan}. Using \texttt{update} on a dictionary is a shorter way of doing:

\begin{minted}{python}
    self.experiment.config['Scan']['start'] = start
    self.experiment.config['Scan']['stop'] = stop
    self.experiment.config['Scan']['num_steps'] = num_steps
\end{minted}

It is important to remember that in the experiment, when we trigger the \texttt{start\_scan}, the model will take care of creating the scan range directly from the values stored in the config dictionary. If we supply values without units, the experiment will complain.

\exercise{Test the limits of the user interface. What happens if you use a number of steps that is not an integer? What happens if you submit a start or stop value in units other than Volts? What happens if you leave one of the options empty?}

\exercise{Following the example above, add the same behavior for the delay, channel in and channel out values.}

We are now at a stage where we can control our experiment from the user interface. We can change the parameters for the scan, start and stop at will. At this stage we should feel very proud of ourselves. It is also a good time to reflect, because things change very quickly, new elements appear on the window but we put very little effort in making everything work together.

One of the values of separating in Model/View/Controller is that, normally, most of our work should be placed in the models. And models are the most pure-python modules in our program. Once we overcome the initial shock of working with more complex patterns, such as classes and threads, the rest is very straightforward. We loop through values, we save data. Most likely it is the kind of things we were already doing when analysing data.

Once the experiment model is ready, plugging the view on top of it does not require too much effort. How to design the experiment model in such a way that allows us such degree of independence, is a skill that can be acquired over time, with critical thinking, and patience. For most programs, when developing the \emph{View}, we would face the problem of something missing in the experiment model. Perhaps a threashold value, or a variable that let's us know something is running. We should always refrain the temptation of complicating the view and we should always favor putting all that effort into the models.

It's only the long run experience the one that will congratulate us on a job well done in the past.

\section{Validating User Input}\label{sec:validating-user-input}
We, as consumers of computer software, are used to a lot of interactions and visual cues when working with a user interface. This makes us expect the same kind of behavior in the programs we develop ourselves. One of the things we can notice in our program is that if we try to trigger a scan while the first one is running, a message will be printed to the terminal, but if we are not paying attention to it, we will miss it and wonder why the scan is not being triggered.

One possible solution would be to gray out the \emph{Start} button, to prevent the user from triggering a second scan. The question is how can we achieve that behavior. If we look in the designer, every widget that we add has a list of properties that we can change, including shape, color, text, etc. In the case of the buttons, there is an option called \texttt{enabled}:

\begin{center}
    \includegraphics[width=.4\linewidth]{images/Chapter_09/10_enabled_button.png}
\end{center}

If we remove the tick mark from the option, the button gets grayed out, and we won't be able to click it. We must learn how to change the enabled status from our program, not from the Designer. For this, we must read the documentation provided by Qt. If we search online for \texttt{QPushButton}, normally the first result would be the one available at \texttt{doc.qt.io}, the official documentation. We only need to be sure we are looking at the Qt5 documentation and not at the Qt4. The page is long and if we look for \texttt{enabled} we won't find anything. This is not a very auspicious start.

If we scroll to the top of the page, we will see that Qt informs us the parent class of QPushButton: QAbstractButton. Remember that when working with objects, there is always a possibility that methods and attributes are defined in the parent class, not in the class we are actually using. We can follow the link, but there won't be any information on enabling or not, but if we go one level above, to the \texttt{QWidget} documentation, we find what we were looking for:

\begin{center}
    \includegraphics[width=.4\linewidth]{images/Chapter_09/11_Qt_Docs_inheritance.png}
\end{center}

To change the status of the button, we must use the \texttt{setEnabled()} method that is defined in the base \texttt{QWidget} class. On the one hand, we can notice that all widgets can be enabled or disabled. In some cases the change will be visible, in others it won't be. We can also see that the Designer was already letting us know that the documentation was available as part of QWidget instead of QPushButton, just look at how properties are organized:

\begin{center}
    \includegraphics[width=.4\linewidth]{images/Chapter_09/12_Designer_object_inheritance.png}
\end{center}

Next time we want to learn how to do something, we know the best is to start by the designer and see if the options are available. If we find it, we must pay attention to the base class that defines the behavior and then we can go looking for the documentation. Navigating the Qt Docs takes a bit of getting used to, but once we understand how the information is organized, it becomes very easy to follow it.

Back to the task at hand, we must disable the button when the scan starts running. One option would be to disable it right when we trigger the scan:

%! Suppress = Ellipsis
\begin{minted}{python}
    def start_scan(self):
        self.start_button.setEnabled(False)
        [...]
\end{minted}

This seems like a very valid idea until we use it for the first time. Once the scan starts, the button will be grayed out, but there is no place where the button can be enabled back. This is a very common pattern with user interfaces. There are different ways of tackle the problem, but the more straightforward one is using the timer we already have in place to update the plot.

Instead of just plotting data, we can use the same timer to update the different elements of the user interface. For example, we would like to let the user start the scan only if there is no scan running, and we want to let them stop the scan only if there is one scan running. Let's start by defining a new method in the main window:

\begin{minted}{python}
    def update_gui(self):
        if self.experiment.is_running:
            self.start_button.setEnabled(False)
            self.stop_button.setEnabled(True)
        else:
            self.start_button.setEnabled(True)
            self.stop_button.setEnabled(True)
\end{minted}

The method \texttt{update\_gui} is easy to follow, if the scan is running we gray out one button but not the other and viceversa. We only need to be sure this method is run periodically. Since we already have a timer for updating the plot, we can use it to update the GUI as well:

\begin{minted}{python}
    def __init__(self, experiment=None):
        self.timer.timeout.connect(self.update_gui)
\end{minted}

With this simple approach, we will be checking every few milliseconds whether the scan is running or not, and we will set the buttons accordingly. There is also a risk with this approach. If we decide to show information on the Main Window that implies reading a value from the device, we will be polling it several times per second, regardless of whether the value changed or not. If we update values stored in an object, such as the Experiment model, there is nothing to loose, but if we stretch this pattern too far, we may encounter issues and our program could become inefficient.

We have generated the most basic of the possibilities, disabling a button to prevent the user from triggering a second scan if there is one already running. There are many more possibilities. What happens if, for example, the user enters a value outside the range of possibilities, such as a start without volts, or negative, or beyond $3.3\,\textrm{V}$. We can use the \texttt{update\_gui} to monitor the values entered and run them through some checks. If they pass, then we leave them as they are, if they don't then we change the line to red and disable the start button.

All these are possibilities that we will start considering as soon as we start developing user interfaces. However, every thing we do has ramifications, such as what we saw when we disabled the start button on our first attempt. Our general approach is not to complicate the user interface beyond what is needed. If we have proper drivers and proper models in place, at least our devices are safe. If we find ourselves or a user of our software making the same mistakes over and over again, we can then optimize the flow to prevent it from happening again.

\subsection{Saving Data with a Shortcut}\label{subsec:saving-data-with-a-shortcut}
The only missing important feature of our user interface is the ability to save data. We could implement a button for this, but we can also look into another important feature of Qt: \textbf{actions}. We saw that a central tool when developing with Qt are signals, such as the ones emitted by a button, a timer, etc. Signals are associated with widgets of some sort. There is another range which are not associated with widgets, but that can be triggered at the user command.

In the Designer, we can add a \texttt{File} menu, by double clicking the top bar of the main window, where it says \texttt{Type Here}, and inside the File menu, we can create a \texttt{Save} option. As soon as we create the Save, the Designer will also show an \emph{Action} defined. We can find the action listed at the bottom of the right sidebar, as we show on the image below. Note that the name assigned by default is \texttt{actionSave}.

\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/13_menu_file.png}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}{0.45\linewidth}
    \centering
    \includegraphics[width=\textwidth]{images/Chapter_09/13_action_save.png}
\end{minipage}

If we pay attention to what appears on that square, we see that there is also the possibility of defining a shortcut. We can go ahead, double-cliking on it will open a small configuration window in which we can add a shortcut, such as Ctrl+S. Just clicking on the shortcut edit line and then pressing a combination of keys will do it. After saving, we can run the program again and we will have a File menu with a Save option, and the shortcut will be written next to it, so there are no possible confusions.

We need to connect the \texttt{actionSave} to the method in our experiment for saving data. Because of how we structured the code, this now becomes almost trivial, in the \texttt{\_\_init\_\_} of the \texttt{MainWindow} we just add the following:

\mint{python}{self.actionSave.triggered.connect(self.experiment.save_data)}

We can use signals to trigger methods in other objects, not only in the window itself. When the experiment gets more complex, it can be very helpful to just trigger the model to do something than first defining a method on the window to then trigger the model. If we run the program again, we can save the data either by going to File/Save, or by pressing Ctrl+S. Go ahead and check the folder you specified in the config file, and you will see the data appearing there.

\note{Adding shortcuts for actions can be a good idea but it also has risks. Shortcuts are hard to document, and some shortcuts are so common that is better not to re define them. We could have used Ctrl+S to Start the scan. But then, we need to stop it and choose Ctrl+X, because it is right below. To save, we need to choose another shortcut, and choose Ctrl+Q because it is on top of the S. All these shortcuts are normally used for something else, like saving, cutting and closing a window. We are free to use them as we wish, but over usage leads to a perilous path.}

Of course, we may be tempted to open a pop-up dialog to ask for the folder where to save data. But again, this has a complex set of possibilities. If we open a pop-up every time we want to save data, it becomes annoying, especially if we save data often. If we show it only the first time, then we won't be able to change later on, wondering why we showed it on the first place. This means we need to establish two behaviors: \emph{save} and \emph{save as}. We won't show how to do it here, but we will leave it as an exercise:

\exercise{Qt bundles a \texttt{QFileDialog} widget, which allows the user to select a folder in the computer or create a new one. It can be used like this: \py{folder = QFileDialog.getExistingDirectory(self, 'Choose Folder')}. Create a new action in the Designer to select the folder, and a new method in the main window to handle the selection of a directory to save the data.}

\section{Conclusions}\label{sec:conclusions}
This is a chapter of great joy. It is the conclusion of a great journey, from developing a driver, to creating models to abstract the behavior we expect both of the device and of the measurement we want to do, and finally to develop a user interface that works and looks nice.

This chapter focused on learning how to use the Qt Designer, a great tool to speed up the development of user interfaces. We covered the basic tools and patterns that one can expect to find in most user interfaces for scientific experiments. Qt, however, is a massive library that allows to build almost anything, from the interface you see in some Mercedes cars to coffee vending machines, to programs running right now on your computer or mobile phone.

We have merely scratched the surface of what Qt offers. For scientific applications, however, we don't need to go much deeper. We are normally fine with simple styling of the objects and a simple menu structure. We can change font-sizes, colors, roundness of edges. We can make floating menus that open by right clicking on an image, and many more things. But we always have to draw a line between how much effort and time we are dedicating to making a program look better and how much time are we dedicating to running an experiment.

\section{Where to Next}\label{sec:where-to-next}
If you reached this point, it means that you have kickstarted your career as a Scientific Python Developer, hurrah!. What we have covered in this book is only the beginning. Devices can be much more sophisticated than a simple DAQ, the data we display may need to be analysed before plotting, or the memory on our computer may not be enough to hold one complete measurement.

Our advise during the workshops is that you should work on what you have learned for at least 6 months. Trying to develop solutions for the tools you already have at hand, such as an Oscilloscope, or your own data acquisition card. In this book we have guided you, we have prevented you from falling in some errors. The reality is that you won't master any technique until you try by yourself, fail by yourself, and solve a problem by yourself.

In order to accompany you in this process, we have built a forum, available at https://forum.pythonforthelab.com. You can ask any question related to programming, work in the lab, or Python. If you have any comments, suggestions, compliments, critiques to send us, you can do it directly to me, at aquiles@pythonforthelab.com. I always want to read how is your path going, what topics are making you struggle.

If you are interested in a follow-up to this book, covering more advanced topics, please drop me a line. I am always seeking new ideas, topics, challenges, not only to produce content, but to learn myself. I do a periodic braindump of what I learn on the website pythonforthelab.com, but most of the time is not organized as this book is. If some things grab your attention, you can always leave a comment to let us know.
