%! Suppress = Ellipsis
\chapter[Graphical User Interfaces]{Getting Started with Graphical User Interfaces}\label{ch:starting-gui}

\section{Introduction}\label{sec:gui-introduction}
Building a \textbf{Graphical User Interfaces} (or GUI) may seem more complicated than it actually is. Once you learn the fundamentals, you'll see that it's possible for you to put something together very quickly, especially if you already have some code with which to work. In the previous chapter, you saw that you could control an experiment from the command line. It's possible to ask, then, why go through the trouble of creating a user interface? The truth is, Graphical User Interfaces can be very useful for performing such tasks as controlling the parameters of an experiment, monitoring the output in a specially designed window, or even for viewing process in real-time in order to make decisions while the experiment runs.

There are several options for building GUIs with Python, and the community has no clear consensus on which path is the best one to follow. For scientific applications, however, the only library that's powerful enough to achieve what you want to achieve is called \textbf{Qt}. Qt was developed as an application framework that allows developers to build native applications (programs that look like they ``belong'' to the operating system on which they're run), without having to change the code. Qt itself is a Finnish company with a long history. It was part of Nokia for a while, though now they're publicly traded in the Helsinki exchange. This means that Qt is going to be around for a long time!

In this chapter, you're going to see the first steps for building a user interface using Qt, as well as its Python wrapper \emph{PyQt}, which you installed in Chapter~\ref{ch:setting-up}. At Python for the Lab, we've traditionally adopted PyQt, but in the past few years, Qt itself took over a project called PySide, which is another wrapper for Qt. They are both licensed under different open-source terms, and both are excellent. However, the structure of the PySide2 package is different from the PyQt package, so for consistency, this book will keep using PyQt.

\checkInfo{Qt, PyQt, and PySide Licensing}{If you're planning to release commercial software, or if you're packaging Qt, PyQt, or PySide2 into your application, you should explore the different licensing options available.}

\section{Creating a Simple Window and Buttons}\label{sec:simple-window-andbuttons}
Now it's finally time to start using the empty folder from the MVC design pattern: the \textbf{View}. You'll start by learning how to create simple windows directly with Qt, and then proceed to a fully-featured user interface for your experiment. You'll start with scripts and slowly grow your program as it increases in complexity.

The best way to get started with Qt is with a quick example. You can create a new file called \textbf{simple\_window.py} in the \emph{Examples} folder with this code:

\begin{minted}{python}
    from PyQt5.QtWidgets import QApplication, QMainWindow

    app = QApplication([])
    win = QMainWindow()
    win.show()
    app.exec()
\end{minted}

You will come back to the code above over and over again. In the beginning, it may seem hard to remember, but once you write it often enough, it will stick. After the import, you create a \py{QApplication} and a \py{QMainWindow}. Then, you show the window and run the app. This code should produce a very simple window that looks like the image below:

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/01_simple_window.png}
\end{center}

The style will match the operating system of the machine your code is running on. It's a simple, empty window. However, you can already start understanding how Qt works. A user interface is a program that keeps running in a loop. When you click and drag to resize a window, for example, there's always a program responsible for knowing how to do this. In Qt, this never-ending loop is the \py{QApplication}. Whatever window you want to create needs to belong to an application, and that is why the first thing you did was define \py{app}.

In the following line, you define a new object, called \py{win}, which is a \py{QMainWindow}. As the name suggests, the main windows are the core of the user interface. From the main window, you can open dialogs and other windows, but the main window is central to the program. After creating it, you show the window. The last line is where the application loop starts. The \py{app.exec()} command is \textbf{blocking}. This means that nothing that comes after will be executed until you're finished with the user interface.

\questionInfo{Exercise}{To understand a bit better what is going on with the user interface, you're encouraged to try different things. For example, what happens if you don't show the window? If you were to add a few print statements, when would they get executed? You can also try to define the window before the application.}

Having an empty window is not particularly useful, so you can start adding elements to it. First, add a title to the window, like this:

\begin{minted}{python}
    win.setWindowTitle('My First Window')
\end{minted}

Very slowly, the program starts taking shape and looking more professional. You can also add an interactive element, such as a button. You can define one like this:

\begin{minted}{python}
    from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton

    app = QApplication([])
    win = QMainWindow()
    win.setWindowTitle('My First Window')
    button = QPushButton('Press Me', win)
    win.show()
    app.exec()
\end{minted}

This will produce a small window:

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/02_simple_window_and_button.png}
\end{center}

Notice that when you defined the button, you added a second argument, \py{win}. Qt has a hierarchical structure, where each element is called a \emph{widget}. You've imported three widgets so far: the application, the window, and the button. All widgets live inside the application loop, but you have to establish the relationship between them. By passing the window as the second argument, you're explicitly saying that the button belongs to the window.

\questionInfo{Exercise}{Remove the \py{win} from the definition of the button, and see what happens.}
\questionInfo{Exercise}{Alter the order and make the button the parent of the main window. Does this work?}

A big part of working with Qt is finding out how to relate different widgets to each other, or how to position them. \py{QMainWindows} are special because they must hold widgets within them. That's why they specify a method to determine which Widget is the most important for the window (or in Qt jargon, which Widget is the central Widget). You can explicitly declare this:

\begin{minted}{python}
    button = QPushButton('Press Me')
    win.setCentralWidget(button)
\end{minted}

Here, you removed the \py{win} from the declaration of the button, but if it's there it won't change the behavior. The window now looks somewhat different:

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/03_simple_window_and_central_widget.png}
\end{center}

You can try resizing the window, and you'll see that the button scales. By declaring the button as the central Widget of the window, you made the relationship even stronger. The last possibility worth mentioning before moving on is that you can also show the button independently from the window, like this:

\begin{minted}{python}
    win.setWindowTitle('My First Window')
    button = QPushButton('Press Me')
    win.show()
    button.show()
\end{minted}

In this case, the window and the button are two independent components, as shown in the image below. For the program to finish, you must close both the button and the window.

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/04_window_button_separated.png}
\end{center}

Qt offers a great deal of flexibility, but you needn't take advantage of all of it. Having buttons floating around the screen does not sound like a good idea, but it's a possibility in case you ever do need it.

Now that you have a button on a window, it's time to do something with it.

\section{Using Signals and Slots}\label{sec:signals-slots}
Qt offers a programming pattern known as \textbf{Signals and Slots}. The core idea is that different actions on a user interface trigger a \emph{signal}. For example, moving the mouse over an element triggers a signal. This signal is then caught by a \emph{slot}, which does something with the information provided. When you move the mouse over a button (also known as hovering), its background changes color. This is a clear example of the signal/slot paradigm.

Every Widget that you can place on the screen has a myriad of signals, from interactions with the mouse to changes in shape or size triggered by reshaping the window, and even to time-based functionality. This does not mean you need to know them all, or that you'll even use them all. However, once you understand the pattern, you'll know where to go to find what you're after.

This button has one signal called, very eloquently, \py{clicked}. To use it, you must define a function that can be called every time the signal fires. This function is the \emph{slot}. You can expand your example code like this:

%! Suppress = Ellipsis
\begin{minted}{python}
def button_clicked():
    print('Button Clicked')

[...]
button = QPushButton('Press Me')
button.clicked.connect(button_clicked)
win.setCentralWidget(button)
\end{minted}

You can see that every time you click the button, the program prints a message to the screen. It's very important to note that you used \py{button_clicked} and not \py{button_clicked()}. It's the same as what was discussed in Section~\ref{subsec:multithreading} on multithreading. You must use the function itself as a slot, and not the outcome of the function.

\subsection{Starting a scan}\label{subsec:start-scan-gui}
With what you've done so far, triggering a scan from the user interface becomes almost trivial. For the time being, you can keep working in the \emph{Examples} folder, but this time let's create a new file called \textbf{start\_gui.py}. The only functionality you'll need is that when you press the button, a scan starts. You need to mix what you already have in \textbf{run\_experiment.py} with what you've done above. It can look like this:

\begin{minted}{python}
    from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton

    from PythonForTheLab.Model.experiment import Experiment

    experiment = Experiment('experiment.yml')
    experiment.load_config()
    experiment.load_daq()

    app = QApplication([])
    win = QMainWindow()
    win.setWindowTitle('My First Window')
    button = QPushButton('Start Scan')

    button.clicked.connect(experiment.do_scan)

    win.setCentralWidget(button)
    win.show()
    app.exec()

    experiment.finalize()
\end{minted}

The code above is a merge between what you did in the previous chapter and this one. You define the experiment as always, and then you add in the code for the window and button, as you've just learned. However, the line that does all the magic is this one:

\begin{minted}{python}
    button.clicked.connect(experiment.do_scan)
\end{minted}

You can try to run the program. When you click the button, a scan starts. However, there's something else happening. The window freezes, and you're not able to reshape it or even close it. In some cases, especially on Windows, the program may even crash, and you get a message asking whether or not you want to report the issue.

\questionInfo{Exercise}{Can you guess why the window freezes?}

When you saw the description of the flow of a Qt program, you learned about a loop taking care of the interactions within the program. However, if you trigger a scan using \py{do_scan}, you're going to block that loop. Both Qt and Python are single-threaded applications by default, and when one blocks, the other blocks as well. Speaking of which, all this talk about single-threaded applications should give you a hint as to how this problem can be solved.

At the end of the last chapter, you developed a different method called \py{start_scan} that creates a separate thread to hold the scanning, effectively releasing the main thread to do other tasks. You can change just one line of code and achieve a very different behavior:

\begin{minted}{python}
    button.clicked.connect(experiment.start_scan)
\end{minted}

You've developed a somewhat functional program. You have a window with a button from which you can control the experiment. It's already quite an excellent achievement. You also have some extra features out of the box, such as preventing the user from triggering two scans at the same time.

Sometimes, the simplicity of developing this kind of solution misguides readers. It was so easy to achieve what you achieved so far because you spent a lot of time and effort developing a proper \emph{experiment class}. The threading, which checks to prevent two scans from running at the same time, as well as some extra things that will keep appearing in this chapter and the next, are thanks to a well-designed model.

\section{Extending the Main Window}\label{sec:extending-main-window}
You've seen how to get started by creating the main window and adding a button to it. However, you can also start seeing that if you try to add more elements, the code is going to become more and more convoluted. It would be a nice addition if the window you design here could be used for different purposes as well. As you've already seen many times, a good idea when you want to make blocks of code reusable is to convert them into classes. Qt is ideally suited for this because every Widget they provide is an object with a special inheritance tree.

In the folder \emph{View} you can create a file called \textbf{main\_window.py}, and you can add the following code:

\begin{minted}{python}
    from PyQt5.QtWidgets import QMainWindow


    class MainWindow(QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle('My First Window')
\end{minted}

Before discussing what you've done, you can quickly go back to \textbf{start\_gui.py} and change the following two lines of code:

\begin{minted}{python}
    win = QMainWindow()
    win.setWindowTitle('My First Window')
\end{minted}

with this one:

\begin{minted}{python}
    win = MainWindow()
\end{minted}

You should also remember to change the imports at the top of the file by these:

\begin{minted}{python}
    from PyQt5.QtWidgets import QApplication
    from PythonForTheLab.View.main_window import MainWindow
\end{minted}

If you run the code, you see that it behaves as it was behaving previously. In the code, you create a new class called \py{MainWindow}, which in turn inherits from \py{QMainWindow}. It's always important to call \py{super()} because that runs the init method from the QMainWindow itself, setting up all the parameters, signals, properties that you need to generate a window. There is, however, a difference with a plan \py{QMainWindow}, you specify its title. Effectively, you've now extended the pure \py{QMainWindow} class to include a title by default.

\checkInfo{Naming conventions}{It's a personal preference when I start developing a program that has only one main window to name it \py{MainWindow}, removing the preceding \py{Q}. It can lead to mistakes if you overlook the small difference in both names. Depending on taste, an alternative is to call the windows by what they are supposed to do, such as \py{ScanWindow}. It depends on the reader's preferences.}

You can add the button, and the slot, like this:

\begin{minted}{python}
from PyQt5.QtWidgets import QMainWindow, QPushButton


class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent=parent)
        self.setWindowTitle('My First Window')
        self.button = QPushButton('Press Me')
        self.setCentralWidget(self.button)

        self.button.clicked.connect(self.button_clicked)

    def button_clicked(self):
        print('Button Clicked')
\end{minted}

You can test this code again and see that you've recovered what you had before. Every time you press on the button, a message appears on the screen. You can also go one step further and start thinking about how to work with the experiment itself. The window is not aware of any experiments, but you would like to be able to trigger a scan if you press the button. Therefore, the experiment has to come from outside of the class and be stored within.

You've already done something like this. When you developed the driver in Section~\ref{sec:going-higher-level}, you could send the port number to the class through the \py{__init__} method. You did the same for the device model in Section~\ref{sec:device-model}, and for the experiment model in Section~\ref{sec:skeleton-experiment-model}. In all those cases, you were using simple strings, but you're not limited to them. Arguments of methods, or any function for the matter, can be complex objects as well.

You can adapt the \py{MainWindow} to accept an experiment as argument, store it as an attribute and use it when you need to. The code would look like this:

\begin{minted}{python}
    [...]
    class MainWindow(QMainWindow):
        def __init__(self, experiment=None):
            super().__init__()
            self.experiment = experiment

            [...]
        def button_clicked(self):
            self.experiment.start_scan()
            print('Scan Started')
\end{minted}

The changes to the code were minimal but significant. You've included \py{experiment=None} in the init. You've provided a default value for the experiment because this allows us to run the program even if you've no experiment defined. It's useful if you want to test how the window looks like quickly. However, as soon as you press the button, the program crashes. You've to update the \textbf{start\_gui.py} script to accommodate for the changes:

\begin{minted}{python}
experiment = Experiment('experiment.yml')
experiment.load_config()
experiment.load_daq()

app = QApplication([])
window = MainWindow(experiment)
window.show()
app.exec()

experiment.finalize()
\end{minted}

You pass \py{experiment} directly to the window, and it takes care of the rest. You can now safely trigger a scan from the user interface. What is important to note is that once you reach this step, all the rest happens directly on the view. The script that you use to open the window stays unaltered. Even in much more complex programs, you use the same pattern\footnote{See, for example, how PyNTA starts its user interface: https://bit.ly/WindowExperiment}.

\section{Adding Layouts}\label{sec:adding-layouts}
So far, the window holds only one button, and you set that button to be the central Widget of the window. This makes it virtually impossible to add any other button or object. Therefore, it's time to start sophisticating the user interface\footnote{In this chapter you decided to go lower level, programming every feature, but in the next chapter you will see how to do it with the QtDesigner software, which will speed up the process}. The basic building blocks in Qt are \py{QWidgets}, and Qt allows us to place widgets inside of widgets at our will. You also know that Main Windows require a central widget. Therefore, you can create a widget that holds two buttons: start and stop, and that Widget is the central Widget of the window. You use this opportunity to clean up the names you've used, to make them more descriptive as well, it's important to pay attention to all the changes made:

\begin{minted}{python}
from PyQt5.QtWidgets import QMainWindow, QPushButton, QWidget


class MainWindow(QMainWindow):
    def __init__(self, experiment=None):
        super().__init__()
        self.experiment = experiment
        self.setWindowTitle('Scan Window')

        self.button_widgets = QWidget()
        self.start_button = QPushButton('Start', self.button_widgets)
        self.stop_button = QPushButton('Stop', self.button_widgets)

        self.setCentralWidget(self.button_widgets)

        self.start_button.clicked.connect(self.start_scan)

    def start_scan(self):
        self.experiment.start_scan()
        print('Scan Started')
\end{minted}

If you run the program again, you will see a Window like the one below:

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/05_window_without_layout.png}
\end{center}

The stop button is visible, but not the start button. It happens because Qt has no way of knowing where you want to add the buttons and place them in the same position. The one that gets added later is on top.

\questionInfo{Exercise}{Change the order in which you define the buttons and see that one or the other gets on top. If the button that is below has a much longer text, you can see it beneath the top one.}

You could specify explicit coordinates for the positions of the buttons, but there's a much simpler approach using layouts. In Qt, there are 4 basic layout types: Horizontal, Vertical, Grid, and Form. With the first two, each time you add a widget, it's added either below or to the right. With the grid layout, you can control the position, width, and height based on a grid you define. The form defines two columns, ideally to hold some labels and inputs. You see more about layouts in the following chapter. For the time being, if you want to add two buttons, you can choose a horizontal layout. The code of the \py{MainWindow} takes a few extra lines to set everything up properly:

\begin{minted}{python}
from PyQt5.QtWidgets import QHBoxLayout
[...]
self.button_widgets = QWidget()
self.start_button = QPushButton('Start')
self.stop_button = QPushButton('Stop')
layout = QHBoxLayout(self.button_widgets)
layout.addWidget(self.start_button)
layout.addWidget(self.stop_button)

self.setCentralWidget(self.button_widgets)
\end{minted}

In Qt, the horizontal layout is called \py{QHBoxLayout}, and you apply it to the \py{buttons_widget}. Then, you add the start and stop to the layout, instead of directly to the widget. This window will look much better:

\begin{center}
    \includegraphics[width=.3\textwidth]{images/Chapter_08/06_window_with_layout.png}
\end{center}

If you resize it, you see that the buttons take the entire width, and they are always centered. It's already a good improvement compared to the simple window with which you started. Before you finish this section, these two exercises are a good way of practicing the skills acquired so far:

\questionInfo{Exercise}{Change \py{QHBoxLayout} by \py{QVBoxLayout} to see the buttons stacked vertically.}

\questionInfo{Exercise}{Connect the stop button to a method that stops the scan}

\section{Plotting Data}\label{sec:plotting-data}
You finish this section by adding a plot of the data in real-time. You already did something similar in Section~\ref{sec:basic-plotting}. Parts of the code are very similar. Our window slowly starts getting more complex, with more elements. So far, you've two buttons stacked horizontally, but you would like to show the plot beneath the buttons, not next to them. One of the most natural solutions is to start stacking widgets, instead of making the \py{buttons_widget} the central Widget, you can make another one that contains the buttons and the plot.

\begin{minted}{python}
import pyqtgraph as pg
from PyQt5.QtWidgets import (QMainWindow,
                             QPushButton,
                             QWidget,
                             QHBoxLayout,
                             QVBoxLayout, )

class MainWindow(QMainWindow):
    def __init__(self, experiment=None):
        super().__init__()
        self.experiment = experiment
        self.setWindowTitle('Scan Window')

        self.central_widget = QWidget()
        self.button_widgets = QWidget()
        self.start_button = QPushButton('Start')
        self.stop_button = QPushButton('Stop')
        self.plot_widget = pg.PlotWidget(title="Plotting I vs V")
        self.plot = self.plot_widget.plot([0], [0])

        layout = QHBoxLayout(self.button_widgets)
        layout.addWidget(self.start_button)
        layout.addWidget(self.stop_button)

        central_layout = QVBoxLayout(self.central_widget)
        central_layout.addWidget(self.button_widgets)
        central_layout.addWidget(self.plot_widget)

        self.setCentralWidget(self.central_widget)
\end{minted}

Some remarks about the code before you run it. You're using \py{()} for the import because it makes it easier to stack the modules instead of having a very long line that becomes hard to read. In the window, you define three widgets now, \py{central_widget}, \py{button_widgets}, and \py{plot_widget}. The plot widget is very similar to what you did in the previous chapter. The only difference is that you store the Widget itself and the plot separately, and you explain why later. You didn't touch the buttons, but instead of adding them as the central Widget, you add them to a higher-order widget. By stacking the buttons horizontally between themselves, but vertically to the plot, you get a window that looks like this:

\begin{center}
    \includegraphics[width=.4\textwidth]{images/Chapter_08/07_window_empty_plot.png}
\end{center}

You're halfway through with what you wanted. If you resize the window, the plot changes, taking all the space available, even if you expand the window vertically, there's no gray area around the buttons. How the surrounding elements control the shape of a widget is one of the properties that can be specified.

\tipsInfo{Qt options}{You make several remarks about possibilities with Qt that you don't explore further. You just want to point out that every single thing that happens on a user interface was decided, and can be changed. Not only the aspect, such as colors but also how different elements relate to each other and change shapes when the container window changes.}

To plot the data you acquire, you just need to update the plot periodically. Qt offers a special object called \py{QTimer} that also specifies signals. With timers, you can trigger periodic actions without interrupting the rest of the program. You also need to develop a method that can update the plot. The Main Window code looks like this:

\begin{minted}{python}
    from PyQt5.QtCore import QTimer
    [...]

    class MainWindow(QMainWindow):
        def __init__(self, experiment=None):
            [...]
            self.timer = QTimer()
            self.timer.timeout.connect(self.update_plot)
            self.timer.start(50)

        def update_plot(self):
            self.plot.setData(self.experiment.scan_range, self.experiment.scan_data)
\end{minted}

The timer is relatively easy to understand. It's an object that triggers a signal, \py{timeout} periodically. You connect that signal to the method \py{update_plot}. When you start the timer, you need to specify the time interval in milliseconds, therefore $50\,\textrm{ms}$ means a refresh rate of $20\,\textrm{Hz}$. The \py{update_plot} method is different from what you did in the previous chapter. Instead of using \py{plot}, you're using \py{setData}. There are two reasons for it. First, if you use \py{plot()}, you create a new plot on top of the existing one. You wouldn't be refreshing the data but drawing on top of it. After a while, especially if the parameters or results change, you would see several lines overlapping. The second reason is speed. \py{plot()} is a relatively slow method because several things need to be set up, such as the axes, labels, ticks. By using \py{setData} PyQtGraph automatically reuses the elements available.

However, if you try to run the code, you will get a problem:

\begin{minted}{bash}
    AttributeError: 'Experiment' object has no attribute 'scan_range'
\end{minted}

\questionInfo{Exercise}{Find out why are you getting this error even though you didn't find it when running a more straightforward script in the previous chapter}

When the window starts, you automatically start the timer, which, in turn, tries to update the plot. However, the experiment class does not have any \py{scan_range} nor \py{scan_data} until the experiment starts running. A bypass to the problem would be to start the timer after you've started the scan, but this is very unreliable. Best-practices in Python indicate that you should always define attributes in classes in the \py{__init__} method. It means that as soon as you create the object, the attributes exist, even if with place-holder values.

When you developed the \emph{Experiment class}, you completely neglected this practice. You added \py{self.} whenever you needed to have data available through the class and also from outside of it. You leave the definition of most of the attributes to the reader, but you show how to solve the problem with the scan. Going back to the experiment model, you need to add the following:

\begin{minted}{python}
    class Experiment:
        def __init__(self, config_file):
            [...]
            self.scan_range = np.array([0]) * ur('V')
            self.scan_data = np.array([0])  * ur('V')
\end{minted}

You decided to define both attributes as numpy arrays holding only one value: $0\,\textrm{V}$. If you try to plot these results, you get a single point at the origin. It may raise other questions, such as whether it's better to have a $0$ or a \py{None} value, because $0\,\textrm{V}$ could be a valid measured value. It's left to the sensitivity of the reader to judge what is best in their specific case. For our purposes, this is enough to get the window running and showing a plot of the data in real-time once the scan starts.

\questionInfo{Exercise}{Every attribute in any class should be defined in the init of that class. Go through all the models, and see whether there are attributes used but not defined at instantiation.}

\subsection{Increasing the refresh rate and number of data points}\label{subsec:refresh-rate-and-number-of-data-points}
When you follow the strategy of using a timer for refreshing the plot, you can be tempted to increase the refresh rate to make the animations more appealing, but you've to be careful with this. On the one hand, if you're generating data at, let's say, $1\,\textrm{Hz}$, doesn't matter how fast you refresh the plot, it won't change faster than once per second.

Let's assume you're acquiring data much faster than once per second, perhaps at hundreds or thousands of new points per second. You've to consider how fast the screen of the computer can redraw the elements on it. Most screens work at $30\,\textrm{Hz}$, some may go to $60\,\textrm{Hz}$. Therefore, if you try to update the plot faster than that, you just waste computer power on something that the screen never can show us.

There's one additional limitation that is our own eyes. You can't process images faster than at 30fps. Already at $50\,\textrm{Hz}$, you don't see the lights in our room blinking. If you're not interested in video quality for the update of our plots, you can safely go down to $20\,\textrm{Hz}$, and the images still look fluid.

\questionInfo{Exercise}{Instead of plotting data from the device, you can update the plot with points that oscillate in time and see up to which point the refresh rate affects the quality of what you're showing.}

There's one more thing to consider beyond the refresh rate, which is the number of points you're plotting. Most screens have a few thousand pixels in each direction. A very common resolution is $1920\times1440\,\textrm{pixels}$. If you acquire $10000$ data points and try to show them on the screen, they have to be reduced almost 5 times to fit the number of pixels available on the screen. In this reduction process, you can lose many details. If you use downsampling, for example, and you're looking for a narrow peak, the chances of it appearing on the image can be very little.

You've to be aware of the number of data pixels that you try to show not only on user interfaces but also when you're preparing plots for printing or inserting into a PDF. The number of dots a printer can generate is normally specified as dots per inch, or dpi. Even at $600\,\textrm{dpi}$, an image with a width of $8\,\textrm{cm}$ (standard 1-column figure on a paper) will have under 2000 dots in its horizontal direction. And, of course, a reader behind a computer screen is limited to its pixels.

\section{Conclusions}\label{sec:basic-gui-conclusions}
In this chapter, you've started building a user interface for the experiment. You explored how to get started with Qt, PyQt, how to use buttons to trigger actions using signals and slots. You also saw how to connect a basic user interface to the experiment model. It showed us the advantages of having an experiment that already runs measurements in its threads.

You also saw how to extend the basic building blocks of Qt, such as QMainWindow, by subclassing it and adding the elements you needed. You saw how to build widgets with more widgets inside, how to lay them out on more complex patterns. Finally, you added simple plotting capabilities to the window, refreshing whatever data the experiment is acquiring in real-time.

This chapter typically generates much satisfaction for people who are developing user interfaces for the first time. On the other hand, you've done much work, and you got a window that does not look nearly as nice as the windows with which you're familiar from other programs. On the one hand, this helps us understand how much effort is behind every window you see. On the other, it pushes us to go one step further.

In the next chapter, you start seeing how to improve the design of our User Interfaces by using a program called Qt Designer.
