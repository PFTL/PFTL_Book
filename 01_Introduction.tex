\chapter{Introduction}
In most laboratories around the world, computers are in charge of controlling experiments. From complex systems such as particle accelerators to simpler UV-Vis spectrometers, there is always a computer in charge of asking the user for some input, performing a measurement and displaying the results. However, for many experimentalists, the software that comes packaged is not sufficient and is barely customizable. 

This book is task-oriented, meaning that it is focused on showing you how things can be done and not into a lot of theory on how programming works in general. This, of course, leads to some generalizations that may not be correct in all scenarios. I ask your forgiveness in those cases and your cooperation: if you find anything that can be improved, or corrected, please contact me.

Together with the book, there is a website where you can find extra information, anecdotes and examples that didn’t fit in here. Remember that the website and its forum are the proper places to communicate with fellow Python For The Lab readers. If you are stuck with the exercises or you have questions that are not answered in the book, don’t hesitate to shout in the comments section of the website.

\section{Why building your own software}
Computers and the software within them, should be regarded as tools and not as obstacles in a researcher daily tasks. However, when it comes to controlling a setup, many scientists prefer to be bound by what the software can perform while not pursuing innovative ideas. Once you learn how to develop your own programs, you will be limited only by your imagination. 

Imagine for a moment that you work with a microscope. Your task is to acquire spectra of some bright nanoparticles. Your job is to focus on each particle and trigger a spectrometer. Change some parameters and repeat. This is tedious, slow and error-prone. Focusing on a bright spot can be easily done by a computer, as well as triggering a spectrometer. 

Another example, imagine that you are inspecting a sample, looking for a special pattern. But once you find it, you have few seconds to trigger a measurement. However, you will never be able to do this by hand. Even in optimized conditions, you need more than few seconds between acquiring, analyzing and making a decision. 

The problems listed above are just some of the realities that researchers face in the lab. In some cases, better software will increase the throughput of a setup. You can leave it running all night, generating better statistics. Sometimes it will open the door to experiments that would have been impossible otherways. Custom software is the only way in which you can bring your instruments to a new life. 

\section{What are you going to learn}
With this book we want you to gain a first insight into the world of developing software for controlling experiments. We will start by discussing how to set up a proper development environment and quickly focus on building a driver for a device. Drivers are the fundamental building blocks of any program for controlling experiments and therefore it is a topic in which you need a solid foundation. 

Once you have the driver in place, you will be tempted to start performing measurements. However, there are some programming patterns that will guarantee the success of your software in the long run. You will be introduced to the Model-View-Controller paradigm and its implications for instrumentation software. You will learn about extracting logic from functionality and laid the foundations for reusable code. 

Once the code is functional, you will learn how to perform measurements and save the data, including metadata, to be able to repeat a measurement if needed. You will plot your results and try to interpret them. So far everything is happening through the command line, with messages being printed to screen. But you are going to go one step further. 

Thanks to the solid structure that you have achieved up to this point, building a Graphical User Interface will be relatively easier. You will learn how to design a window that accepts input from the user and displays a plot with the results to the user. You will be able to save data from the window and learn how to verify the input parameters before passing them to an instrument. 

More importantly, you will learn some strategies that will make your programs more reusable, not only by you in the future, but by others in the same setup. This book is the starting point for laying out a program that is guaranteed to last. The most difficult task when developing software for the lab is knowing where to start. This book is exactly that, a starting point for your future endeavors.

\section{Who is this book intended for}
When I started this book, I wanted to make it possible for people with very different programming levels to achieve a common goal. I found that the only way to do this is to be a bit dogmatic with the explanations. For example, if you want to do this you should type that. By starting the development through a real need, a question arising from the real world, you can anticipate what is going to happen in the future and therefore the motivation level will remain high enough as to continue thinking in a solution.

Generally speaking, you will need a basic level of programming. You should understand what is an \textit{if-statement}, why would you use a \textit{for-loop} or a \textit{while-loop}. We are going to make extensive use of classes in Python, but without complicating it too much. In the book, you can find a refreshment of how to work with classes and other syntactic examples of Python. You should read that chapter through, especially if you are not familiar with Python. If you find that the contents are too complicated for your level, you should consider starting with an easier book, perhaps on how to use Python for analyzing data.

Even if not strictly required, you will also need a basic understanding of how an experiment works and a bit of physics. Namely, you need to understand that an experiment starts by designing a way in which you can alter your object of study in a controlled manner and monitor some signals while you do so. The experiment we are going to perform throughout this book is a common example in many, many different fields: we are going to change an analog output while we measure an analog input. If you are using the device that accompanies the course, the experiment is going to be measuring the I-V curve of a diode.

Varying an output voltage and recording an input is a common task in innumerable experiments from different fields. Changing a voltage can be related to displacement through a piezo stage, you can change the intensity of light, you can alter temperature, and the list goes on and on. Measuring a voltage can be equivalent to determining a current, the intensity of light, a displacement, a force, etc. Look around in your own lab and probably will find examples.

\section{Uetke DAQ Device}
Together with the book, you are going to receive a device that will act as a Data Acquisition board, or DAQ for short. The device is able to acquire analog signals but also to generate analog outputs. The device will be connected to the computer via the USB port. Having a real device is paramount for students to translate the knowledge acquired to their own realities. 

Building software for the lab has a reality component not covered in any other books or tutorials. The fact that you are interacting with real-world devices, that is able to change the state of an experiment, makes the development process much more compelling. The Uetke DAQ is a toy device, easy to replace, but capable of performing quality measurements. 

\section{About this book}
This book is a compendium of the best strategies that I have found while developing software for different laboratories. I have tried to justify every decision made, but some are rooted more in an aesthetic choice than in an architectural one. You are free to change and improve whatever you think will lead you to better (or faster) results. I have tested what I propose and I am very confident with the outcome. If you are not very experienced, I suggest that you start in the same way as the book does and later on you can find your own way.

When developing software, you will probably realize that it is going to be used by another person either at the same time or in the future. In many labs, people come and go and therefore you cannot count on being around for answering questions regarding your programs, or vice versa, you will have to understand someone else’s code. If you adhere to some common standards, everybody’s life will be much easier. In Python For The Lab, you will find a lot of recommendations regarding how to make your code clear, to you and to others.

You can find many tools that will help you in keeping your code organized, such as tools for version control and documenting. They are, however, a topic completely different from what we intend to cover in this book. There will be some hints as to where to start. Remember that many of the problems can be solved by clear policies established in each lab, such as where to put the code for sharing with other members, how to document, etc. If there is nothing like that where you work, you should seriously consider discussing it with your team members.

The book is divided into different chapters where you will develop different skills. Each chapter is aimed at tackling a specific problem that we want to solve, and that is clearly stated in the chapter objectives. It may happen that a chapter is easier for you because it is what you are used to doing, and you will be inclined to skip it. However, bear in mind that each chapter builds on the previous one and therefore you should be sure that you have the needed code in place.

\section{Why Python?}
Python became ubiquitous in many research labs because of many different reasons. First, Python is free and open source and therefore there is no overhead when implementing it. Compared to the price of the licenses of programs such as Matlab or LabView, we can make some compromises while using Python. On the downside, Matlab and Lab View have a relatively good professional support and communities built around them. Answers to questions regarding Python have to be found by searching online, most likely in Stack Overflow.

If you search online for instructions on how to control your experiment with Python, you will find really few sources of information. Fortunately, this is changing thanks to an evergrowing number of people developing open source code and writing very useful documentation. Python can achieve all the same functionality as Lab View, the only limitation is the existence of drivers for more complex instruments. With a stronger community, companies will realize the value of providing drivers for other programming environments.

Python doesn’t need to be compiled to execute a script, meaning that changes done to the code can be immediately observed. Its syntax is very clear and intuitive; people making the switch from Matlab will find no problems in understanding the code. People making the switch from LabView, however, will have a higher learning curve converting from a drag-and-drop approach to a normal typed language. In any case, once some syntactic elements are known, a lot of things can be programmed.

A very important aspect of Python is that it is platform independent. Since Python is interpreted by a special program every time we run it, it will produce the same output regardless of whether we run on Linux, Windows or Mac. The python interpreter is responsible for adapting the way our code works under the hood to the different architectures. Thus we can develop on our office PC running Windows, run the code in the lab that runs Linux and share it with a colleague who prefers a Mac.

Many of the doubts that can arise when programming with Python will not be specific to interfacing with instruments, but more general regarding how to achieve a certain functionality. Normally you can find answers to all of them just by searching online. And if not, you can always refer to the forum of the Python For The Lab website. It is a great place to share your doubts, especially because it will help us improve the contents of this book.

\section{The Onion Principle}
When you start developing software it is very hard to think ahead. Most likely you have a small problem that you want to solve and you just go for it. Later on, it may turn out, and this is especially true for people who work in labs, that that small problem is actually something worth investigating. Your software will not be able to handle the new tasks and you will need to improve it. Here is where having the proper set of rules in place will help you and I like to call them the Onion Principle.

The rules I am talking about are not rules written in stone and that you can find clearly stated in a book (by the way, you won’t find them here). I am talking about a set of mind that will empower yourself to develop better, clearer and more expandable code. Sitting down and reflecting is the best you can do, even more than sitting down and typing. When dealing with experiments you have a lot of things to ask yourself, what do you know, what do you want to prove, how to do it. Only then you will sit down to write a program that responds to your needs.

If you build something that cannot be expanded, it will become useless very soon. When you don’t really know what may happen with your code, you should think ahead and structure it as an onion, in layers. I am not claiming that it is something that happens naturally, but you can develop your own set of procedures to ensure that you are developing future-proof code. Once you get the handle on it, it won’t take you longer than being disorganized and not having the proper structure. Variables that are not self-descriptive, lack comments, and the list goes on and on.

It is not all about being future-proof. When you start with a simple task at hand, you want to solve it quickly and not spending hours developing useless lines of code just thinking what if. I am all in for that kind of solutions; however, a strong foundation is always important. Taking shortcuts just because you don’t want to create a separated file will give you more headaches even in the short term. You should build code that is robust enough to support for expansion later on. In the same way that you take steps while performing an experiment, you should take steps when developing software.

One of the key elements to achieve a great onion-like approach in Python is to use classes. They are concise elements with clear functionality and very easy to document. They can be imported and even expanded without changing the original code, as we will see by the end of this chapter. If you come from the data analysis world, it may very well be that you never developed your own classes, but this is about to change with this book. You shouldn’t be afraid of them; you should just try to understand them because I can guarantee that once you get the handle of the, you won’t be able to stop thinking in their own terms.

I will not make special emphasis on why I ask you to do the things in a certain way throughout the book. However, if you pay attention you will notice that each step is incremental. You won’t have to start all over again to add a new feature that you didn’t about. And this ends up being easy because the foundation given by the previous step is very solid. I am not saying that there is only one way of achieving the same results, but I will be just showing you a way of doing things. When you have the chance to improve something without much effort, you should take it, you will be very grateful to your past self.

In the end, all the common practices and development patterns that I can show you, are thought just to make you save time not only in the long run but also next week. I have, just as you are about to do, started developing software for acquiring a very simple signal, an analog input generated by a photodiode. It didn’t take long until I wanted to move a piezo stage with an analog output and suddenly I needed a way of doing 2D and 3D scans of my sample. Sadly for me, there was no one around who could show me a way to being organized and clear with my code.

This book is based not only on my own experiences working in different labs but also on the experiences of the people who surrounded me, who received my code. Sometimes we cannot anticipate the ramifications that our work will have, but I can assure to you, that if you started like a small onion, layer by layer, they are going to be very satisfying.

\section{The Agile Process}
The Agile software development describes a particular approach to software development methodology based on iterative development. Its core value is that requirements and solutions evolve through a collaborative process between developers and customers. The principles of the Agile methodology are summarized in four statements in its manifesto. They are:

\begin{itemize}
 \item Individuals and interactions over processes and tools
 \item Working software over comprehensive documentation
 \item Customer collaboration over contract negotiation
 \item Responding to change over following a plan
\end{itemize}
        
Agile in itself doesn’t establish any particulars regarding programming but just how to develop a workflow and a working environment. In the last few years, Agile has attracted a lot of attention, extending its concepts away from software development, and moving into project management. Even though the core principles were drawn from a programming context, scientific projects could also benefit from the Agile ideas, but with some reservations.

Some of the main points of an Agile process, such as responding to change over following a plan are a routine reality in a lab. Plans are hard to follow because a researcher cannot be sure of what lays ahead. More interesting questions arise or some things just don’t work as expected. Being flexible to overcome obstacles and to change focus when more important questions can be answered, is a needed attribute of successful researchers.

Collaboration over negotiation is also common in a scientific setting, where a lot of agreements are done verbally, without almost any negotiation. Sometimes it is not even an agreement, but just mere curiosity that sparkles a collaboration. Collaboration in science often starts with complementary capacities, for example, two different groups which developed expertise in different techniques. Negotiations come at a much later stage, only when the collaboration was successful and researchers need to agree on how to share the credit.

The other two principles of the Agile methodology, however, are worth discussing in detail in the context of scientific work. To value individuals and interactions is a general principle to which few researchers will oppose. It is better to allow creativity than to be fixated on a specific process or tool. Moreover, great ideas may appear from a discussion or an interaction with another researcher. However, it is also important to value the processes and tools that each researcher has available in the lab. Even though questions can appear in any setting, only places with the proper setups will be able to answer them. The opposite is also valid, posing questions to which one has the proper tools to answer.

The context of every research is different and every field is particular; valuing individuals is part of a healthy working environment, but one should not lose sight of the established processes. Processes can guarantee the quality of data and the moral integrity of researchers. It doesn’t mean things cannot be changed for the better, but there should be a limit to how much an individual can be valued over an established process. A brilliant scientist will stop contributing to the group if he or she doesn’t document the work or doesn’t follow the procedures established to share resources, for example.

Working software over extensive documentation should be better rephrased as Results over extensive documentation. In this particular point, an Agile process can be the opposite of what a lab manager wishes, but it is exactly what commonly happens. Reproducing results is only possible when extensive documentation is available, allowing others to perform the exact same measurement. The pace at which science is moving, however, values quick results over thorough research, allowing little or no time to provide extensive documentation about experiments and results.

Documentation in science has a different value than for software development, but the rhythm at which both evolve is fundamentally the same. Science is based on building on each other’s work, while software development can be done to overcome a very specific obstacle. The difference between a scientific work and software development is, therefore, the life cycle of the results. While one expects to build experiments on top of the knowledge generated in a lab, he may not use an available program as a starting point for further development.

The Agile manifesto provides not only the four values stated at the beginning but also twelve principles to follow. Some of which are very relevant to a lab manager. For example:

\begin{itemize}
 \item Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
 \item The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
 \item Continuous attention to technical excellence and good design enhances agility.
 \item Simplicity —the art of maximizing the amount of work not done— is essential.
 \item At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.
\end{itemize}

When you are developing software within a scientific environment is very important to be critical about what you are requested to do and how to do it. If you are used to developing software for customers or for small projects, you will notice that what people expect is completely different from what researchers expect. The software that you leave in a lab is going to be used, hopefully, for many years, and future researchers are going to need to implement new options and functionalities into your program. Keep this in mind when you are deciding how to document or if you plan to use a very obfuscated Python method.
