\chapter{Introduction}
In most laboratories around the world, computers are in charge of controlling experiments. From complex systems such as particle accelerators to simpler UV-Vis spectrometers, there is always a computer in charge of asking the user for some input, performing a measurement and displaying the results. However, for many experimentalists, the software that comes packaged is not sufficient and is barely customizable. Moreover, if you have a custom built setup you will also need custom built software.

Even if most scientists are used to analyzing data with a computer, very few of them are able to write software for controlling experiments. This is due, in part, to a very severe lack of documentation and examples, in part due to the lack of working libraries to work upon. Python For The Lab is a humble attempt to overcome the current limitations while trying to build a community around common practices when dealing with experiments and interfacing through the computer.

Without further ado, welcome to the book Python For The Lab. This book is thought as a guide to building all the software you need for interfacing with a real-world device. We are going to start from the very basic of communicating with a device through the exchange of commands, building slowly towards classes and finalizing with a graphical user interfaces (GUI). This book is task-oriented, meaning that it is focused on showing you how things can be done and not into a lot of theory on how programming works in general. This, of course, leads to some generalizations that may not be correct in all scenarios. I ask your forgiveness in those cases and your cooperation: if you find anything that can be improved, or corrected, please contact me.

Together with the book, there is a website where you can find extra information, anecdotes and examples that didn’t fit in here. Remember that the website is the proper place to communicate with fellow Python For The Lab readers. If you are stuck with the exercises or you have questions that are not answered in the book, don’t hesitate to shout in the comments section of the website.

This book is a compendium of the best strategies that I have found while developing software for different laboratories. I have tried to justify every decision made, but some are more of an aesthetic choice than an architectural one. You are free to change and improve whatever you think will lead you to better (or faster) results. I have tested what I propose and I am very confident with the outcome. If you are not very experienced, I suggest that you start in the same way as the book does and later on you can find your own way.

When developing software, you will probably realize that it is going to be used by another person either at the same time or in the future. In many labs, people come and go and therefore you cannot count on being around for answering questions regarding your programs, or vice versa, you will have to understand someone else’s code. If you adhere to some common standards, everybody’s life will be much easier, and in Python For The Lab, you will find a lot of recommendations regarding how to make your code clear, to you and to others.

You can find many tools that will help you in keeping your code organized, such as tools for version control and documenting. They are, however, a topic completely different from what we intend to cover in this book. There will be some hints as to where to start. Remember that many of the problems can be solved by clear policies established in each lab, such as where to put the code for sharing with other members, how to document, etc. If there is nothing like that where you work, you should seriously consider discussing it with your team members.

The book is divided into different chapters where you will develop different skills. Each chapter is aimed at tackling a specific problem that we want to solve, and that is clearly stated in the chapter objectives. It may happen that a chapter is easier for you because it is what you are used to doing, and you will be inclined to skip it. However, bear in mind that each chapter builds on the previous one and therefore you should be sure that you have the needed code in place.

\section{Who is this book intended for}
When I started this book I wanted to make it possible for people with very different programming levels to achieve a common goal. I found that the only way to do this is to be a bit dogmatic with the explanations, for example, if you want to do this you should type that. By starting the development through a real need, a question arising from the real world, you can anticipate what is going to happen in the future and therefore the motivation level will remain high enough as to continue thinking in a solution.

Generally speaking, you will need a bit of programming knowledge; you should understand what an if statement is, why would you use a for loop or a while loop. We are going to make extensive use of classes in Python, but without complicating it too much. In the book, you can find a refreshment of how to work with classes and other syntactic examples of Python. You should read that chapter through, especially if you are not familiar with Python. If you find that the contents are too complicated for your level, you should consider starting with an easier book, perhaps on how to use Python for analyzing data.

Even if not strictly required, you will also need a basic understanding of how an experiment works and a bit of physics. Namely, you need to understand that an experiment starts by designing a way in which you can alter your object of study in a controlled manner and monitor some signals while you do so. The experiment we are going to perform throughout this book is a common example in many, many different fields: we are going to change an analog output while we measure an analog input. If you are using the device that accompanies the course, the experiment is going to be measuring the I-V curve of a diode.

\section{What do we want to achieve?}

With this book we want you to gain a first insight into the world of developing software for controlling experiments. Not only through the command line but also through a User Interface that you are going to build yourself from scratch. We want to lay down the foundations for future work in developing an ecosystem of packages that can control a variety of experiments, in different fields.

By following the book you will gain a set of tools that you will be able to immediately use in your own laboratory. It may seem simple at the beginning, but if you think it through, you will notice that the possibilities are endless. The main objective of this book is to give you the tools to be able to understand the documentation online and to know where you can ask for help.

By reading the book you are not going to become a better programmer; you are not going to learn the fancy caveats of Python such as decorators, inheritance, etc. But you will learn how to package your code for others to use, how to use threading for performing different tasks at the same time and many other useful topics for working in the lab. It is a very hands-on approach that has proven to be the best pedagogical strategy.

You are going to receive a device that will act as a DAQ, short of Data Acquisition. The device is able to acquire analog signals but also to generate analog outputs. They are called analog because you can set the output to whatever value you want within a certain voltage range. The device will be connected to the computer via the USB port. With this device you are going to perform an experiment: measure the I-V curve of a diode. This is, measure the current that circulates through a diode as a function of the voltage that you apply to it.

Varying an output voltage and recording an input is a common task in innumerable experiments from different fields. Changing a voltage can be related to displacement through a piezo stage, you can change the intensity of light, you can alter temperature and the list goes on and on. Measuring a voltage can be equivalent to determining a current, the intensity of light, a displacement, a force, etc. Most likely at your own lab, you will find this same pattern.

What we want to achieve therefore is not just measuring the I-V curve of a diode, but showing you all the process from building a driver for your device, to performing a measurement and building a user interface to interact with it. The skills that you are going to acquire are the base for building very sophisticated and specialized software. You are also going to get acquainted with resources and tools that you will find very interesting for the future.

\section{Why Python?}

Python became ubiquitous in many research labs because of many different reasons. First, Python is free and open source and therefore there is no overhead when implementing it. Compared to the price of the licenses of programs such as Matlab or LabView, we can make some compromises while using Python. On the downside, Matlab and Lab View have a relatively good professional support and communities built around them. Answers to questions regarding Python have to be found by searching online, most likely in Stack Overflow.

If you search online for instructions on how to control your experiment with Python, you will find really few sources of information. Fortunately, this is changing thanks to an evergrowing number of people developing open source code and writing very useful documentation. Python can achieve all the same functionality as Lab View, the only limitation is the existence of drivers for more complex instruments. With a stronger community, companies will realize the value of providing drivers for other programming environments.

Python doesn’t need to be compiled to execute a script, meaning that changes done to the code can be immediately observed. Its syntax is very clear and intuitive; people making the switch from Matlab will find no problems in understanding the code. People making the switch from LabView, however, will have a higher learning curve converting from a drag-and-drop approach to a normal typed language. In any case, once some syntactic elements are known, a lot of things can be programmed.

A very important aspect of Python is that it is platform independent. Since Python is interpreted by a special program every time we run it, it will produce the same output regardless of whether we run on Linux, Windows or Mac. The python interpreter is responsible for adapting the way our code works under the hood to the different architectures. Thus we can develop on our office PC running Windows, run the code in the lab that runs Linux and share it with a colleague who prefers a Mac.

Many of the doubts that can arise when programming with Python will not be specific to interfacing with instruments, but more general regarding how to achieve a certain functionality. Normally you can find answers to all of them just by searching online. And if not, a great source of information is Stack Overflow. Don’t be afraid to ask whatever is in your mind, the community will guide you through the process on how to make your question more specific if needed, or they will point you towards the solution.

\section{The Onion Principle}

When you start developing software it is very hard to think ahead. Most likely you have a small problem that you want to solve and you just go for it. Later on, it may turn out, and this is especially true for people who work in labs, that that small problem is actually something worth investigating. Your software will not be able to handle the new tasks and you will need to improve it. Here is where having the proper set of rules in place will help you and I like to call them the Onion Principle.

The rules I am talking about are not rules written in stone and that you can find clearly stated in a book (by the way, you won’t find them here). I am talking about a set of mind that will empower yourself to develop better, clearer and more expandable code. Sitting down and reflecting is the best you can do, even more than sitting down and typing. When dealing with experiments you have a lot of things to ask yourself, what do you know, what do you want to prove, how to do it. Only then you will sit down to write a program that responds to your needs.

If you build something that cannot be expanded, it will become useless very soon. When you don’t really know what may happen with your code, you should think ahead and structure it as an onion, in layers. I am not claiming that it is something that happens naturally, but you can develop your own set of procedures to ensure that you are developing future-proof code. Once you get the handle of it, it won’t take you longer than being disorganized and not having the proper structure. Variables that are not self-descriptive, lack comments, and the list goes on and on.

It is not all about being future-proof. When you start with a simple task at hand, you want to solve it quickly and not spending hours developing useless lines of code just thinking what if. I am all in for that kind of solutions; however, a strong foundation is always important. Taking shortcuts just because you don’t want to create a separated file will give you more headaches even in the short term. You should build code that is robust enough to support for expansion later on. In the same way that you take steps while performing an experiment, you should take steps when developing software.

One of the key elements to achieve a great onion-like approach in Python is to use classes. They are concise elements with clear functionality and very easy to document. They can be imported and even expanded without changing the original code, as we will see by the end of this chapter. If you come from the data analysis world, it may very well be that you never developed your own classes, but this is about to change with this book. You shouldn’t be afraid of them; you should just try to understand them because I can guarantee that once you get the handle of the, you won’t be able to stop thinking in their own terms.

I will not make special emphasis on why I ask you to do the things in a certain way throughout the book. However, if you pay attention you will notice that each step is incremental. You won’t have to start all over again to add a new feature that you didn’t about. And this ends up being easy because the foundation given by the previous step is very solid. I am not saying that there is only one way of achieving the same results, but I will be just showing you a way of doing things. When you have the chance to improve something without much effort, you should take it, you will be very grateful to your past self.

In the end, all the common practices and development patterns that I can show you, are thought just to make you save time not only in the long run but also next week. I have, just as you are about to do, started developing software for acquiring a very simple signal, an analog input generated by a photodiode. It didn’t take long until I wanted to move a piezo stage with an analog output and suddenly I needed a way of doing 2D and 3D scans of my sample. Sadly for me, there was no one around who could show me a way to being organized and clear with my code.

This book is based not only on my own experiences working in different labs but also on the experiences of the people who surrounded me, who received my code. Sometimes we cannot anticipate the ramifications that our work will have, but I can assure to you, that if you started like a small onion, layer by layer, they are going to be very satisfying.

\section{The Agile Process}

The Agile software development describes a particular approach to software development methodology based on iterative development. Its core value is that requirements and solutions evolve through a collaborative process between developers and customers. The principles of the Agile methodology are summarized in four statements in its manifesto. They are:

        Individuals and interactions over processes and tools
        Working software over comprehensive documentation
        Customer collaboration over contract negotiation
        Responding to change over following a plan

Agile in itself doesn’t establish any particulars regarding programming but just how to develop a workflow and a working environment. In the last few years, Agile has attracted a lot of attention, extending its concepts away from software development, and moving into project management. Even though the core principles were drawn from a programming context, scientific projects could also benefit from the Agile ideas, but with some reservations.

Some of the main points of an Agile process, such as responding to change over following a plan are a routine reality in a lab. Plans are hard to follow because a researcher cannot be sure of what lays ahead. More interesting questions arise or some things just don’t work as expected. Being flexible to overcome obstacles and to change focus when more important questions can be answered, is a needed attribute of successful researchers.

Collaboration over negotiation is also common in a scientific setting, where a lot of agreements are done verbally, without almost any negotiation. Sometimes it is not even an agreement, but just mere curiosity that sparkles a collaboration. Collaboration in science often starts with complementary capacities, for example, two different groups which developed expertise in different techniques. Negotiations come at a much later stage, only when the collaboration was successful and researchers need to agree on how to share the credit.

The other two principles of the Agile methodology, however, are worth discussing in detail in the context of scientific work. To value individuals and interactions is a general principle to which few researchers will oppose. It is better to allow creativity than to be fixated on a specific process or tool. Moreover, great ideas may appear from a discussion or an interaction with another researcher. However, it is also important to value the processes and tools that each researcher has available in the lab. Even though questions can appear in any setting, only places with the proper setups will be able to answer them. The opposite is also valid, posing questions to which one has the proper tools to answer.

The context of every research is different and every field is particular; valuing individuals is part of a healthy working environment, but one should not lose sight of the established processes. Processes can guarantee the quality of data and the moral integrity of researchers. It doesn’t mean things cannot be changed for the better, but there should be a limit to how much an individual can be valued over an established process. A brilliant scientist will stop contributing to the group if he or she doesn’t document the work or doesn’t follow the procedures established to share resources, for example.

Working software over extensive documentation should be better rephrased as Results over extensive documentation. In this particular point, an Agile process can be the opposite of what a lab manager wishes, but it is exactly what commonly happens. Reproducing results is only possible when extensive documentation is available, allowing others to perform the exact same measurement. The pace at which science is moving, however, values quick results over thorough research, allowing little or no time to provide extensive documentation about experiments and results.

Documentation in science has a different value than for software development, but the rhythm at which both evolve is fundamentally the same. Science is based on building on each other’s work, while software development can be done to overcome a very specific obstacle. The difference between a scientific work and software development is, therefore, the life cycle of the results. While one expects to build experiments on top of the knowledge generated in a lab, he may not use an available program as a starting point for further development.

The Agile manifesto provides not only the four values stated at the beginning but also twelve principles to follow. Some of which are very relevant to a lab manager. For example:

        Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
        The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
        Continuous attention to technical excellence and good design enhances agility.
        Simplicity —the art of maximizing the amount of work not done— is essential.
        At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.

When you are developing software within a scientific environment is very important to be critical about what you are requested to do and how to do it. If you are used to developing software for customers or for small projects, you will notice that what people expect is completely different from what researchers expect. The software that you leave in a lab is going to be used, hopefully, for many years, and future researchers are going to need to implement new options and functionalities into your program. Keep this in mind when you are deciding how to document or if you plan to use a very obfuscated Python method.
