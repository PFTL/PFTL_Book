\chapter{Introduction}
In most laboratories around the world, computers are in charge of controlling experiments. From complex systems such as particle accelerators to simpler UV-Vis spectrometers, there is always a computer responsible for asking the user for some input, performing a measurement, and displaying the results. Learning how to control devices through the computer is, therefore, of utmost importance for every experimentalist who wants to gain a deeper degree of freedom when planning measurements. 

This book is task-oriented, meaning that it is focused on showing you how things can be done and not into a lot of theory on how programming works in general. This, of course, leads to some generalizations that may not be correct in all scenarios. I ask your forgiveness in those cases and your cooperation: if you find anything that can be improved, or corrected, please contact me.

Together with the book, there is a website\footnote{https://www.pythonforthelab.com} where you can find extra information, anecdotes and examples that didn’t fit in here. Remember that the website and its forum are the proper places to communicate with fellow Python For The Lab readers. If you are stuck with the exercises or you have questions that are not answered in the book, don’t hesitate to shout in the forum. Continuous feedback is the best way to improve this book. 

\section{Why building your own software}
Computers and the software within them, should be regarded as tools and not as obstacles in a researcher's daily tasks. However, when it comes to controlling a setup, many scientists prefer to be bound by what the software can perform while not pursuing innovative ideas. Once you learn how to develop your own programs, you will be limited only by your imagination. 

Let's assume for a moment that you work with a microscope. Your task is to acquire spectra of some bright nanoparticles. Your job is to focus on each particle and trigger a spectrometer. Change some parameters and repeat. This is tedious, slow, and error-prone. Focusing on a bright spot can be easily done by a computer, as well as triggering a spectrometer. 

Another example, imagine that you are inspecting a sample, looking for a special pattern. But once you find it, you have few seconds to trigger a measurement. Unfortunately, you will never be able to do this by hand. Even in optimized conditions, you need more than few seconds between acquiring, analyzing and making a decision. 

The problems listed above are just some of the realities that researchers face in the lab. In some cases, better software will increase the throughput of a setup. You can leave it running all night, generating better statistics. Sometimes it will open the door to experiments that would have been impossible otherways. Custom software is the way in which you can bring your instruments to a new life, and your creativity to a completely new stage. 

\section{What are you going to learn}
With this book we want you to gain a first insight into the world of developing software for controlling experiments. We will start by discussing how to set up a proper development environment and quickly focus on building a driver for a device. Drivers are the fundamental building blocks of any program for controlling experiments and therefore it is a topic in which you need a solid foundation. 

Once you have the driver in place, you will be tempted to start performing measurements. However, there are some programming patterns that will guarantee the success of your software in the long run. You will be introduced to the Model-View-Controller paradigm and its implications for instrumentation software. You will learn about extracting logic from functionality and laid the foundations for reusable code. 

Once the code is working, you will learn how to perform measurements and save the data, including metadata, to be able to repeat a measurement if needed. You will plot your results and try to interpret them. Up to this point, your program will be running through the command line, with messages being printed to screen. This book is going even one step further. 

Thanks to the solid structure that you have achieved up to this point, building a Graphical User Interface will be relatively easy. You will learn how to design a window that accepts input from the user and displays back a plot with the results of the measurement. You will be able to save data from the window and learn how to verify the input parameters before passing them to an instrument. 

More importantly, you will learn some strategies that will make your programs more reusable, not only by you in the future, but also by others which have access to the same setup. This book is the starting point for laying out a program that is guaranteed to last. The most difficult task when developing software for the lab is knowing where to start. This book is exactly that, a starting point for your future endeavors.

\section{Who is this book intended for}
When I started this book, I wanted to make it possible for people with very different programming levels to achieve a common goal. I found that the only way to do this is to be a bit dogmatic with the explanations. For example, if you want to do this you should type that. By starting the development through a real need, a question arising from the real world, you can anticipate what is going to happen in the future and therefore the motivation level will remain high enough as to continue thinking in a solution.

Generally speaking, you will need a basic level of programming. You should understand what is an \textit{if-statement}, why would you use a \textit{for-loop} or a \textit{while-loop}. We are going to make extensive use of classes in Python, but without complicating it too much. In the appendixes of the book you can find a quick walkthrough about how to work with classes and other syntactic examples of Python. You should start by reading that chapter if you are not familiar with Python. If you find that the contents are too complicated for your level, you should consider starting with an easier book, perhaps on how to use Python for analyzing data.

Even if not strictly required, you will also need a basic understanding of how an experiment works and a bit of physics. Namely, you need to understand that an experiment starts by designing a way in which you can alter your object of study in a controlled manner and monitor some signals while you do so. The experiment we are going to perform throughout this book is a common example in many, many different fields: we are going to change an analog output while we measure an analog input. If you are a student of the Python for the Lab workshop, the experiment is going to be measuring the I-V curve of a diode.

Varying an output voltage and recording an input is a common task in innumerable experiments from different fields. Changing a voltage can be related to displacement through a piezo stage, you can change the intensity of light, you can alter temperature, and the list goes on and on. Measuring a voltage can be equivalent to determining a current, the intensity of light, a displacement, a force, etc. Look around in your own lab and probably will find examples.

\section{Uetke DAQ Device}
In order to follow the book, you will need a device that acts as a data acquisition board. If you joined one of the workshops, the device will be provided by the instructor. If you got this book online and would like to buy one of Uetke DAQ's, please contact us. The devices are open source/open hardware, and you can find the instructions for building one on our website. The core of the course is that you will develop code that makes it easy to exchange devices. Therefore, if you have access to any other acquisition card, with a bit of tinkering you will be able to adapt the course contents to your needs. 

The requisits for the device is to be able to acquire analog signals, and also to generate analog outputs. The device will be connected to the computer via the USB port. Having a real device is paramount for students to translate the knowledge acquired to their own realities. 

Building software for the lab has a reality component not covered in any other books or tutorials. The fact that you are interacting with real-world devices, which are able to change the state of an experiment, makes the development process much more compelling. The Uetke DAQ is a toy device, easy to replace, but capable of performing quantitative measurements. 

\section{About this book}
This book is a compendium of the best strategies that I have found while developing software for different laboratories. I have tried to justify every decision made, but some are rooted more in an aesthetic choice than in an architectural one. You are free to change and improve whatever you think will lead you to better (or faster) results. I have tested what I propose and I am very confident with the outcome. If you are not very experienced, I suggest you start in the same way as the book does and later you can find your own way.

When developing software, you will probably realize that it is going to be used by another person either at the same time or in the future. In many labs, people come and go and therefore you cannot count on being around for answering questions regarding your programs, or vice versa, you will have to understand someone else’s code. If you adhere to some common standards, everybody’s life will be much easier. In Python For The Lab, you will find a lot of recommendations regarding how to make your code clear, to you and to others.

You can find many tools that will help you in keeping your code organized, such as tools for version control and documenting. They are, however, a topic completely different from what we intend to cover in this book. There will be some hints as to where to start. Remember that many of the problems can be solved by clear policies established in each lab, such as where to put the code for sharing with other members, how to document, etc. If there is nothing like that where you work, you should seriously consider discussing it with your team members.

The book is divided into different chapters where you will develop different skills. Each chapter is aimed at tackling a specific problem that we want to solve, and that is clearly stated in the chapter objectives. It may happen that a chapter is easier for you because it is what you are used to doing, and you will be inclined to skip it. However, bear in mind that each chapter builds on the previous one and therefore you should be sure that you have the needed code in place.

\section{Why Python?}
Python became ubiquitous in many research labs because of many different reasons. First, Python is open source, and we strongly believe that the future of research lies on openness. Even if you are an industrial researcher, the results, the way of generating data, etc. should be open to your colleagues (present and future). Python leverages the knowledge gathered in very different places in order to deliver a better product. From high-performance computing, to machine learning, to experiments, Python can be found everywhere. 

Another factor to take into account is the fact that Python is free and therefore there is no overhead when implementing it. There are no limits to the number of machines in which you can install Python, nor the number of different users. Moreover, Python is accompanied by a miriad of professionally developed tools such as numpy, scipy, scikit, etc. If you are looking for professional support, you can look at companies such as Anaconda, which provide customers with high-quality advise and troubleshooting. 

However, for experimentalists there is a big downside. If you search online for instructions on how to control your experiment with Python, you will find really few sources of information. Fortunately, this is changing thanks to an evergrowing number of people developing open source code and writing very useful documentation. Python can achieve all the same functionality of Lab View, the only limitation is the existence of drivers for more complex instruments. With a stronger community, companies will realize the value of providing drivers for other programming environments.

Python doesn’t need to be compiled in order to run, meaning that changes done to the code can be immediately observed. Its syntax is very clear and intuitive; people making the switch from Matlab will find no problems in understanding the code. People making the switch from LabView, however, will have a higher learning curve converting from a drag-and-drop approach to a normal typed language. In any case, once some syntactic elements are known, a lot of things can be programmed.

A very important aspect of Python is that it is platform independent. Since Python is interpreted by a special program every time we run it, it will produce the same output regardless of whether we run on Linux, Windows or Mac. The python interpreter is responsible for adapting the way our code works under the hood to the different architectures. Therefore, we can develop on our office PC running Windows, run the code in the lab that has Linux installed and share it with a colleague who prefers Mac.

Many of the doubts that can arise when programming with Python will not be specific to interfacing with instruments, but more general regarding how to achieve a certain functionality. Normally you can find answers to all of them just by searching online. And if not, you can always refer to the forum of the Python For The Lab website. It is a great place to share your doubts, especially because it will help us improve the contents of this book.

\section{The Onion Principle}
When you start developing software it is very hard to think ahead. Most likely you have a small problem that you want to solve and you just go for it. Later on, it may turn out, and this is especially true for people who work in labs, that that small problem is actually something worth investigating. Your software will not be able to handle the new tasks and you will need to improve it. Having a proper set of rules in place will help you have code that can adapt to your future needs while keeping you productive in the present. I like to call those rules the Onion Principle.

The rules I am talking about are not rules written in stone and you will not find them stated in a book (by the way, you won’t find them here). I am talking about a state of mind that will empower yourself to develop better, clearer and more expandable code. Sitting down and reflecting is the best you can do, even more than sitting down and typing. When dealing with experiments you have a lot of things to ask yourself, what do you know, what do you want to prove, how to do it. Only then you will sit down to write a program that responds to your needs.

If you build something that cannot be expanded, it will become useless very soon. When you don’t really know what may happen with your code, you should think ahead and structure it as an onion, in layers. I am not claiming that it is something that happens naturally, but you can develop your own set of procedures to ensure that you are developing future-proof code. Once you get the handle on it, it won’t take you longer than being disorganized and not having the proper structure. Variables that are not self-descriptive, lack comments, and the list goes on and on.

It is not all about being future-proof. When you start with a simple task at hand, you want to solve it quickly and not spending hours developing useless lines of code just thinking what if. I am all in for that kind of solutions; however, a strong foundation is always important. Taking shortcuts just because you don’t want to create a separated file will give you more headaches even in the short term. You should build code that is robust enough to support for expansion later on. In the same way that you take steps while performing an experiment, you should take steps when developing software.

One of the key elements to achieve a great onion-like approach in Python is to use classes. They are concise elements with clear functionality and very easy to document. They can be imported and even expanded without changing the original code, as we will see by the end of this chapter. If you come from the data analysis world, it may very well be that you never developed your own classes, but this is about to change with this book. You shouldn’t be afraid of them; you should just try to understand them because I can guarantee that once you get the handle of the, you won’t be able to stop thinking in their own terms.

I will not make special emphasis on why I ask you to do the things in a certain way throughout the book. However, if you pay attention you will notice that each step is incremental. You won’t have to start all over again to add a new feature that you didn’t think about. And this ends up being easy because the foundation given by the previous step is very solid. I am not saying that there is only one way of achieving the same results, but I will be just showing you a way of doing things. When you have the chance to improve something without much effort, you should take it, you will be very grateful to your past self.

In the end, all the common practices and development patterns that I can show you, are thought just to make you save time not only in the long run but also next week. I have, just as you are about to do, started developing software for acquiring a very simple signal, an analog input generated by a photodiode. It didn’t take long until I wanted to move a piezo stage with an analog output and suddenly I needed a way of doing 2D and 3D scans of my sample. Sadly for me, there was no one around who could show me a way to being organized and clear with my code.

This book is based not only on my own experiences working in different labs but also on the experiences of the people who surrounded me, who received my code. Sometimes we cannot anticipate the ramifications that our work will have, but I can assure to you that if you start like a small onion, layer by layer, each new path that opens up will be very satisfying. 

\section{Where to get the code}
The code that you are going to develop in this book is freely available on Github (\url{https://github.com/PFTL/SimpleDaq}). We encourage you not to look for the solution ahead of time. The code is there in order to give you the chance to explore alternatives. For example, the online code is well documented. You can see how we have decided to add comments in order to implement the same solutions on your programs. If you are experienced with Python, you can directly study the code to see how we solved some of the common problems people encounter in the lab. 

If you have found any errors, or would like to contact us, please send an e-mail to courses@uetke.com. We will come back to you as soon as possible. 

\section{Organizing a Python for the Lab Workshop}
Python for the Lab was born with the intention of bringing together researchers working in a lab and the Python programming language. With that goal in mind, we developed not only this book, but also a workshop in which we can train scientitsts. The workshops change in duration and content, and there is always the possibility to adapt them to the specific needs of your group. 

If you would like to organize a Python for the Lab workshop at your institution, contact us at courses@uetke.com and we will gladly discuss with you different options. You can also find more information about the courses at https://www.uetke.com/courses.
