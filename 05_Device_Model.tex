\chapter{Writing a Model for the Device}\label{ch:device-model}

\section{Introduction}\label{sec:device-model-introduction}
The secret to successfully develop a model for a device is to think. We need to know what we expect from the device, how are we planning to use it. The first time we start thinking about models, it can become complicated because we need to anticipate our future needs. For example, the {PFTL DAQ} device doesn't handle units. It would be great if the Model would allow us to specify the output voltage instead of converting it to an integer because it is what the driver uses. This requirement seems trivial and probably is the first one that comes to mind. Later, once you start using the program, you can see that some other useful options were missing, and you could have saved much time if you would have thought about them.

There is no magical recipe to teach precisely how to develop models for devices. Each device and each experiment is unique; the best we can do is to focus on the task at hand. We can extrapolate the rest to other devices and experiments. Once you understand the role that models play, you can use them for very different purposes, without needing to re-write the entire program. With a simple device and a simple experiment, the gain of having models separated from controllers may not be immediate. Still, as soon as the complexity grows, the value becomes apparent.

\warningInfo{Device Manuals}{It is impossible to overestimate the importance of reading the manuals of your devices. Hardware in the lab is not the same as consumer hardware. Things can break, signals may not make sense. Be always sure to understand the limits under which each component operates.}

\section{Device Model}\label{sec:device-model}
We must first thing how do we want to interact with that particular device. Of course, we would like to initialize it, set a voltage, read a voltage, and finalize the device. But we don't want just to repeat what the Controller can do. When we initialize or finalize the device, we want to be sure the output voltages are at $0\,\textrm{V}$. In this way, we can ensure that no current flows through the LED unless we explicitly want it. We also want to be able to use values in volts when setting an output, and getting values in volts when reading a voltage.

We can develop a skeleton of the Model. We can use empty methods to have an idea of what we need to develop and the arguments and outputs of each method. Let's start by creating a file \textbf{analog\_daq.py} in the \emph{Model} folder, we can then add the following code:

\begin{minted}{python}
class AnalogDaq:
    def __init__(self, port):
        pass

    def initialize(self):
        pass

    def get_voltage(self, channel):
        pass

    def set_voltage(self, channel, volts):
        pass

    def finalize(self):
        pass
\end{minted}

Now we can start step by step. We start very similarly to how we started the Controller; the \py{AnalogDaq} class takes port as an argument for initializing. The main difference is that we don't use PySerial directly, but we use the Controller. We can start improving our code, like this:

\begin{minted}{python}
from PythonForTheLab.Controller.pftl_daq import Device

class AnalogDaq:
    def __init__(self, port):
        self.port = port
        self.driver = Device(self.port)

    def initialize(self):
        self.driver.initialize()
        self.set_voltage(0, 0)
        self.set_voltage(1, 0)
\end{minted}

We initialize the class by storing the \py{port} and by creating a \py{self.driver} attribute. Remember that the \py{Device} has a separate method for initializing. The \py{initialize} method now not only initializes the the driver itself, but also sets the output voltages to 0. We haven't developed a way of setting voltaes, yet, but we see the flow. The same works for the \py{finalize} method:

\begin{minted}{python}
    def finalize(self):
        self.set_voltage(0, 0)
        self.set_voltage(1, 0)
        self.driver.finalize()
\end{minted}

We first set the voltages to $0$, and then we finalize the Controller. This is a clear example of our own logic imposed on the device. In some cases, we don't want to set the voltage to 0 when closing the communication. Perhaps we are just switching on a laser, and we want it to stay on even if we switch off the computer, or we are using piezo stages and is not recommended to suddenly shake them by setting a different voltage, it is better just to leave a voltage applied to them. That is why adding these features to the Controller would imply violating the separation of models and controllers. What we do with the voltages is part of the logic, not of the device itself. Now that we have this code, we can also add an example to the end of the file, to show how to use the Model:

\begin{minted}{python}
if __name__ == "__main__":
    daq = AnalogDaq('/dev/ttyACM0')
    daq.initialize()
    print(input_volts)
    daq.finalize()
\end{minted}

The last missing bits are the methods for getting and setting a voltage. What we do in these steps was discussed in Section~\ref{subsec:adc-dca}. To set a voltage, we first need to transform a number in the range $0-3.3$ to an integer in the range $0-4095$ and then we apply it:

\begin{minted}{python}
    def set_voltage(self, channel, volts):
        voltage_bits = volts*4095/3.3
        self.driver.set_analog_output(channel, voltage_bits)
\end{minted}

And we can do the same for the get method:

\begin{minted}{python}
    def get_voltage(self, channel):
        voltage_bits = self.driver.get_analog_input(channel)
        voltage = voltage_bits*3.3/1023
        return voltage
\end{minted}

And that is all that is needed. We can now run the code and see that we are reading voltages and setting voltages. Because of how the experiment works, the values we get at the analog input are going to be very small, in the order of few tens of millivolts, but enough to be detected by the {PFTL DAQ}.

\section{Base Model}\label{sec:base-model}
In this book, we are working with only one device, and therefore we are using only one model. But if we want to make our program compatible with more devices, we need to start developing models for each new device. Since we have one model, it would look reasonable to copy it and adapt the methods based on what the new drivers allow us to do. Another option is to create a base class that all other models inherit. In this way, we know that all the methods are defined, perhaps they don't do anything, but at least they are there.

What we do in this section is not a requirement to keep going, but it is important to show the pattern because sooner or later, when the program grows, it becomes a handy approach. Create a file called \textbf{base\_daq.py} inside the Controller folder, we can add the following code to it:

\begin{minted}{python}
class DAQBase:
    def __init__(self, port):
        self.port = port

    def initialize(self):
        pass

    def get_voltage(self, channel):
        pass

    def set_voltage(self, channel, volts):
        pass

    def finalize(self):
        pass
\end{minted}

This class doesn't do anything by itself. It is only the schematics of what a model should contain. We added \py{pass} after every definition to take care of functions in which nothing happens. We can see that we also specify the arguments that each method takes: initialize takes a port, setting a value takes channel and value, and so forth. In programming, this is also called an API, or Application Programming Interface. The base class defines the interface that all the DAQ models use. There is an initialize method, a get and set analog and a finalize. Just by looking at this simple example, we already know how things are going to work and what do we need to do to make them work.

As an example, let's create a dummy DAQ that can generate random values when requested, and since it is not connected to any real device, it doesn't do anything else. We can add the following code to \textbf{dummy\_daq.py} in the Model folder:

\begin{minted}{python}
from random import random
from PythonForTheLab.Model.base_daq import DAQBase

class DummyDaq(DAQBase):
     def get_analog_value(self, channel):
         return random()
\end{minted}

And if we copy the example code from our real daq, things are still going to work fine:

\begin{minted}{python}
if __name__ == "__main__":
    daq = DummyDaq('/dev/ttyACM0')
    daq.initialize()
    voltage = 3
    daq.set_voltage(0, voltage)
    input_volts = daq.get_voltage(0)
    print(input_volts)
    daq.finalize()
\end{minted}

Of course, when we set a voltage, initialize, or finalize the Model, nothing happens, but when we ask for a value, we get one. You see that the way of using this class is the same as the real Model, and it took us only 3 lines of code to develop. Perhaps in the future you move to a more complex DAQ, such as an oscilloscope. If you maintain the same names for the methods of the Model, everything keeps working in the same way.

\questionInfo{Exercise}{Update the real Model to inherit from the base class}

\section{Adding real units to the code}\label{sec:pint}
The Model for the {PFTL DAQ} device is working great, but it has one problem. It allows us to set the output in volts and reads a value in volts. But if we ever make the mistake of supplying the value in millivolts, the program won't work as expected. In real cases, it is tough to remember the units that every method should take. Sometimes you have very different outputs and inputs, with each one taking different units. Imagine you want to make a periodic signal, perhaps the device asks for the frequency, perhaps for the period.

In Python we can overcome the limitations of working with plain numbers by using a package called \emph{Pint}, that allows us to work with \emph{real} units. Let's quickly see how Pint can be used with a simple example:

\begin{minted}{pycon}
>>> import pint
>>> ur = pint.UnitRegistry()
>>> meter = ur('meter')
>>> b = 5*meter
>>> type(b)
<class 'pint.quantity.build_quantity_class.<locals>.Quantity'>
>>> print(b)
5 meter
>>> c = b.to('inch')
>>> print(c)
196.8503937007874 inch
\end{minted}

First, we import the package and start the \emph{Unit Registry}. In principle, Pint allows us to work with custom-made units, but the fundamental ones are already included in their \emph{Unit Registry}. Then, because of convenience, we define the variable \py{meter}, as actually the unit meter. Finally, we assign the value of \py{5 meters} to \py{b}. In this case, \py{b} is of type \py{Quantity}. Therefore it is not just a number but a number and a unit attached to it. \emph{Pint} allows us to convert between units, and this is how we create the variable \py{c}, which is 5 meters converted to inches. And things can get very interesting:

\begin{minted}{pycon}
 >>> b == c
 True
\end{minted}

Even if the numeric value of \py{b} and \py{c} is different, they are still equal to each other, exactly as we would have imagined. We can also work with more complex units:

\begin{minted}{pycon}
>>> d = c*b
>>> print(d.to('m**2'))
25.0 meter ** 2
>>> print(d.to('in**2'))
38750.07750015501 inch ** 2
>>> t = 2.5*ur('s')
>>> v = c/t
>>> print(v.to('in/s'))
78.74015748031496 inch / second
\end{minted}

So far we have always been transforming between units of the same type, i.e.\ a length in meters to a length in inches, etc. But Pint can also handle combined units such as what happens with voltage, current and resistance:

\begin{minted}{pycon}
>>> current = 5*ur('A')
>>> res = 10*ur('ohm')
>>> voltage = current*res
>>> print(voltage)
50 ampere * ohm
>>> print(voltage.to('V'))
50.0 volt
>>> print(voltage.m_as('mV'))
50000.0
\end{minted}

The snippet above shows you that Pint can understand the relationship between Amperes, Ohms, and Volts. There is one more feature that is important to point out: Pint can parse strings to separate the units from the numbers. For example, we can do the following:

\begin{minted}{pycon}
 >>> current = ur('5 A')
 >>> resistance = ur('10 ohm')
\end{minted}

Being able to parse strings so easily is going to make our life much easier when we will be dealing with user input. Now we have seen how to handle \emph{real} units on our code. However, the device still requires us to set the output using plain numbers. In the context of Pint, just the number, without the units is called the \emph{magnitude}. To get the magnitude out of a quantity, we can do the following:

\begin{minted}{pycon}
 >>> current = ur('5 A')
 >>> current_mag = current.m
 >>> print(current)
 5 ampere
 >>> print(current_mag)
 5
 >>> current_ma = current.m_as('mA')
 >>> print(current_ma)
 5000.0
\end{minted}

We start with a quantity called \py{current} of $5\,\textrm{A}$. If we just append the \py{.m} to the variable, we get the magnitude in whatever unit it is already expressed. If we want to be sure to get the magnitude in a specific unit, we use the command \py{.m_as()}. In our case, we will need to transform the user input to an integer, and we will not need to assume it is in volts, we can transform it to volts before converting it to an integer. The \py{set_voltage} method would look like this:

\begin{minted}{python}
    def set_voltage(self, channel, volts):
        value_volts = volts.m_as('V')
        value_int = round(value_volts / 3.3 * 4095)
        self.driver.set_analog_output(channel, value_int)
\end{minted}

We transform the value to volts and get only the magnitude. Then we transform that value to bits, using the round function to get an integer after the operation. We use that rounded value to set the output on the device. Our program is now very flexible since the user can provide the output value in whatever units she pleases, provided that Pint can transform them into volts.

\questionInfo{Exercise}{Update the method \py{get_voltage} so it generates an in volts. Pay attention to the fact that you need to import Pint and create the unit registry before you define your class to be able to use it.}

We should also update the method for getting a voltage to return a voltage and not a plain number. The code below only shows the parts that have changed or added, not the entire class:

%! Suppress = Ellipsis
\begin{minted}{python}
import pint

ur = pint.UnitRegistry()

[...]

    def get_voltage(self, channel):
        voltage_bits = self.driver.get_analog_input(channel)
        voltage = voltage_bits * ur('3.3V')/1023
        return voltage
\end{minted}

However, we also need to update the \py{initialize} and \py{finalize} methods in order to use units and not plain numbers:

\begin{minted}{python}
    def initialize(self):
        self.driver.initialize()
        self.set_voltage(0, ur('0V'))
        self.set_voltage(1, ur('0V'))

    def finalize(self):
        self.set_voltage(0, ur('0V'))
        self.set_voltage(1, ur('0V'))
        self.driver.finalize()
\end{minted}

The class is complete and we need to update the example code at the bottom of the file in order to use the real units:

\begin{minted}{python}
if __name__ == "__main__":
    daq = AnalogDaq('/dev/ttyACM0')
    daq.initialize()
    voltage = ur('3000mV')
    daq.set_voltage(0, voltage)
    input_volts = daq.get_voltage(0)
    print(input_volts)
    daq.finalize()
\end{minted}

If you are hesitant about the impact that different unit systems can have, there is a great example involving a multi-million dollar satellite\footnote{You can check the article on LA times: https://bit.ly/la-times-mo}. The Mars Climate Orbiter fell from its orbit because engineers from the US failed at using the established units of measure in their software, resulting in a mix of metric and imperial systems.

\section{Testing the DAQ Model}\label{sec:testing-the-daq-model}
At this point, we have a very functional program. We can handle units, we have split the logic of the units from the driver, meaning that we can easily share our code with colleagues or the rest of the world. It is time to test our program. One of the reasons we created the Examples folder was to be able to add extra python files that don't belong to our core program. In the Examples folder, create a file called \textbf{test\_daq.py}, and we can start using the Model to do some measurements:

%! Suppress = Ellipsis
\begin{minted}{python}
import numpy as np
import pint

from PythonForTheLab.Model.analog_daq import AnalogDaq

ur = pint.UnitRegistry()
V = ur('V')

daq = AnalogDaq('/dev/ttyACM0') # <-- Remember to change the port
daq.initialize()
# 11 Values with units in a numpy array... 0, 0.3, 0.6, etc.
volt_range = np.linspace(0, 3, 11) * V
currents = [] # Empty list to store the values

for volt in volt_range:
    daq.set_voltage(0, volt)
    currents.append(daq.get_voltage(0))

print(current)
\end{minted}

We can run the code above, but we will notice that we are printing currents with units of volts. This can be very confusing for someone looking at our results, or even for ourselves. We have to remember that we can transform volts to amperes by deviding them with the resistance we are using. If we have a $100\,\textrm{Ohm}$ resistance, we can do the following:

\begin{minted}{python}
for volt in volt_range:
    daq.set_voltage(0, volt)
    measured_voltage = daq.get_voltage(0)
    current = measured_voltage/ur('100ohm')
    currents.append(current)
\end{minted}

If we run the code with the changes above, we will get the following error:

%! Suppress = Ellipsis
\begin{minted}{python}
 [...]
 ValueError: Cannot operate with Quantity and Quantity of different registries.
\end{minted}

The error is descriptive, but hard to understand without knowing the underlaying principles of Pint. The unit registry is a collection of rules that allows us to transform from one quantity to another. But these rules belong to a unit registry. In principle, two distinct unit registries hold rules for different sets of units. It means that we can't convert units across unit registries. We need to use only one registry throughout the program. Right now, we are creating the registry in two different places: The device model and the example.

Since units belong to the entire program, it could be a good idea to define the unit registry at the root. In other words, we can create it directly in the \textbf{\_\_init\_\_.py} file that we placed in the PythonForTheLab folder:

\begin{minted}{python}
 import pint

 ur = pint.UnitRegistry()
\end{minted}

Every time we want to use units and the unit registry, we can do the following:

\begin{minted}{python}
 from PythonForTheLab import ur
\end{minted}

\questionInfo{Exercise}{Improve DAQ model to use the central unit registry and not one defined locally.}

\questionInfo{Exercise}{Modify the example that we developed for testing the DAQ model, so it uses the central unit registry, and see that it works as expected.}

After completing the exercises above, we should be able to run the example and get the values we wanted. We are getting currents in amperes, we are setting voltages in volts. We are still missing some details, such as saving data, but the core of the measurement is already there.

\section{Appending to the PATH at runtime}\label{sec:appending-path}
In Section~\ref{sec:path}, we have seen how to add the root folder of the project to the computer's PYTHONPATH. It allows Python to find our program and allows us to import the packages and modules very easily. However, altering environment variables in different Operating Systems is not only cumbersome, but it can also lead to unwanted results. For example, we may be overwriting something important if there is any name clash between the program we develop and some other library on the computer.

Therefore, we can go a different route and add the folder to the path directly from within Python. This change is not permanent, and it is in place only while the program runs, but no further. First, we need to learn how to identify the folder we want to add to the path. For this, Python offers a module called \py{os}. The code below looks cumbersome, but we explain it after. We can add the following line at the beginning of the \textbf{test\_daq.py} file:

\begin{minted}{python}
import os

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
\end{minted}

First, \py{__file__} variable is a way of letting Python know we are interested in the current file, which in this case is \py{test_daq.py}. We can start from the inside of the function. First, we get the absolute path to the file, including all the folders to get there. Then, we grab the directory that holds the file, which would be the \emph{Examples} folder. And then, we grab the directory that contains the examples, which in our case is the root folder or \py{base_dir} as we called it.

Next, we need to add the \py{base_dir} to the path. For this, we use another package called \py{sys}, which is a wrapper for the operating system. It means that this package adapts according to which operating system we use to run the program. To add the folder, we only need to do the following:

\begin{minted}{python}
import sys

sys.path.append(base_dir)
\end{minted}

And that is it. It doesn't matter if we modify the PYTHONPATH variable anymore, we can always run the \py{test_daq.py} file.

\warningInfo{The PATH}{Since appending to path only works while the program runs, if we try to run the package files independently, Python does not know where to find the modules. The test files we created in Examples are what are called entry points, and the program should be run directly from them}

\section{Real World Example}\label{sec:real-world-model}
The usefulness of models at this stage may still be obscure. We may be tempted to define units and transformation in the Controller itself. We know we are the only ones using it, just to do one experiment. It may be fine when you start, but at some point, the code grows because the experiment is progressing and getting more complex. As an example, at Python for the Lab, we have developed software for controlling a microscope using a camera. However, there were several cameras available, some more expensive and powerful, and they were all shared between people and experiments.

Therefore, having a flexible way of using different cameras for the same experiment became mandatory. Sometimes we would use a Hamamatsu, sometimes a Basler, sometimes a Photonics Science. However, each camera had an incredibly different way of working. First, Hamamatsu didn't provide any drivers written in Python. Photonics Science shared an internal tool they used, and Basler as an entire package called PyPylon to control their cameras. The controller layer, therefore, was not developed by us but was given.

At the model level, however, we made sure that all cameras would work in the same way. They all have the same method for setting the exposure or changing the region of interest. Therefore, the only thing that we needed to change to run an experiment with one or the other camera was changing what Model we were importing. The rest of the code would stay the same. If you want to see the real code, you can head to the repository on of the UUTrack project\footnote{https://github.com/uetke/UUTrack}.

\section{Conclusions}\label{sec:device-model-conclusions2}
In this chapter, we have seen what does \emph{Model} mean in the {MVC} pattern. We focus on adding features to how the device works, such as switching off the outputs when we finalize using the device. We have also included real-world units by using \textbf{Pint} and learned some of its quirks regarding the unit registry.

We have also covered how to append folders to the path through Python. It allows us to run all the import statements that we want, without having to alter the environment variables of the operating system manually. It is handy because, on the one hand, it runs unaltered in Linux, Windows, and Mac. On the other, we don't make any permanent changes to the configuration of the computer. It is a possibility that at some point we have two projects with the same name, because we use them for two different but very similar experiments, for example, but we want to be sure we are importing the correct one.
