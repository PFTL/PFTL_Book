\chapter{Writing a Model for the Device}\label{ch:device-model}

\section{Introduction}\label{sec:device-model-introduction}
Diligent thought is the key successfully developing a model for a device. You need to know what you expect from the device how you are planning to use it. The first time you start to think about models, it can be quite overwhelming, because you'll need to anticipate your future needs. For example, the {PFTL DAQ} device doesn't handle units. It would be great if the model would allow you to specify the output voltage instead of converting it to an integer, because that's what the driver uses. This requirement seems trivial and is probably the first one that comes to mind. Later, once you start using the program, you'll notice that some other useful options were missing, and you could have saved time had you thought about them.

There's no magical recipe to teach precisely how to develop models for devices. Each device and each experiment is unique; the best you can do is to focus on the task at hand. You can extrapolate the rest to other devices and experiments. Once you understand the role that models play, you can use them for very different purposes, without needing to re-write the entire program. With a simple device and a simple experiment, you may not see immediate gains from having models separated from controllers. Still, as soon as the complexity grows, this value becomes apparent.

\warningInfo{Device Manuals}{It's impossible to overestimate the importance of reading the manuals for your devices. Hardware in the lab is not the same as consumer hardware. Things can break, signals may not make sense, and you could run into a host of other issues. Always be sure that you understand the limits under which your components operate.}

\section{Developing the Device Model}\label{sec:device-model}
You must first thing how do you want to interact with that particular device. Of course, you would like to initialize it, set a voltage, read a voltage, and finalize the device. But you don't want just to repeat what the Controller can do. When you initialize or finalize the device, you want to be sure the output voltages are at $0\,\textrm{V}$. In this way, you can ensure that no current flows through the LED unless you explicitly want it. You also want to be able to use values in volts when setting an output, and getting values in volts when reading a voltage.

You can develop a skeleton of the Model. You can use empty methods to have an idea of what you need to develop and the arguments and outputs of each method. Let's start by creating a file \textbf{analog\_daq.py} in the \emph{Model} folder, you can then add the following code:

\begin{minted}{python}
class AnalogDaq:
    def __init__(self, port):
        pass

    def initialize(self):
        pass

    def get_voltage(self, channel):
        pass

    def set_voltage(self, channel, volts):
        pass

    def finalize(self):
        pass
\end{minted}

Now you can start step by step. You start very similarly to how you started the Controller; the \py{AnalogDaq} class takes port as an argument for initializing. The main difference is that you don't use PySerial directly, but you use the Controller. You can start improving your code, like this:

\begin{minted}{python}
from PythonForTheLab.Controller.pftl_daq import Device

class AnalogDaq:
    def __init__(self, port):
        self.port = port
        self.driver = Device(self.port)

    def initialize(self):
        self.driver.initialize()
        self.set_voltage(0, 0)
        self.set_voltage(1, 0)
\end{minted}

You initialize the class by storing the \py{port} and by creating a \py{self.driver} attribute. Remember that the \py{Device} has a separate method for initializing. The \py{initialize} method now not only initializes the the driver itself, but also sets the output voltages to 0. You haven't developed a way of setting voltaes, yet, but you see the flow. The same works for the \py{finalize} method:

\begin{minted}{python}
    def finalize(self):
        self.set_voltage(0, 0)
        self.set_voltage(1, 0)
        self.driver.finalize()
\end{minted}

You first set the voltages to $0$, and then you finalize the Controller. This is a clear example of your own logic imposed on the device. In some cases, you don't want to set the voltage to 0 when closing the communication. Perhaps you're just switching on a laser, and you want it to stay on even if you switch off the computer, or you're using piezo stages and is not recommended to suddenly shake them by setting a different voltage, it's better just to leave a voltage applied to them. That is why adding these features to the Controller would imply violating the separation of models and controllers. What you do with the voltages is part of the logic, not of the device itself. Now that you have this code, you can also add an example to the end of the file, to show how to use the Model:

\begin{minted}{python}
if __name__ == "__main__":
    daq = AnalogDaq('/dev/ttyACM0')
    daq.initialize()
    print(input_volts)
    daq.finalize()
\end{minted}

The last missing bits are the methods for getting and setting a voltage. What you do in these steps was discussed in Section~\ref{subsec:adc-dca}. To set a voltage, you first need to transform a number in the range $0-3.3$ to an integer in the range $0-4095$ and then you apply it:

\begin{minted}{python}
    def set_voltage(self, channel, volts):
        voltage_bits = volts*4095/3.3
        self.driver.set_analog_output(channel, voltage_bits)
\end{minted}

And you can do the same for the get method:

\begin{minted}{python}
    def get_voltage(self, channel):
        voltage_bits = self.driver.get_analog_input(channel)
        voltage = voltage_bits*3.3/1023
        return voltage
\end{minted}

And that is all that is needed. You can now run the code and see that you're reading voltages and setting voltages. Because of how the experiment works, the values you get at the analog input are going to be very small, in the order of few tens of millivolts, but enough to be detected by the {PFTL DAQ}.

\section{Developing the Base Model}\label{sec:base-model}
In this book, you're working with only one device, and therefore you're using only one model. But if you want to make your program compatible with more devices, you need to start developing models for each new device. Since you have one model, it would look reasonable to copy it and adapt the methods based on what the new drivers allow us to do. Another option is to create a base class that all other models inherit. In this way, you know that all the methods are defined, perhaps they don't do anything, but at least they are there.

What you do in this section is not a requirement to keep going, but it's important to show the pattern because sooner or later, when the program grows, it becomes a handy approach. Create a file called \textbf{base\_daq.py} inside the Controller folder, you can add the following code to it:

\begin{minted}{python}
class DAQBase:
    def __init__(self, port):
        self.port = port

    def initialize(self):
        pass

    def get_voltage(self, channel):
        pass

    def set_voltage(self, channel, volts):
        pass

    def finalize(self):
        pass
\end{minted}

This class doesn't do anything by itself. It's only the schematics of what a model should contain. You added \py{pass} after every definition to take care of functions in which nothing happens. You can see that you also specify the arguments that each method takes: initialize takes a port, setting a value takes channel and value, and so forth. In programming, this is also called an API, or Application Programming Interface. The base class defines the interface that all the DAQ models use. There's an initialize method, a get and set analog and a finalize. Just by looking at this simple example, you already know how things are going to work and what do you need to do to make them work.

As an example, let's create a dummy DAQ that can generate random values when requested, and since it's not connected to any real device, it doesn't do anything else. You can add the following code to \textbf{dummy\_daq.py} in the Model folder:

\begin{minted}{python}
from random import random
from PythonForTheLab.Model.base_daq import DAQBase

class DummyDaq(DAQBase):
     def get_analog_value(self, channel):
         return random()
\end{minted}

And if you copy the example code from your real daq, things are still going to work fine:

\begin{minted}{python}
if __name__ == "__main__":
    daq = DummyDaq('/dev/ttyACM0')
    daq.initialize()
    voltage = 3
    daq.set_voltage(0, voltage)
    input_volts = daq.get_voltage(0)
    print(input_volts)
    daq.finalize()
\end{minted}

Of course, when you set a voltage, initialize, or finalize the Model, nothing happens, but when you ask for a value, you get one. You see that the way of using this class is the same as the real Model, and it took us only 3 lines of code to develop. Perhaps in the future you move to a more complex DAQ, such as an oscilloscope. If you maintain the same names for the methods of the Model, everything keeps working in the same way.

\questionInfo{Exercise}{Update the real Model to inherit from the base class}

\section{Adding Real Units to the Code}\label{sec:pint}
The Model for the {PFTL DAQ} device is working great, but it has one problem. It allows us to set the output in volts and reads a value in volts. But if you ever make the mistake of supplying the value in millivolts, the program won't work as expected. In real cases, it's tough to remember the units that every method should take. Sometimes you have very different outputs and inputs, with each one taking different units. Imagine you want to make a periodic signal, perhaps the device asks for the frequency, perhaps for the period.

In Python you can overcome the limitations of working with plain numbers by using a package called \emph{Pint}, that allows us to work with \emph{real} units. Let's quickly see how Pint can be used with a simple example:

\begin{minted}{pycon}
>>> import pint
>>> ur = pint.UnitRegistry()
>>> meter = ur('meter')
>>> b = 5*meter
>>> type(b)
<class 'pint.quantity.build_quantity_class.<locals>.Quantity'>
>>> print(b)
5 meter
>>> c = b.to('inch')
>>> print(c)
196.8503937007874 inch
\end{minted}

First, you import the package and start the \emph{Unit Registry}. In principle, Pint allows us to work with custom-made units, but the fundamental ones are already included in their \emph{Unit Registry}. Then, because of convenience, you define the variable \py{meter}, as actually the unit meter. Finally, you assign the value of \py{5 meters} to \py{b}. In this case, \py{b} is of type \py{Quantity}. Therefore it's not just a number but a number and a unit attached to it. \emph{Pint} allows us to convert between units, and this is how you create the variable \py{c}, which is 5 meters converted to inches. And things can get very interesting:

\begin{minted}{pycon}
 >>> b == c
 True
\end{minted}

Even if the numeric value of \py{b} and \py{c} is different, they are still equal to each other, exactly as you would have imagined. You can also work with more complex units:

\begin{minted}{pycon}
>>> d = c*b
>>> print(d.to('m**2'))
25.0 meter ** 2
>>> print(d.to('in**2'))
38750.07750015501 inch ** 2
>>> t = 2.5*ur('s')
>>> v = c/t
>>> print(v.to('in/s'))
78.74015748031496 inch / second
\end{minted}

So far you have always been transforming between units of the same type, i.e.\ a length in meters to a length in inches, etc. But Pint can also handle combined units such as what happens with voltage, current and resistance:

\begin{minted}{pycon}
>>> current = 5*ur('A')
>>> res = 10*ur('ohm')
>>> voltage = current*res
>>> print(voltage)
50 ampere * ohm
>>> print(voltage.to('V'))
50.0 volt
>>> print(voltage.m_as('mV'))
50000.0
\end{minted}

The snippet above shows you that Pint can understand the relationship between Amperes, Ohms, and Volts. There's one more feature that is important to point out: Pint can parse strings to separate the units from the numbers. For example, you can do the following:

\begin{minted}{pycon}
 >>> current = ur('5 A')
 >>> resistance = ur('10 ohm')
\end{minted}

Being able to parse strings so easily is going to make your life much easier when you will be dealing with user input. Now you have seen how to handle \emph{real} units on your code. However, the device still requires us to set the output using plain numbers. In the context of Pint, just the number, without the units is called the \emph{magnitude}. To get the magnitude out of a quantity, you can do the following:

\begin{minted}{pycon}
 >>> current = ur('5 A')
 >>> current_mag = current.m
 >>> print(current)
 5 ampere
 >>> print(current_mag)
 5
 >>> current_ma = current.m_as('mA')
 >>> print(current_ma)
 5000.0
\end{minted}

You start with a quantity called \py{current} of $5\,\textrm{A}$. If you just append the \py{.m} to the variable, you get the magnitude in whatever unit it's already expressed. If you want to be sure to get the magnitude in a specific unit, you use the command \py{.m_as()}. In your case, you will need to transform the user input to an integer, and you will not need to assume it's in volts, you can transform it to volts before converting it to an integer. The \py{set_voltage} method would look like this:

\begin{minted}{python}
    def set_voltage(self, channel, volts):
        value_volts = volts.m_as('V')
        value_int = round(value_volts / 3.3 * 4095)
        self.driver.set_analog_output(channel, value_int)
\end{minted}

You transform the value to volts and get only the magnitude. Then you transform that value to bits, using the round function to get an integer after the operation. You use that rounded value to set the output on the device. Our program is now very flexible since the user can provide the output value in whatever units she pleases, provided that Pint can transform them into volts.

\questionInfo{Exercise}{Update the method \py{get_voltage} so it generates an in volts. Pay attention to the fact that you need to import Pint and create the unit registry before you define your class to be able to use it.}

You should also update the method for getting a voltage to return a voltage and not a plain number. The code below only shows the parts that have changed or added, not the entire class:

%! Suppress = Ellipsis
\begin{minted}{python}
import pint

ur = pint.UnitRegistry()

[...]

    def get_voltage(self, channel):
        voltage_bits = self.driver.get_analog_input(channel)
        voltage = voltage_bits * ur('3.3V')/1023
        return voltage
\end{minted}

However, you also need to update the \py{initialize} and \py{finalize} methods in order to use units and not plain numbers:

\begin{minted}{python}
    def initialize(self):
        self.driver.initialize()
        self.set_voltage(0, ur('0V'))
        self.set_voltage(1, ur('0V'))

    def finalize(self):
        self.set_voltage(0, ur('0V'))
        self.set_voltage(1, ur('0V'))
        self.driver.finalize()
\end{minted}

The class is complete and you need to update the example code at the bottom of the file in order to use the real units:

\begin{minted}{python}
if __name__ == "__main__":
    daq = AnalogDaq('/dev/ttyACM0')
    daq.initialize()
    voltage = ur('3000mV')
    daq.set_voltage(0, voltage)
    input_volts = daq.get_voltage(0)
    print(input_volts)
    daq.finalize()
\end{minted}

If you're hesitant about the impact that different unit systems can have, there's a great example involving a multi-million dollar satellite\footnote{You can check the article on LA times: https://bit.ly/la-times-mo}. The Mars Climate Orbiter fell from its orbit because engineers from the US failed at using the established units of measure in their software, resulting in a mix of metric and imperial systems.

\section{Testing the DAQ Model}\label{sec:testing-the-daq-model}
At this point, you have a very functional program. You can handle units, you have split the logic of the units from the driver, meaning that you can easily share your code with colleagues or the rest of the world. It's time to test your program. One of the reasons you created the Examples folder was to be able to add extra python files that don't belong to your core program. In the Examples folder, create a file called \textbf{test\_daq.py}, and you can start using the Model to do some measurements:

%! Suppress = Ellipsis
\begin{minted}{python}
import numpy as np
import pint

from PythonForTheLab.Model.analog_daq import AnalogDaq

ur = pint.UnitRegistry()
V = ur('V')

daq = AnalogDaq('/dev/ttyACM0') # <-- Remember to change the port
daq.initialize()
# 11 Values with units in a numpy array... 0, 0.3, 0.6, etc.
volt_range = np.linspace(0, 3, 11) * V
currents = [] # Empty list to store the values

for volt in volt_range:
    daq.set_voltage(0, volt)
    currents.append(daq.get_voltage(0))

print(current)
\end{minted}

You can run the code above, but you will notice that you're printing currents with units of volts. This can be very confusing for someone looking at your results, or even for ourselves. You have to remember that you can transform volts to amperes by deviding them with the resistance you're using. If you have a $100\,\textrm{Ohm}$ resistance, you can do the following:

\begin{minted}{python}
for volt in volt_range:
    daq.set_voltage(0, volt)
    measured_voltage = daq.get_voltage(0)
    current = measured_voltage/ur('100ohm')
    currents.append(current)
\end{minted}

If you run the code with the changes above, you will get the following error:

%! Suppress = Ellipsis
\begin{minted}{python}
 [...]
 ValueError: Cannot operate with Quantity and Quantity of different registries.
\end{minted}

The error is descriptive, but hard to understand without knowing the underlaying principles of Pint. The unit registry is a collection of rules that allows us to transform from one quantity to another. But these rules belong to a unit registry. In principle, two distinct unit registries hold rules for different sets of units. It means that you can't convert units across unit registries. You need to use only one registry throughout the program. Right now, you're creating the registry in two different places: The device model and the example.

Since units belong to the entire program, it could be a good idea to define the unit registry at the root. In other words, you can create it directly in the \textbf{\_\_init\_\_.py} file that you placed in the PythonForTheLab folder:

\begin{minted}{python}
 import pint

 ur = pint.UnitRegistry()
\end{minted}

Every time you want to use units and the unit registry, you can do the following:

\begin{minted}{python}
 from PythonForTheLab import ur
\end{minted}

\questionInfo{Exercise}{Improve DAQ model to use the central unit registry and not one defined locally.}

\questionInfo{Exercise}{Modify the example that you developed for testing the DAQ model, so it uses the central unit registry, and see that it works as expected.}

After completing the exercises above, you should be able to run the example and get the values you wanted. You're getting currents in amperes, you're setting voltages in volts. You're still missing some details, such as saving data, but the core of the measurement is already there.

\section{Appending to the PATH at Runtime}\label{sec:appending-path}
In Section~\ref{sec:path}, you have seen how to add the root folder of the project to the computer's PYTHONPATH. It allows Python to find your program and allows us to import the packages and modules very easily. However, altering environment variables in different Operating Systems is not only cumbersome, but it can also lead to unwanted results. For example, you may be overwriting something important if there's any name clash between the program you develop and some other library on the computer.

Therefore, you can go a different route and add the folder to the path directly from within Python. This change is not permanent, and it's in place only while the program runs, but no further. First, you need to learn how to identify the folder you want to add to the path. For this, Python offers a module called \py{os}. The code below looks cumbersome, but you explain it after. You can add the following line at the beginning of the \textbf{test\_daq.py} file:

\begin{minted}{python}
import os

base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
\end{minted}

First, \py{__file__} variable is a way of letting Python know you're interested in the current file, which in this case is \py{test_daq.py}. You can start from the inside of the function. First, you get the absolute path to the file, including all the folders to get there. Then, you grab the directory that holds the file, which would be the \emph{Examples} folder. And then, you grab the directory that contains the examples, which in your case is the root folder or \py{base_dir} as you called it.

Next, you need to add the \py{base_dir} to the path. For this, you use another package called \py{sys}, which is a wrapper for the operating system. It means that this package adapts according to which operating system you use to run the program. To add the folder, you only need to do the following:

\begin{minted}{python}
import sys

sys.path.append(base_dir)
\end{minted}

And that is it. It doesn't matter if you modify the PYTHONPATH variable anymore, you can always run the \py{test_daq.py} file.

\warningInfo{The PATH}{Since appending to path only works while the program runs, if you try to run the package files independently, Python does not know where to find the modules. The test files you created in Examples are what are called entry points, and the program should be run directly from them}

\section{Brainstorming a Real World Example}\label{sec:real-world-model}
The usefulness of models at this stage may still be obscure. You may be tempted to define units and transformation in the Controller itself. You know you're the only ones using it, just to do one experiment. It may be fine when you start, but at some point, the code grows because the experiment is progressing and getting more complex. As an example, at Python for the Lab, you have developed software for controlling a microscope using a camera. However, there were several cameras available, some more expensive and powerful, and they were all shared between people and experiments.

Therefore, having a flexible way of using different cameras for the same experiment became mandatory. Sometimes you would use a Hamamatsu, sometimes a Basler, sometimes a Photonics Science. However, each camera had an incredibly different way of working. First, Hamamatsu didn't provide any drivers written in Python. Photonics Science shared an internal tool they used, and Basler as an entire package called PyPylon to control their cameras. The controller layer, therefore, was not developed by us but was given.

At the model level, however, you made sure that all cameras would work in the same way. They all have the same method for setting the exposure or changing the region of interest. Therefore, the only thing that you needed to change to run an experiment with one or the other camera was changing what Model you were importing. The rest of the code would stay the same. If you want to see the real code, you can head to the repository on of the UUTrack project\footnote{https://github.com/uetke/UUTrack}.

\section{Conclusions}\label{sec:device-model-conclusions2}
In this chapter, you have seen what does \emph{Model} mean in the {MVC} pattern. You focus on adding features to how the device works, such as switching off the outputs when you finalize using the device. You have also included real-world units by using \textbf{Pint} and learned some of its quirks regarding the unit registry.

You have also covered how to append folders to the path through Python. It allows us to run all the import statements that you want, without having to alter the environment variables of the operating system manually. It's handy because, on the one hand, it runs unaltered in Linux, Windows, and Mac. On the other, you don't make any permanent changes to the configuration of the computer. It's a possibility that at some point you have two projects with the same name, because you use them for two different but very similar experiments, for example, but you want to be sure you're importing the correct one.
