\chapter{Run an experiment}\label{chapter:run-experiment}


\section{Introduction}
In the previous chapter, we have seen how to develop an experiment model and how to use it from a simple script. In this chapter we are going to explore how to bring it to the next level. So far we can run the experiment only with the parameters specified on the config file, but we are not limited to them. Moreover, once the scan starts, there is no way of stopping it unless we completely stop the program. That leads to missing data and is not particularly helpful.

Following the \emph{Onion Principle}, it is now time to bring the experiment model to the next level.


\section{Running an Experiment}\label{section:running-nexperiment}
In the previous chapter we have seen that an experiment can be run from a simple script in which each of the steps needed are triggered one after the other. We called that script \textbf{run\_experiment.py} and had the following code (skipping some less relevant lines):

\begin{minted}{python}
    from PythonForTheLab.Model import Experiment

    experiment = Experiment('experiment.yml')
    experiment.load_config()

    experiment.load_daq()

    experiment.do_scan()
    experiment.save_data()
    experiment.finalize()
\end{minted}

This is relatively straightforward, but not the only thing that can be done with the experiment. We can access the attributes of the experiment class while we permorming a measurement. For example, we could show the data once the scan is completed:

\begin{minted}{python}
    experiment.do_scan()
    print(experiment.scan_data)
\end{minted}

But we could also change the parameters of the scan after loading the config file. Sharing information with classes in Python is always two ways: we can read from them, but we can also write to them. Let's see what happens when we change the \texttt{config} attribute of the experiment before triggering the scan. We can do something like the following:

\begin{minted}{python}
    [...]

    experiment.config['Scan']['num_steps'] = 5
    experiment.do_scan()
    experiment.save_data()
    experiment.config['Scan']['num_steps'] = 10
    experiment.do_scan()
    experiment.save_data()
    experiment.finalize()
\end{minted}

Any of the values stored in the \texttt{config} of the experiment can be changed at any time. It can be changed from a script, it could be changed from the running script. We are not limited to running the experiment from a script, we can also run it from the Python interpreter. The steps would be the same. For people familiar with Jupyter notebooks, for example, the experiments can be run directly from within them. There are some extra benefits of using notebooks, such as the possibility of documenting the work, but we leave the discussion for the Advanced Python for the Lab book.

\note{Running from the Python interpreter is normally cumbersome. There is another version of the interpreter called \textbf{bpython} which has auto-complete functions, as well as it allows you to edit code before running it. We don't encourage people to run experiments from the interpreter, but some times it is the handiest solution to change values when desired.}

In the code above, we have changed the value of the number of steps before triggering a scan. First we have set it to 5 steps and then to 10 steps. We can check the metadata and we will see that this information was actually saved. If we open the data file, we would also see a different number of data points. This flow proposes very interesting possibilities. For example, if we would like to see if there is any form of hysteresis on the measurements, we could vary the delay between data points.

\exercise{Write a for-loop that changes the delay between data points after each scan. Remember to save the data in order to explore the differences}

If we start developing complex logic in the running script, it is fair to wonder if it is better putting all that logic into the experiment class. As always, when we do things only once, knowing they'll be one-off tasks, then it is quicker to run from a script. If, however, that one-off becomes an essential part of our experiments, or we believe that others could benefit from doing the same measurement, then we should implement the code in the class. As always, common sense is the best ally for a scientific developer.

One of the important things to note is that when we work with units, we leave the values as string, and only transform them to real quantities when we need them. If we explore the \texttt{do\_scan} method, we would see that we start by running the parameters through the unit registry. This means that if we want to change the values of, for example, the start, stop, or delay we only need to change a string:

\begin{minted}{python}
    experiment.config['Scan']['start'] = '2.2V'
    experiment.config['Scan']['delay'] = '200ms'
\end{minted}

\section{Plotting Scan Data}\label{section:plotting}
We have seen how to perform a measurement, how to change the parameters of the scan without changing the config file, and how to save data. However, we are not doing anything with the data after we save it. Being able to see what we are doing through a plot seems a very nice addition to our work flow. For plotting we are going to use a library called \href{http://www.pyqtgraph.org/}{PyQtGraph} which was developed mainly to generate fast data visualizations. Exactly what we need when we are dealing with experiments. Normally, people a bit more familiar with Python get acquainted with matplotlib, which is a great tool for paper-ready plots, but a bit slow for real-time visualization. In any case, at this stage we don't care about speed, therefore if you more confident with another tool, feel more free to adapt the code to use them. In any case, PyQtGraph will come back later, when we build the user interface.

Making a simple plot with PyQtGraph is very easy. We can add the following after we perform the scan, in the \textbf{run\_experiment.py} script file:

\begin{minted}{python}
    import pyqtgraph as pg

    [...]

    pg.plot(experiment.scan_range, experiment.scan_data)
\end{minted}

It is simple, but it works. PyQtGraph also gives us some mouse interactions out of the box. We can drag the image, we can zoom in and out with the mouse wheel, we can also transform the scale of the axes by right-clicking. We can make the plot a bit better looking by adding labels and a title:

\begin{minted}{python}
    PlotWidget = pg.plot(title="Plotting I vs V")
    PlotWidget.setLabel('bottom', f'Channel: {experiment.config['Scan']['channel_out']}', units="V")
    PlotWidget.setLabel('left', f'Channel: {experiment.config['Scan']['channel_in']}', units="V")
    PlotWidget.plot(experiment.scan_values, experiment.scan_data)
\end{minted}

Plotting with PyQtGraph is relatively simple. However, we can only plot data after the scan is finished. The \texttt{do\_scan} method takes relatively long to complete. When a method, or a function, work in this way, they are called blocking functions. The program can't continue until they finish. If we would like to monitor the progress of the experiment while running, we need to find a way of making the scan in a non-blocking way.

\section{Running the scan in a nonblocking way}\label{section:nonblocking}
Methods or functions like \texttt{do\_scan} take a long time to run. Imagine if we would like to acquire a movie for one hour, the function would take one hour to complete. If we would be running a very complex simulation or data analysis process, functions can also take very long to complete. However, both scenarios are different from each other. Sometimes functions take long to execute because they are computationally expensive. They need a lot of cycles of the processor in order to finish. Sometimes they take long to execute because the process is slow. For instance, when we do a scan, most of the time the program is waiting in a \texttt{python}{sleep}, or is waiting for the device to read a signal and transfer it to the computer. Waiting is not computationally expensive, which means that our computer is able to perform other tasks at the same time if we know how.

Python has different options for achieving what we are after, but the one that gives best results, not only in terms of flexibility, but also in terms of simplicity to implement is the \emph{multithreading} module\footnote{Another library which is gaining popularity is AsyncIO. It is, however, harder to implement efficiently for our purposes}.

\subsection{Threads in Python}\label{subsection:multithreading}
All threads have two ends. A computer program always starts going through a thread in the same direction, until it reaches its end. Sometimes, along the thread a task blocks the progress, and the program halts there for some time. What Python allows us to do is to start other threads at any point in time. The more threads we have, the more entangled the program would be. Python, however, will not run the threads at the same time. There is a tool calle the Global Interpreter Lock (or GIL), which prevents two things to happen simoultaneusly.

What Python does is run small pieces of each thread one after the other. Someone once compared it to a super efficient secretary, who pushes jobs according to who has free time and who has tasks to perform. This means that two computations won't happen exactly at the same time, but if one thread is, for example, waiting on a \texttt{sleep}, Python can go and let another thread run. Whenever we start Python, we are starting a thread, also called \emph{main thread}, that will live through our program. From that thread we can start a second one, as we do in the code below:

\begin{minted}{python}
    import threading
    from time import sleep

    def func(steps):
        for i in range(steps):
            sleep(1)
            print('Step: {}'.format(i))

    t = threading.Thread(target=func, args=(3, ))
    print('Here')
    t.start()
    sleep(2)
    print('There')
\end{minted}

If we run it, we get the following output:

\begin{minted}{text}
    Here
    Step: 0
    Step: 1
    There
    Step: 2
\end{minted}

It is very important to understand what is happening in the code above, so we can go step by step dissecting it. If we run the function \texttt{func} on its own, we will see that the numbers appear one by one. We would also notice that while the function is running, nothing else would happen. However, in the code above, we can se a \texttt{'There'} being printed in between the output of the function. This means that we managed to trigger the function and it didn't stop the execution of the rest of the program.

When we used \texttt{threading.Thread}, we were creating a new child thread. The \texttt{target} is whatever function we want to run on that thread. We can also pass arguments, as we did, using \texttt{args=(3, )}. Once we created the thread, we have to start it by doing \texttt{t.start()}. Note that the \texttt{target} is \texttt{func} and not \texttt{func()}. If we would use \texttt{func()}, we would be using the result of the function, and not the function itself. Therefore, there wouldn't be much to gain from the thread.

\warning{It is very important to distinguish the proper function from its output. What we can put to run on a separate thread is a function, and therefore we use \texttt{target=func}. If we call the function, we would be sending its output to a thread, which is not useful. If things don't seem to work, check whether there is a pair of \texttt{()} that is not supposed to be there.}

Another common pitfal is forgetting the \texttt{start()}. When we create a new thread, the function is not executed but it will be waiting until the \texttt{start()} signal is triggered. That is why we first see \texttt{'Here'} being printed, then some steps. With such a simple example it is always a good idea to change the parameters to see how they affect the output printed to screen, what happens first, second, etc.

We can also have several threads running the same function at the same time. In the example below you can see how easy it is:

\begin{minted}{python}
    first_t = threading.Thread(target=func, args=(3, ))
    second_t = threading.Thread(target=func, args=(3, ))
    print('Here')
    first_t.start()
    second_t.start()
    sleep(1)
    first_t.join()
    second_t.join()
    print('There')
\end{minted}

Starting two threads is as simple as starting one. We have added one extra detail to our code, we have used \texttt{join()} in order to wait for the threads to complete. Now we can see that \texttt{'There'} is printed only after the function finishes. Using \texttt{join()} is normally a good idea in order not to finish the program and leave some orfaned threads.

\note{The fact that things can happen more or less at the same time does not mean our code is running in parallel. Threads have been around for a very, very long time. Even in single-core computers, we were able to switch from one program to another, we could get e-mails while browsing the internet. This was the operating system taking care of executing bits of each program to keep them all up to date. Parallelizing means running computations at the same time. In multi-core processors like the ones available in most computers and cell phones today, we are actually able to split tasks and run them at the same time in different cores. For really running on different cores, Python offers the \emph{multiprocessing} package. However, multiprocessing is challenging. The Advanced Python for the Lab coves in detail how to leverage it for larger and more data-consuming experiments.}

\section{Threads for the experiment model}\label{section:threads-experiment-model}
We have seen how to run a very simple function on a different thread. But we can also see that more complex functions do not present a challenge. Going back to the experiment model, we can already test what we have learned by running the \texttt{do\_scan} method on its own thread. Since the method doesn't take any arguments, the code would simple look like this:

\begin{minted}{python}
    t = threading.Thread(target=experiment.do_scan)
    t.start()
\end{minted}

While the scan is running in its own thread, we can do other things in the main thread, such as plotting. We need to refresh the plot while the acquisition is happening, and therefore we will need to update the plot within a loop. Combining what we have seen so far, we can update the \textbf{run\_experiment.py} file:

\begin{minted}{python}
    import threading
    import pyqtgraph as pg
    from time import sleep
    from PythonForTheLab.Model import Experiment

    experiment = Experiment('experiment.yml')
    experiment.load_config()
    experiment.load_daq()
    t = threading.Thread(target=experiment.do_scan)
    t.start()

    PlotWidget = pg.plot(title="Plotting I vs V")
    PlotWidget.setLabel('bottom', f'Channel: {experiment.config['Scan']['channel_out']}', units="V")
    PlotWidget.setLabel('left', f'Channel: {experiment.config['Scan']['channel_in']}', units="V")

    while t.isAlive():
        PlotWidget.plot(experiment.scan_values, experiment.scan_data, clear=True)
        pg.QtGui.QApplication.processEvents()
        sleep(.1)

    experiment.finalize()
\end{minted}

The beginning of the code is exactly the same. The only difference is that we trigger the scan inside its own thread. After starting it, we create a plot exactly in the same way we did before. The important part is the \texttt{while} loop. First, we check whether the thread is still running with the \texttt{isAlive()} method. If the thread is not running, it means the scan has finished. Then, within the loop, we update the plot with the data available in the experiment class. It is very important to note that even if the \texttt{do\_scan} method is running in a different thread, its data is accessible from the main thread. The extra line with the \texttt{QApplication} is necessary to make things work, but not important, and since we are not going to follow this approach, we will not discuss it further.

Exchanging information between threads is a topic that has to be handled with care. Right now we have two threads: the main thread, in which we define the experiment and the plot, and we have a child thread, in which the scan is happening. However, for a scan to happen, the thread needs to have a copy of the experiment itself. It turns out that is not just a copy, but the experiment is exactly the same object on both threads. That is why, if the child thread modifies the values of \texttt{scan\_data}, for example, the main thread can see them. But data is not the only thing being shared. The experiment holds the communication with the {PFTL DAQ} device. This communication is open from both the main and the child threads. Nothing prevents us from triggering two scans at the same time:

\begin{minted}{python}
    scan1 = threading.Thread(target=experiment.do_scan)
    scan2 = threading.Thread(target=experiment.do_scan)
    scan1.start()
    scan2.start()
\end{minted}

If we do something like this, we will see the inherent problem of working with threads carelessly. Each scan has a for-loop, in which the output voltage will be set to a given value and then another voltage will be read. In the best case scenario, when one thread sets the value, the other will change it and the voltage read will correspond to the second one. In the worst case scenario, the information transmitted to and from the device will be split. This means that the bytes being transmitted to and from the device can end up intercalated. This corrupts the data and can lead to crashes or the device going beyond the specified range of voltages.

We are not going to enter into the details of all the possible solutions to prevent this problems from appearing. The threading package has a lot of tools to make our programs \emph{thread-safe}. However, we also have to find a balance between how complex we want to make our solution and how much we can trust that we won't make these kind of mistakes. We will use a very simple approach that will prevent us from triggering a second scan if one is already running. That is actually a likely scenario if we don't realize a scan is taking place. The solution is actually relatively easy: when the scan is running, we set a variable to \texttt{True}. Every time we want to start a new scan, we check the variable, and prevent the program from going further if it a scan is already happening. We must edit the \texttt{Experiment} class:

\begin{minted}{python}
class Experiment:
    def __init__(self, config_file):
        self.is_running = False  # Variable to check if the scan is running
    [...]

    def do_scan(self):
        if self.is_running:
            print('Scan already running')
            return
        self.is_running = True
        [...]
        for volt in self.scan_range:
            [...]
        self.is_running = False
\end{minted}

We have removed all the code that didn't change to keep it shorter. It is very important to define the \texttt{self.is\_running} attribute in the \texttt{\_\_init\_\_} because if we don't, the program would crash the first time we try to run a scan. Then, we check if the scan is already running. If it is, we print a message and stop the execution by using a \texttt{return}. This pattern is very handy to avoid using a very long if-else block. Then we switch the attribute right before starting the loop and back to false when we are done. This should be enough to prevent two threads from running a scan at the same time. We can go ahead and re-run the script to see that this time we get a nice message warning us that a scan is already taking place.

\warning{People experienced with threads may dislike the solution above, and they are right to do so. There is a chance that both threads check if the scan is running one exactly after the other, and then both will see it is not. Then both threads will set our safety variable to true, and we will face the same issues as before. This can happen only if we trigger two threads to do the scan one right after the other. In practical terms, however, we will be triggering the scan by clicking on a button, or by typing on the Python interpreter, and this will never be quicker than checking whether a variable is true or not. However, as programs become more complex, these concerns can become real issues\footnote{We have written an extensive tutorial on threading on our website, feel free to check it out to learn more.}}

There is only one extra feature that our \texttt{do\_scan} method is missing: the ability to stop whenever we want. We have seen that the main thread is able to read data stored in the experiment class even if this data is generated by a child thread. The same works the other way around. The child thread can see the changes to attributes of the experiment class. Therefore, we can use an attribute, similar to the \texttt{is\_running} that will signal that we want to stop the scan. We can modify the \texttt{do\_scan} again:

\begin{minted}{python}
    def do_scan(self):
        [...]
        self.keep_running = True
        for volt in self.scan_range:
            if not self.keep_running:
                break
\end{minted}
When we start the scan, \texttt{keep\_running} is set to \texttt{True} because we, obviously, want to keep running the scan. Then, in every iteration, we check whether this variable changed or not. If it was set to \texttt{False}, then the loop would stop. We can see how this would work in the \textbf{run\_experiment.py} script:

\begin{minted}{python}
    [...]
    scan1 = threading.Thread(target=experiment.do_scan)
    scan1.start()
    sleep(2)
    experiment.keep_running = False
    print('Experiment finished')
    experiment.finalize()
\end{minted}

The example is relatively straightforward. We start the scan, wait for two seconds and then we stop it. It is not a particularly useful situation, but it is crucial for cases when we want to be in control and not lose data nor damage the equipment.

\exercise{Use the input from the keyboard to stop the scan. The best approach is to wait while the thread is alive, such as we did for plotting. Then, you can use a try/except block, using the KeyboardInterrupt exception.}

\section{Improving the Experiment Class}\label{section:improving-experiment}
Through the book we have always came back to the \emph{Onion Principle}. Every time we find something that believe can be useful in the future, we don't leave it as an example on a Python script, but we try to implement it in a more robust way. This is what is happening with threads. We have seen that we can run the scan without blocking the program, but that can be achieved by remembering how to work with threads. A better idea would be to implement the threads directly in the Experiment class.

In this case, the best idea is to generate a new method that will take care of starting the scan in a separate thread, and another method just for stopping. Having specific methods is a very good way of not having to remember what attributes are meant to do what. Let's create the methods for starting and stopping the scan, directly on the Experiment class:

\begin{minted}{python}
    import threading
    [...]

    def start_scan(self):
        self.scan_thread = threading.Thread(target=self.do_scan)
        self.scan_thread.start()

    def stop_scan(self):
        self.keep_running = False
\end{minted}

And now we can update the \textbf{run\_experiment.py} script to make it look much better:

\begin{minted}{python}
    experiment.start_scan()
    while experiment.is_running:
        print('Experiment Running')
    experiment.finalize()
\end{minted}

This code is clean and easy to understand. One of the advantages is that it also gives us freedom to decide whether we want to run the scan on its own thread or not. There is only one more detail, and is that if we finalize the experiment while the scan is running, then we may face some issues trying to read from a closed device. It is better to update the finalize method:

\begin{minted}{python}
    def finalize(self):
        print('Finalizing Experiment')
        self.stop_scan()
        while self.is_running:
            time.sleep(.1)
        [...]
\end{minted}

We stop the scan, and then we wait until we are certain it has finished. This is important because it may happen that the delay between data points is very large, or because acquiring data takes long, such as what happens with long exposure times of cameras. Once we know the scan stopped, then we continue to close the communication.

\subsection{Threads and Jupyter Notebooks}\label{subsection:Jupyter}
Running experiments on Jupyter Notebooks can be a very good solution to combinethe generation of data, its documentation, and its analysis in only one tool. If used properly, Jupyter notebooks can be a great resource for the experimentalist. However, real-time plotting of data within notebooks is virtually impossible. Building interactive tools on top of a notebook is very complicated, and that is why we chose to follow a different path for the last chapters.

However, for people who are already using Jupyter, it is worth mentioning that the way in which we developed the Experiment and Device models, makes them readily available to be incorporated to a notebook. Moreover, the use of threads directly built in the class, allows us to run the scan in one cell and simoultaneusly plot the data on another cell. This can help prototype programs very quickly, and can be also the starting point for plugging an experiment directly to the data analysis pipeline.

\section{Conclusions}\label{section:conclusions-run-experiment}
This chapter was aimed at polishing some of the details that we were missing in order to be able to perform a scan in a robust way. The most interesting aspect of the chapter is the inclusion of threads to be able to run a scan and still maintain control of the program. We quickly saw how to plot while the scan runs, and took a look at the problems that can appear when we run multiple threads. We explored some interesting strategies to prevent a second scan from starting, and for stopping the scan without the risk of losing data.

Threads open a lot of different possibilities for Python developers, not only for lab applications. They are, however, a complex topic that needs to be taken seriously. The pattern we decided to follow in this chapter, exchanging information between main and child threads using attributes of a class is very simple, but also prone to problems. However, we do believe that in the context of a program to control an experiment, there is rarely the need to go beyond what we have done. This does not mean that we shouldn't keep an eye in case problems arise.
