\chapter{Run an experiment}\label{chapter:run-experiment}


\section{Introduction}
In the previous chapter, we have seen how to develop an experiment model and how to use it from a simple script. In this chapter we are going to explore how to bring it to the next level. So far we can run the experiment only with the parameters specified on the config file, but we are not limited to them. Moreover, once the scan starts, there is no way of stopping it unless we completely stop the program. That leads to missing data and is not particularly helpful.

Following the \emph{Onion Principle}, it is now time to bring the experiment model to the next level.


\section{Running an Experiment}\label{section:running-nexperiment}
In the previous chapter we have seen that an experiment can be run from a simple script in which each of the steps needed are triggered one after the other. We called that script \textbf{run\_experiment.py} and had the following code (skipping some less relevant lines):

\begin{minted}{python}
    from PythonForTheLab.model.experiment import Experiment

    experiment = Experiment('experiment.yml')
    experiment.load_config()

    experiment.load_daq()

    experiment.do_scan()
    experiment.save_data()
    experiment.finalize()
\end{minted}

This is relatively straightforward, but not the only thing that can be done with the experiment. We can access the attributes of the experiment class while we permorming a measurement. For example, we could show the data once the scan is completed:

\begin{minted}{python}
    experiment.do_scan()
    print(experiment.scan_data)
\end{minted}

But we could also change the parameters of the scan after loading the config file. Sharing information with classes in Python is always two ways: we can read from them, but we can also write to them. Let's see what happens when we change the \texttt{config} attribute of the experiment before triggering the scan. We can do something like the following:

\begin{minted}{python}
    [...]

    experiment.config['Scan']['num_steps'] = 5
    experiment.do_scan()
    experiment.save_data()
    experiment.config['Scan']['num_steps'] = 10
    experiment.do_scan()
    experiment.save_data()
    experiment.finalize()
\end{minted}

Any of the values stored in the \texttt{config} of the experiment can be changed at any time. It can be changed from a script, it could be changed from the running script. We are not limited to running the experiment from a script, we can also run it from the Python interpreter. The steps would be the same. For people familiar with Jupyter notebooks, for example, the experiments can be run directly from within them. There are some extra benefits of using notebooks, such as the possibility of documenting the work, but we leave the discussion for the Advanced Python for the Lab book.

\note{Running from the Python interpreter is normally cumbersome. There is another version of the interpreter called \textbf{bpython} which has auto-complete functions, as well as it allows you to edit code before running it. We don't encourage people to run experiments from the interpreter, but some times it is the handiest solution to change values when desired.}

In the code above, we have changed the value of the number of steps before triggering a scan. First we have set it to 5 steps and then to 10 steps. We can check the metadata and we will see that this information was actually saved. If we open the data file, we would also see a different number of data points. This flow proposes very interesting possibilities. For example, if we would like to see if there is any form of hysteresis on the measurements, we could vary the delay between data points.

\exercise{Write a for-loop that changes the delay between data points after each scan. Remember to save the data in order to explore the differences}

If we start developing complex logic in the running script, it is fair to wonder if it is better putting all that logic into the experiment class. As always, when we do things only once, knowing they'll be one-off tasks, then it is quicker to run from a script. If, however, that one-off becomes an essential part of our experiments, or we believe that others could benefit from doing the same measurement, then we should implement the code in the class. As always, common sense is the best ally for a scientific developer.

One of the important things to note is that when we work with units, we leave the values as string, and only transform them to real quantities when we need them. If we explore the \texttt{do_scan} method, we would see that we start by running the parameters through the unit registry. This means that if we want to change the values of, for example, the start, stop, or delay we only need to change a string:

\begin{minted}{python}
    experiment.config['Scan']['start'] = '2.2V'
    experiment.config['Scan']['delay'] = '200ms'
\end{minted}

\section{Plotting Scan Data}\label{section:plotting}
We have seen how to perform a measurement, how to change the parameters of the scan without changing the config file, and how to save data. However, we are not doing anything with the data after we save it. Being able to see what we are doing through a plot seems a very nice addition to our work flow. For plotting we are going to use a library called \href{http://www.pyqtgraph.org/}{PyQtGraph} which was developed mainly to generate fast data visualizations. Exactly what we need when we are dealing with experiments. Normally, people a bit more familiar with Python get acquainted with matplotlib, which is a great tool for paper-ready plots, but a bit slow for real-time visualization. In any case, at this stage we don't care about speed, therefore if you more confident with another tool, feel more free to adapt the code to use them. In any case, PyQtGraph will come back later, when we build the user interface.

Making a simple plot with PyQtGraph is very easy. We can add the following after we perform the scan, in the \textbf{run\_experiment.py} script file:

\begin{minted}{python}
    import pyqtgraph as pg

    [...]

    pg.plot(experiment.scan_range, experiment.scan_data)
\end{minted}

It is simple, but it works. PyQtGraph also gives us some mouse interactions out of the box. We can drag the image, we can zoom in and out with the mouse wheel, we can also transform the scale of the axes by right-clicking. We can make the plot a bit better looking by adding labels and a title:

\begin{minted}{python}
    PlotWidget = pg.plot(title="Plotting I vs V")
    PlotWidget.setLabel('bottom', f'Channel: {experiment.config['Scan']['channel_out']}', units="V")
    PlotWidget.setLabel('left', f'Channel: {experiment.config['Scan']['channel_in']}', units="V")
    PlotWidget.plot(experiment.scan_values, experiment.scan_data)
\end{minted}

Plotting with PyQtGraph is relatively simple. However, we can only plot data after the scan is finished. The \texttt{do\_scan} method takes relatively long to complete. When a method, or a function, work in this way, they are called blocking functions. The program can't continue until they finish. If we would like to monitor the progress of the experiment while running, we need to find a way of making the scan in a non-blocking way.

\section{Running the scan in a nonblocking way}\label{section:nonblocking}

Methods or functions like \texttt{do_scan} take a long time to run. Imagine if we would be acquiring a movie for one hour, the function would take one hour to complete. If we would be running a very complex simulation or data analysis process, functions can also take very long to complete. However, both scenarios are different from each other. Sometimes functions take long to execute because they are computationally expensive. They need a lot of cycles of the processor in order to finish. Sometimes they take long to execute because the process is slow. For instance, when we do a scan, most of the time the program is waiting in a \texttt{python}{sleep}, or is waiting for the device to output a value. Waiting is not computationally expensive, which means that our computer computer is capable of performing other tasks at the same time if we let it.

Python has different options for achieving what we are after, but the one that gives best results, not only in terms of power, but also in terms of simplicity to implement is the \emph{multithreading} module, which we will explore in the next section.

\subsection{Threads in Python}\label{subsection:multithreading}
You can think about threads as different lines of execution. A Thread
would be similar to opening different terminals and running Python in
each one of them. The advantage is that since you are running all your
threads in the same Python interpreter, you can easily exchange
information within them. Let's see first a simple example of a function that takes long to execute:

\begin{minted}{python}
    import threading
    from time import sleep

    def func(steps):
    for i in range(steps):
    sleep(1)
    print('Step: {}'.format(i))

    t = threading.Thread(target=func, args=(3, ))
    print('Here')
    t.start()
    sleep(2)
    print('There')
\end{minted}

If you run the code above, you should see the following output:

\begin{minted}{text}
    Here
    Step: 0
    Step: 1
    There
    Step: 2
    Step: 3
\end{minted}

What is happening is very interesting. If you run the function
\mintinline{python}{func} on its own, you will see that the numbers appear one by
one, and while the function doesn't end, you won't be able to do
anything else. However, when you create a thread, i.e. when you execute
\mintinline{python}{threading.Thread}, the target function is going to run in a
separate space, therefore not blocking your program. When you create a
\emph{thread}, you have to specify the function you are going to
execute, bearing in mind that it is the function itself and not the
instance, i.e., you don't append the \mintinline{python}{()}. If the function takes
arguments, you add them as a comma-separated list, even if it is only
one as in the example above.

When you create the thread, the function is not executed, it is waiting
for the \mintinline{python}{start()} signal to start running. What you see is that
even after the thread starts, the
\mintinline{python}{print('There')} statement is
being executed. First, you print
\mintinline{python}{'Here'}, you start the
\emph{thread}, you wait for two seconds, in which \mintinline{python}{func} prints
its first two steps, you print
\mintinline{python}{'There'} while the thread
continues its execution. Working with threads can get very complicated
when you need to share information, or when you need to be sure one
specific thread finished before you do something else, etc. For simple
examples, however, it is very handy and easy to understand.

You can also have several threads running at the same time, and you can
assign names to them:

Python

\begin{minted}{python}
    def func(steps):
    print(threading.currentThread().getName(), 'Starting')
    for i in range(steps):
    sleep(1)
    print('Step: {}'.format(i))
    print(threading.currentThread().getName(), 'Finishing')


    first_t = threading.Thread(name='First Thread',
    target=func, args=(3, ))
    second_t = threading.Thread(name='Second Thread',
    target=func, args=(3, ))
    print('Here')
    first_t.start()
    second_t.start()
    sleep(2)
    print('There')
\end{minted}

Go ahead and run the script to see what happens.


\section{Threads for the experiment model}\label{threads-for-the-experimentmodel}

Going back to the experiment model, you can already test what you have
learned by executing the \mintinline{python}{do_scan} method in its own thread.
Since the method doesn't take any arguments, the line should look like:

\begin{minted}{python}
    t = threading.Thread(target=e.do_scan)
\end{minted}

While the scan is running in the background, you can do other things in
the main thread, such as plotting. Let's see how you can do that. You
need to refresh the plot while the acquisition is happening, and
therefore you will need to update the plot within a loop. One possible
way of doing it is like this:

\begin{minted}{python}
    import threading
    import pyqtgraph as pg
    from time import sleep
    from PythonForTheLab.Model import Experiment

    e = Experiment()
    e.load_config('config.yml')
    e.load_daq()
    t = threading.Thread(target=e.do_scan)
    t.start()

    PlotWidget = pg.plot(title="Plotting I vs V")
    PlotWidget.setLabel('bottom', 'Port: {}'.format(
    e.properties['Scan']['port_out']), units="V")
    PlotWidget.setLabel('left', 'Port: {}'.format(
    e.properties['Scan']['port_in']), units="V")
    PlotWidget.plot(e.xdata_scan, e.ydata_scan)

    while t.isAlive():
    PlotWidget.plot(e.xdata_scan, e.ydata_scan, clear=True)
    pg.QtGui.QApplication.processEvents()
    sleep(1)
\end{minted}

The beginning of the code is a combination of what you have been doing
for running the scan and plotting and the use of threads. The important
part is what is happening in the \mintinline{python}{while} loop. First, you check
that the thread is still running with the \mintinline{python}{isAlive()} method.
Then, within the loop, you update the plot with the data in the
experiment class. It is very important to note that even if the
\mintinline{python}{do_scan} method is running in a different thread, its data is
accessible from the main thread. There is an extra line in which you
declare a \mintinline{python}{QApplication}. For the time being, do not worry about
it. Its only purpose is to use the plot that you have already created a
few lines above.

Exchanging information with a class means that you cannot only read from
it but that you can also write to it. Therefore, a clever way of
stopping a scan is by checking the status of a property within the loop.
For example, you can add the following code to the \mintinline{python}{do_scan}
method of the experiment model:

\begin{minted}{python}
    if self.stop_scan:
    break
\end{minted}

What is happening is that if the property \mintinline{python}{stop_scan} is set to
\mintinline{python}{True}, the for-loop in which you are running the scan will stop.
Remember that if you add a new property such as \mintinline{python}{stop_scan}, you
have to initialize it in the \mintinline{python}{__init__} method of the class.
It is also important to set the property to \mintinline{python}{False} every time
you start a new scan. If you fail to do that, after you stop a scan you
won't be able to run another one. The \mintinline{python}{do_scan} method will look
like this:

\begin{minted}{python}
    def do_scan(self):
    self.stop_scan = False
    [...]
    for value in scan:
    if self.stop_scan:
    break
    [...]
\end{minted}

The \mintinline{python}{[...]} means that there is code that is not being
displayed, for brevity.

\exercise{Run the example with the threads again, but this time change the value
of \mintinline{python}{e.stop_scan} to \mintinline{python}{True} after a certain number of plot
updates.}

\exercise{Use the input from the keyboard to stop the scan}

Finally, it is important to point out that sometimes you actually need
to wait for a thread to finish. Imagine that you want to perform several
scans, you don't want to do them at the same time, but one after the
other. To wait for a thread to finish you can use the method
\mintinline{python}{join()}, like this:

\begin{minted}{python}
    t = threading.Thread(target=e.do_scan)
    t.start()
    print('Thread Running')
    t.join()
    print('Thread Stopped')
\end{minted}

In this example, \mintinline{python}{Thread Stopped} will appear only after the
Thread has finished. Moreover, when you start working with this design
pattern in mind, you will realize that there is nothing that forbids the
user from triggering two scans at the same time, in two different
threads. This can give a lot of headaches when you start developing
complex applications. Sometimes, the errors that appear are going to be
very hard to debug. It is very hard to transmit all the different things
that can happen once a different person starts using your software.

\exercise{Add an extra property to the experiment model called
    \mintinline{python}{scan_is_running}. Set it to \mintinline{python}{True} when the scan runs
    and \mintinline{python}{False} when the scan stops. Use it to avoid two scans to run
    simultaneously.}

Threads work also in Jupyter notebooks. If you start a thread in a cell,
you will see that it immediately releases the interpreter. You can move
to a different thread and keep working, updating a plot, etc. Whenever
you want to stop the scan, you can do it as before, changing the value
of the \mintinline{python}{stop_scan} property.


\section{Word of Caution with Threads}\label{word-of-caution-withthreads}

Threads are a very complex topic in any programming language, and even
if the examples that you have seen up to now seem straightforward, you
need to be cautious about how you implement threads in larger programs.
Today computers with multi-core processors are ubiquitous. However, when
you run a Python program it is going to run only within one of the cores
of the computer. Moreover, each core can run only one thread at a time.

When you run multiple threads, the processor very quickly switches from
one thread to another. The first thread runs for a while, then it stops,
another thread runs for a while, stops, etc. Switching from a thread to
another is not free for the processor and even if the process is not
doing anything, the processor has no way of knowing it and will switch
to it anyways. While you have processes like the ones you have developed
up to now, which are not computationally expensive, you won't notice
performance issues. However, if you start dealing with image analysis,
data processing, etc. you will have to find better alternatives.

If you want to test the limits of threading in Python, you can generate
large random arrays. Run the process on different threads and check the
status of your computer. You will notice that not all the cores
available are in use, but one of them is going to be at 100\%. Moreover,
you can check what takes longer if generating 4 random arrays in 4
different threads or one after the other.

You shouldn't confuse the idea of multithreading with parallelizing
code. When you parallelize code you are able to use all the cores of
your computer at the same time. Threading just allows you to run code at
the same time on the same processor. The subject is vast and exceeds the
objectives of this book. However, you need to be aware of the
limitations of the techniques that you use and the degree of
applicability that they have. If you want to develop code that runs in
parallel, you can look at libraries such as \emph{mpi} or
\emph{multiprocessing}.


\section{Conclusions}\label{conclusions}
This is a chapter where you can see how all your previous work plays out
nicely together. Developing drivers and models may seem a lot of
unnecessary work, but when you see everything coming together you start
to realize that it really pays off being organized and systematic with
the code. If you stop reading the book in this chapter, you would have
already acquired a lot of knowledge that can improve your work in the
lab. You have learned the {MVC} pattern, you have developed models, and
worked with threads. You have also seen how to store metadata and use it
to run an experiment again.

The most important message that you should take with you after these few
chapters is that the code you write today should be useful tomorrow.
You have started with simple tasks, such as communicating with a serial
device, and some chapters later, the same code is being used for
performing experiments. If you think about it, the base driver was never
updated since you first developed it, it just changed folders. This is,
in principle, what you expect to happen with all the code you develop.
Each class, each function, can be a building block for something else.
You will see how this materializes in the next two chapters when you
develop a Graphical User Interface ({GUI}).

When you work in the lab, you will notice that every device is
different, has different requisites, and a different behavior. It is
very important that you understand, first of all, what do you want to do
with the devices that you have available. Devices for the lab are not
home appliances and may have options which you should understand by
reading the manual. Perhaps you need external triggers, an amplifier, a
filter, etc. Once you understand what experiment you are actually
performing, then you can start programming, but not the other
way around.
